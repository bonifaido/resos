// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct FrameworkID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkID {}

impl FrameworkID {
    pub fn new() -> FrameworkID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkID {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkID,
        };
        unsafe {
            instance.get(|| {
                FrameworkID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for FrameworkID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkID {
    fn new() -> FrameworkID {
        FrameworkID::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    FrameworkID::has_value,
                    FrameworkID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkID>(
                    "FrameworkID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkID {
    fn eq(&self, other: &FrameworkID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct OfferID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for OfferID {}

impl OfferID {
    pub fn new() -> OfferID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static OfferID {
        static mut instance: ::protobuf::lazy::Lazy<OfferID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OfferID,
        };
        unsafe {
            instance.get(|| {
                OfferID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for OfferID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<OfferID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for OfferID {
    fn new() -> OfferID {
        OfferID::new()
    }

    fn descriptor_static(_: ::std::option::Option<OfferID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    OfferID::has_value,
                    OfferID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OfferID>(
                    "OfferID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for OfferID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for OfferID {
    fn eq(&self, other: &OfferID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for OfferID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AgentID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AgentID {}

impl AgentID {
    pub fn new() -> AgentID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AgentID {
        static mut instance: ::protobuf::lazy::Lazy<AgentID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentID,
        };
        unsafe {
            instance.get(|| {
                AgentID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for AgentID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AgentID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AgentID {
    fn new() -> AgentID {
        AgentID::new()
    }

    fn descriptor_static(_: ::std::option::Option<AgentID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    AgentID::has_value,
                    AgentID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentID>(
                    "AgentID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AgentID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AgentID {
    fn eq(&self, other: &AgentID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AgentID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TaskID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskID {}

impl TaskID {
    pub fn new() -> TaskID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskID {
        static mut instance: ::protobuf::lazy::Lazy<TaskID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskID,
        };
        unsafe {
            instance.get(|| {
                TaskID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for TaskID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskID {
    fn new() -> TaskID {
        TaskID::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    TaskID::has_value,
                    TaskID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskID>(
                    "TaskID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskID {
    fn eq(&self, other: &TaskID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ExecutorID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ExecutorID {}

impl ExecutorID {
    pub fn new() -> ExecutorID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorID {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorID,
        };
        unsafe {
            instance.get(|| {
                ExecutorID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ExecutorID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ExecutorID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorID {
    fn new() -> ExecutorID {
        ExecutorID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    ExecutorID::has_value,
                    ExecutorID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorID>(
                    "ExecutorID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ExecutorID {
    fn eq(&self, other: &ExecutorID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ExecutorID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerID {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerID {}

impl ContainerID {
    pub fn new() -> ContainerID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerID {
        static mut instance: ::protobuf::lazy::Lazy<ContainerID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerID,
        };
        unsafe {
            instance.get(|| {
                ContainerID {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerID {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerID {
    fn new() -> ContainerID {
        ContainerID::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    ContainerID::has_value,
                    ContainerID::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerID>(
                    "ContainerID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerID {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerID {
    fn eq(&self, other: &ContainerID) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TimeInfo {
    // message fields
    nanoseconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TimeInfo {}

impl TimeInfo {
    pub fn new() -> TimeInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TimeInfo {
        static mut instance: ::protobuf::lazy::Lazy<TimeInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeInfo,
        };
        unsafe {
            instance.get(|| {
                TimeInfo {
                    nanoseconds: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 nanoseconds = 1;

    pub fn clear_nanoseconds(&mut self) {
        self.nanoseconds = ::std::option::Option::None;
    }

    pub fn has_nanoseconds(&self) -> bool {
        self.nanoseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanoseconds(&mut self, v: i64) {
        self.nanoseconds = ::std::option::Option::Some(v);
    }

    pub fn get_nanoseconds<'a>(&self) -> i64 {
        self.nanoseconds.unwrap_or(0)
    }
}

impl ::protobuf::Message for TimeInfo {
    fn is_initialized(&self) -> bool {
        if self.nanoseconds.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.nanoseconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.nanoseconds.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nanoseconds {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TimeInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TimeInfo {
    fn new() -> TimeInfo {
        TimeInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TimeInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "nanoseconds",
                    TimeInfo::has_nanoseconds,
                    TimeInfo::get_nanoseconds,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeInfo>(
                    "TimeInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TimeInfo {
    fn clear(&mut self) {
        self.clear_nanoseconds();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TimeInfo {
    fn eq(&self, other: &TimeInfo) -> bool {
        self.nanoseconds == other.nanoseconds &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TimeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DurationInfo {
    // message fields
    nanoseconds: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DurationInfo {}

impl DurationInfo {
    pub fn new() -> DurationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DurationInfo {
        static mut instance: ::protobuf::lazy::Lazy<DurationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DurationInfo,
        };
        unsafe {
            instance.get(|| {
                DurationInfo {
                    nanoseconds: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required int64 nanoseconds = 1;

    pub fn clear_nanoseconds(&mut self) {
        self.nanoseconds = ::std::option::Option::None;
    }

    pub fn has_nanoseconds(&self) -> bool {
        self.nanoseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanoseconds(&mut self, v: i64) {
        self.nanoseconds = ::std::option::Option::Some(v);
    }

    pub fn get_nanoseconds<'a>(&self) -> i64 {
        self.nanoseconds.unwrap_or(0)
    }
}

impl ::protobuf::Message for DurationInfo {
    fn is_initialized(&self) -> bool {
        if self.nanoseconds.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.nanoseconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.nanoseconds.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nanoseconds {
            try!(os.write_int64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DurationInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DurationInfo {
    fn new() -> DurationInfo {
        DurationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DurationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "nanoseconds",
                    DurationInfo::has_nanoseconds,
                    DurationInfo::get_nanoseconds,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DurationInfo>(
                    "DurationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DurationInfo {
    fn clear(&mut self) {
        self.clear_nanoseconds();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DurationInfo {
    fn eq(&self, other: &DurationInfo) -> bool {
        self.nanoseconds == other.nanoseconds &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DurationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Address {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ip: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Address {}

impl Address {
    pub fn new() -> Address {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Address {
        static mut instance: ::protobuf::lazy::Lazy<Address> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Address,
        };
        unsafe {
            instance.get(|| {
                Address {
                    hostname: ::protobuf::SingularField::none(),
                    ip: ::protobuf::SingularField::none(),
                    port: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        };
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip<'a>(&'a self) -> &'a str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required int32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> i32 {
        self.port.unwrap_or(0)
    }
}

impl ::protobuf::Message for Address {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.port {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Address>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Address {
    fn new() -> Address {
        Address::new()
    }

    fn descriptor_static(_: ::std::option::Option<Address>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    Address::has_hostname,
                    Address::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip",
                    Address::has_ip,
                    Address::get_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "port",
                    Address::has_port,
                    Address::get_port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Address>(
                    "Address",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Address {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_ip();
        self.clear_port();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Address {
    fn eq(&self, other: &Address) -> bool {
        self.hostname == other.hostname &&
        self.ip == other.ip &&
        self.port == other.port &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct URL {
    // message fields
    scheme: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    path: ::protobuf::SingularField<::std::string::String>,
    query: ::protobuf::RepeatedField<Parameter>,
    fragment: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for URL {}

impl URL {
    pub fn new() -> URL {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static URL {
        static mut instance: ::protobuf::lazy::Lazy<URL> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const URL,
        };
        unsafe {
            instance.get(|| {
                URL {
                    scheme: ::protobuf::SingularField::none(),
                    address: ::protobuf::SingularPtrField::none(),
                    path: ::protobuf::SingularField::none(),
                    query: ::protobuf::RepeatedField::new(),
                    fragment: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string scheme = 1;

    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        };
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_scheme<'a>(&'a self) -> &'a str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.v1.Address address = 2;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut Address {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }

    // optional string path = 3;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .mesos.v1.Parameter query = 4;

    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.query, ::protobuf::RepeatedField::new())
    }

    pub fn get_query<'a>(&'a self) -> &'a [Parameter] {
        &self.query
    }

    // optional string fragment = 5;

    pub fn clear_fragment(&mut self) {
        self.fragment.clear();
    }

    pub fn has_fragment(&self) -> bool {
        self.fragment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fragment(&mut self, v: ::std::string::String) {
        self.fragment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fragment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.fragment.is_none() {
            self.fragment.set_default();
        };
        self.fragment.as_mut().unwrap()
    }

    // Take field
    pub fn take_fragment(&mut self) -> ::std::string::String {
        self.fragment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_fragment<'a>(&'a self) -> &'a str {
        match self.fragment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for URL {
    fn is_initialized(&self) -> bool {
        if self.scheme.is_none() {
            return false;
        };
        if self.address.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scheme));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fragment));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.scheme.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.address.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.query.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.fragment.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.scheme.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.address.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(3, &v));
        };
        for v in self.query.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.fragment.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<URL>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for URL {
    fn new() -> URL {
        URL::new()
    }

    fn descriptor_static(_: ::std::option::Option<URL>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "scheme",
                    URL::has_scheme,
                    URL::get_scheme,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "address",
                    URL::has_address,
                    URL::get_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    URL::has_path,
                    URL::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "query",
                    URL::get_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "fragment",
                    URL::has_fragment,
                    URL::get_fragment,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<URL>(
                    "URL",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for URL {
    fn clear(&mut self) {
        self.clear_scheme();
        self.clear_address();
        self.clear_path();
        self.clear_query();
        self.clear_fragment();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for URL {
    fn eq(&self, other: &URL) -> bool {
        self.scheme == other.scheme &&
        self.address == other.address &&
        self.path == other.path &&
        self.query == other.query &&
        self.fragment == other.fragment &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for URL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Unavailability {
    // message fields
    start: ::protobuf::SingularPtrField<TimeInfo>,
    duration: ::protobuf::SingularPtrField<DurationInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Unavailability {}

impl Unavailability {
    pub fn new() -> Unavailability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Unavailability {
        static mut instance: ::protobuf::lazy::Lazy<Unavailability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Unavailability,
        };
        unsafe {
            instance.get(|| {
                Unavailability {
                    start: ::protobuf::SingularPtrField::none(),
                    duration: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.TimeInfo start = 1;

    pub fn clear_start(&mut self) {
        self.start.clear();
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: TimeInfo) {
        self.start = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start<'a>(&'a mut self) -> &'a mut TimeInfo {
        if self.start.is_none() {
            self.start.set_default();
        };
        self.start.as_mut().unwrap()
    }

    // Take field
    pub fn take_start(&mut self) -> TimeInfo {
        self.start.take().unwrap_or_else(|| TimeInfo::new())
    }

    pub fn get_start<'a>(&'a self) -> &'a TimeInfo {
        self.start.as_ref().unwrap_or_else(|| TimeInfo::default_instance())
    }

    // optional .mesos.v1.DurationInfo duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: DurationInfo) {
        self.duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration<'a>(&'a mut self) -> &'a mut DurationInfo {
        if self.duration.is_none() {
            self.duration.set_default();
        };
        self.duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_duration(&mut self) -> DurationInfo {
        self.duration.take().unwrap_or_else(|| DurationInfo::new())
    }

    pub fn get_duration<'a>(&'a self) -> &'a DurationInfo {
        self.duration.as_ref().unwrap_or_else(|| DurationInfo::default_instance())
    }
}

impl ::protobuf::Message for Unavailability {
    fn is_initialized(&self) -> bool {
        if self.start.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.duration));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.start.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.duration.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.start.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.duration.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Unavailability>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Unavailability {
    fn new() -> Unavailability {
        Unavailability::new()
    }

    fn descriptor_static(_: ::std::option::Option<Unavailability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "start",
                    Unavailability::has_start,
                    Unavailability::get_start,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "duration",
                    Unavailability::has_duration,
                    Unavailability::get_duration,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Unavailability>(
                    "Unavailability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Unavailability {
    fn clear(&mut self) {
        self.clear_start();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Unavailability {
    fn eq(&self, other: &Unavailability) -> bool {
        self.start == other.start &&
        self.duration == other.duration &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Unavailability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MachineID {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    ip: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MachineID {}

impl MachineID {
    pub fn new() -> MachineID {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MachineID {
        static mut instance: ::protobuf::lazy::Lazy<MachineID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MachineID,
        };
        unsafe {
            instance.get(|| {
                MachineID {
                    hostname: ::protobuf::SingularField::none(),
                    ip: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        };
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip<'a>(&'a self) -> &'a str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for MachineID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MachineID>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MachineID {
    fn new() -> MachineID {
        MachineID::new()
    }

    fn descriptor_static(_: ::std::option::Option<MachineID>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    MachineID::has_hostname,
                    MachineID::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip",
                    MachineID::has_ip,
                    MachineID::get_ip,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MachineID>(
                    "MachineID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MachineID {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_ip();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MachineID {
    fn eq(&self, other: &MachineID) -> bool {
        self.hostname == other.hostname &&
        self.ip == other.ip &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MachineID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MachineInfo {
    // message fields
    id: ::protobuf::SingularPtrField<MachineID>,
    mode: ::std::option::Option<MachineInfo_Mode>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MachineInfo {}

impl MachineInfo {
    pub fn new() -> MachineInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MachineInfo {
        static mut instance: ::protobuf::lazy::Lazy<MachineInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MachineInfo,
        };
        unsafe {
            instance.get(|| {
                MachineInfo {
                    id: ::protobuf::SingularPtrField::none(),
                    mode: ::std::option::Option::None,
                    unavailability: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.MachineID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: MachineID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut MachineID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> MachineID {
        self.id.take().unwrap_or_else(|| MachineID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a MachineID {
        self.id.as_ref().unwrap_or_else(|| MachineID::default_instance())
    }

    // optional .mesos.v1.MachineInfo.Mode mode = 2;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: MachineInfo_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode<'a>(&self) -> MachineInfo_Mode {
        self.mode.unwrap_or(MachineInfo_Mode::UP)
    }

    // optional .mesos.v1.Unavailability unavailability = 3;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability<'a>(&'a mut self) -> &'a mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        };
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability<'a>(&'a self) -> &'a Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }
}

impl ::protobuf::Message for MachineInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.mode = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.mode.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.unavailability.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.mode {
            try!(os.write_enum(2, v.value()));
        };
        if let Some(v) = self.unavailability.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MachineInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MachineInfo {
    fn new() -> MachineInfo {
        MachineInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<MachineInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    MachineInfo::has_id,
                    MachineInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "mode",
                    MachineInfo::has_mode,
                    MachineInfo::get_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "unavailability",
                    MachineInfo::has_unavailability,
                    MachineInfo::get_unavailability,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MachineInfo>(
                    "MachineInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MachineInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_mode();
        self.clear_unavailability();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MachineInfo {
    fn eq(&self, other: &MachineInfo) -> bool {
        self.id == other.id &&
        self.mode == other.mode &&
        self.unavailability == other.unavailability &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MachineInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MachineInfo_Mode {
    UP = 1,
    DRAINING = 2,
    DOWN = 3,
}

impl ::protobuf::ProtobufEnum for MachineInfo_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MachineInfo_Mode> {
        match value {
            1 => ::std::option::Option::Some(MachineInfo_Mode::UP),
            2 => ::std::option::Option::Some(MachineInfo_Mode::DRAINING),
            3 => ::std::option::Option::Some(MachineInfo_Mode::DOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MachineInfo_Mode] = &[
            MachineInfo_Mode::UP,
            MachineInfo_Mode::DRAINING,
            MachineInfo_Mode::DOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<MachineInfo_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MachineInfo_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MachineInfo_Mode {
}

#[derive(Clone,Default)]
pub struct FrameworkInfo {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularPtrField<FrameworkID>,
    failover_timeout: ::std::option::Option<f64>,
    checkpoint: ::std::option::Option<bool>,
    role: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    webui_url: ::protobuf::SingularField<::std::string::String>,
    capabilities: ::protobuf::RepeatedField<FrameworkInfo_Capability>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkInfo {}

impl FrameworkInfo {
    pub fn new() -> FrameworkInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo,
        };
        unsafe {
            instance.get(|| {
                FrameworkInfo {
                    user: ::protobuf::SingularField::none(),
                    name: ::protobuf::SingularField::none(),
                    id: ::protobuf::SingularPtrField::none(),
                    failover_timeout: ::std::option::Option::None,
                    checkpoint: ::std::option::Option::None,
                    role: ::protobuf::SingularField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    principal: ::protobuf::SingularField::none(),
                    webui_url: ::protobuf::SingularField::none(),
                    capabilities: ::protobuf::RepeatedField::new(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string user = 1;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        };
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user<'a>(&'a self) -> &'a str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.FrameworkID id = 3;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: FrameworkID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> FrameworkID {
        self.id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a FrameworkID {
        self.id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // optional double failover_timeout = 4;

    pub fn clear_failover_timeout(&mut self) {
        self.failover_timeout = ::std::option::Option::None;
    }

    pub fn has_failover_timeout(&self) -> bool {
        self.failover_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failover_timeout(&mut self, v: f64) {
        self.failover_timeout = ::std::option::Option::Some(v);
    }

    pub fn get_failover_timeout<'a>(&self) -> f64 {
        self.failover_timeout.unwrap_or(0f64)
    }

    // optional bool checkpoint = 5;

    pub fn clear_checkpoint(&mut self) {
        self.checkpoint = ::std::option::Option::None;
    }

    pub fn has_checkpoint(&self) -> bool {
        self.checkpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkpoint(&mut self, v: bool) {
        self.checkpoint = ::std::option::Option::Some(v);
    }

    pub fn get_checkpoint<'a>(&self) -> bool {
        self.checkpoint.unwrap_or(false)
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        };
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role<'a>(&'a self) -> &'a str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    // optional string hostname = 7;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string principal = 8;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string webui_url = 9;

    pub fn clear_webui_url(&mut self) {
        self.webui_url.clear();
    }

    pub fn has_webui_url(&self) -> bool {
        self.webui_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webui_url(&mut self, v: ::std::string::String) {
        self.webui_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webui_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.webui_url.is_none() {
            self.webui_url.set_default();
        };
        self.webui_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_webui_url(&mut self) -> ::std::string::String {
        self.webui_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_webui_url<'a>(&'a self) -> &'a str {
        match self.webui_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated .mesos.v1.FrameworkInfo.Capability capabilities = 10;

    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: ::protobuf::RepeatedField<FrameworkInfo_Capability>) {
        self.capabilities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capabilities<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        &mut self.capabilities
    }

    // Take field
    pub fn take_capabilities(&mut self) -> ::protobuf::RepeatedField<FrameworkInfo_Capability> {
        ::std::mem::replace(&mut self.capabilities, ::protobuf::RepeatedField::new())
    }

    pub fn get_capabilities<'a>(&'a self) -> &'a [FrameworkInfo_Capability] {
        &self.capabilities
    }

    // optional .mesos.v1.Labels labels = 11;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for FrameworkInfo {
    fn is_initialized(&self) -> bool {
        if self.user.is_none() {
            return false;
        };
        if self.name.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.failover_timeout = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.checkpoint = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webui_url));
                },
                10 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.capabilities));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.user.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.failover_timeout.is_some() {
            my_size += 9;
        };
        if self.checkpoint.is_some() {
            my_size += 2;
        };
        for value in self.role.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.webui_url.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.capabilities.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.user.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.failover_timeout {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.checkpoint {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.role.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.webui_url.as_ref() {
            try!(os.write_string(9, &v));
        };
        for v in self.capabilities.iter() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo {
    fn new() -> FrameworkInfo {
        FrameworkInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "user",
                    FrameworkInfo::has_user,
                    FrameworkInfo::get_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    FrameworkInfo::has_name,
                    FrameworkInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    FrameworkInfo::has_id,
                    FrameworkInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "failover_timeout",
                    FrameworkInfo::has_failover_timeout,
                    FrameworkInfo::get_failover_timeout,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "checkpoint",
                    FrameworkInfo::has_checkpoint,
                    FrameworkInfo::get_checkpoint,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "role",
                    FrameworkInfo::has_role,
                    FrameworkInfo::get_role,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    FrameworkInfo::has_hostname,
                    FrameworkInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    FrameworkInfo::has_principal,
                    FrameworkInfo::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "webui_url",
                    FrameworkInfo::has_webui_url,
                    FrameworkInfo::get_webui_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "capabilities",
                    FrameworkInfo::get_capabilities,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    FrameworkInfo::has_labels,
                    FrameworkInfo::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo>(
                    "FrameworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo {
    fn clear(&mut self) {
        self.clear_user();
        self.clear_name();
        self.clear_id();
        self.clear_failover_timeout();
        self.clear_checkpoint();
        self.clear_role();
        self.clear_hostname();
        self.clear_principal();
        self.clear_webui_url();
        self.clear_capabilities();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkInfo {
    fn eq(&self, other: &FrameworkInfo) -> bool {
        self.user == other.user &&
        self.name == other.name &&
        self.id == other.id &&
        self.failover_timeout == other.failover_timeout &&
        self.checkpoint == other.checkpoint &&
        self.role == other.role &&
        self.hostname == other.hostname &&
        self.principal == other.principal &&
        self.webui_url == other.webui_url &&
        self.capabilities == other.capabilities &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct FrameworkInfo_Capability {
    // message fields
    field_type: ::std::option::Option<FrameworkInfo_Capability_Type>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for FrameworkInfo_Capability {}

impl FrameworkInfo_Capability {
    pub fn new() -> FrameworkInfo_Capability {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static FrameworkInfo_Capability {
        static mut instance: ::protobuf::lazy::Lazy<FrameworkInfo_Capability> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FrameworkInfo_Capability,
        };
        unsafe {
            instance.get(|| {
                FrameworkInfo_Capability {
                    field_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.FrameworkInfo.Capability.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: FrameworkInfo_Capability_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> FrameworkInfo_Capability_Type {
        self.field_type.unwrap_or(FrameworkInfo_Capability_Type::UNKNOWN)
    }
}

impl ::protobuf::Message for FrameworkInfo_Capability {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<FrameworkInfo_Capability>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for FrameworkInfo_Capability {
    fn new() -> FrameworkInfo_Capability {
        FrameworkInfo_Capability::new()
    }

    fn descriptor_static(_: ::std::option::Option<FrameworkInfo_Capability>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    FrameworkInfo_Capability::has_field_type,
                    FrameworkInfo_Capability::get_field_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FrameworkInfo_Capability>(
                    "FrameworkInfo_Capability",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for FrameworkInfo_Capability {
    fn clear(&mut self) {
        self.clear_field_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for FrameworkInfo_Capability {
    fn eq(&self, other: &FrameworkInfo_Capability) -> bool {
        self.field_type == other.field_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for FrameworkInfo_Capability {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FrameworkInfo_Capability_Type {
    UNKNOWN = 0,
    REVOCABLE_RESOURCES = 1,
    TASK_KILLING_STATE = 2,
}

impl ::protobuf::ProtobufEnum for FrameworkInfo_Capability_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FrameworkInfo_Capability_Type> {
        match value {
            0 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::UNKNOWN),
            1 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES),
            2 => ::std::option::Option::Some(FrameworkInfo_Capability_Type::TASK_KILLING_STATE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FrameworkInfo_Capability_Type] = &[
            FrameworkInfo_Capability_Type::UNKNOWN,
            FrameworkInfo_Capability_Type::REVOCABLE_RESOURCES,
            FrameworkInfo_Capability_Type::TASK_KILLING_STATE,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<FrameworkInfo_Capability_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FrameworkInfo_Capability_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FrameworkInfo_Capability_Type {
}

#[derive(Clone,Default)]
pub struct HealthCheck {
    // message fields
    http: ::protobuf::SingularPtrField<HealthCheck_HTTP>,
    delay_seconds: ::std::option::Option<f64>,
    interval_seconds: ::std::option::Option<f64>,
    timeout_seconds: ::std::option::Option<f64>,
    consecutive_failures: ::std::option::Option<u32>,
    grace_period_seconds: ::std::option::Option<f64>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HealthCheck {}

impl HealthCheck {
    pub fn new() -> HealthCheck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck,
        };
        unsafe {
            instance.get(|| {
                HealthCheck {
                    http: ::protobuf::SingularPtrField::none(),
                    delay_seconds: ::std::option::Option::None,
                    interval_seconds: ::std::option::Option::None,
                    timeout_seconds: ::std::option::Option::None,
                    consecutive_failures: ::std::option::Option::None,
                    grace_period_seconds: ::std::option::Option::None,
                    command: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.HealthCheck.HTTP http = 1;

    pub fn clear_http(&mut self) {
        self.http.clear();
    }

    pub fn has_http(&self) -> bool {
        self.http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http(&mut self, v: HealthCheck_HTTP) {
        self.http = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http<'a>(&'a mut self) -> &'a mut HealthCheck_HTTP {
        if self.http.is_none() {
            self.http.set_default();
        };
        self.http.as_mut().unwrap()
    }

    // Take field
    pub fn take_http(&mut self) -> HealthCheck_HTTP {
        self.http.take().unwrap_or_else(|| HealthCheck_HTTP::new())
    }

    pub fn get_http<'a>(&'a self) -> &'a HealthCheck_HTTP {
        self.http.as_ref().unwrap_or_else(|| HealthCheck_HTTP::default_instance())
    }

    // optional double delay_seconds = 2;

    pub fn clear_delay_seconds(&mut self) {
        self.delay_seconds = ::std::option::Option::None;
    }

    pub fn has_delay_seconds(&self) -> bool {
        self.delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay_seconds(&mut self, v: f64) {
        self.delay_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_delay_seconds<'a>(&self) -> f64 {
        self.delay_seconds.unwrap_or(15f64)
    }

    // optional double interval_seconds = 3;

    pub fn clear_interval_seconds(&mut self) {
        self.interval_seconds = ::std::option::Option::None;
    }

    pub fn has_interval_seconds(&self) -> bool {
        self.interval_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_seconds(&mut self, v: f64) {
        self.interval_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_interval_seconds<'a>(&self) -> f64 {
        self.interval_seconds.unwrap_or(10f64)
    }

    // optional double timeout_seconds = 4;

    pub fn clear_timeout_seconds(&mut self) {
        self.timeout_seconds = ::std::option::Option::None;
    }

    pub fn has_timeout_seconds(&self) -> bool {
        self.timeout_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_seconds(&mut self, v: f64) {
        self.timeout_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_timeout_seconds<'a>(&self) -> f64 {
        self.timeout_seconds.unwrap_or(20f64)
    }

    // optional uint32 consecutive_failures = 5;

    pub fn clear_consecutive_failures(&mut self) {
        self.consecutive_failures = ::std::option::Option::None;
    }

    pub fn has_consecutive_failures(&self) -> bool {
        self.consecutive_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consecutive_failures(&mut self, v: u32) {
        self.consecutive_failures = ::std::option::Option::Some(v);
    }

    pub fn get_consecutive_failures<'a>(&self) -> u32 {
        self.consecutive_failures.unwrap_or(3u32)
    }

    // optional double grace_period_seconds = 6;

    pub fn clear_grace_period_seconds(&mut self) {
        self.grace_period_seconds = ::std::option::Option::None;
    }

    pub fn has_grace_period_seconds(&self) -> bool {
        self.grace_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grace_period_seconds(&mut self, v: f64) {
        self.grace_period_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_grace_period_seconds<'a>(&self) -> f64 {
        self.grace_period_seconds.unwrap_or(10f64)
    }

    // optional .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }
}

impl ::protobuf::Message for HealthCheck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.delay_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.interval_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.timeout_seconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.consecutive_failures = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.grace_period_seconds = ::std::option::Option::Some(tmp);
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.http.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.delay_seconds.is_some() {
            my_size += 9;
        };
        if self.interval_seconds.is_some() {
            my_size += 9;
        };
        if self.timeout_seconds.is_some() {
            my_size += 9;
        };
        for value in self.consecutive_failures.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.grace_period_seconds.is_some() {
            my_size += 9;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.http.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.delay_seconds {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.interval_seconds {
            try!(os.write_double(3, v));
        };
        if let Some(v) = self.timeout_seconds {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.consecutive_failures {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.grace_period_seconds {
            try!(os.write_double(6, v));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<HealthCheck>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck {
    fn new() -> HealthCheck {
        HealthCheck::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "http",
                    HealthCheck::has_http,
                    HealthCheck::get_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "delay_seconds",
                    HealthCheck::has_delay_seconds,
                    HealthCheck::get_delay_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "interval_seconds",
                    HealthCheck::has_interval_seconds,
                    HealthCheck::get_interval_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timeout_seconds",
                    HealthCheck::has_timeout_seconds,
                    HealthCheck::get_timeout_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "consecutive_failures",
                    HealthCheck::has_consecutive_failures,
                    HealthCheck::get_consecutive_failures,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "grace_period_seconds",
                    HealthCheck::has_grace_period_seconds,
                    HealthCheck::get_grace_period_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    HealthCheck::has_command,
                    HealthCheck::get_command,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck>(
                    "HealthCheck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck {
    fn clear(&mut self) {
        self.clear_http();
        self.clear_delay_seconds();
        self.clear_interval_seconds();
        self.clear_timeout_seconds();
        self.clear_consecutive_failures();
        self.clear_grace_period_seconds();
        self.clear_command();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for HealthCheck {
    fn eq(&self, other: &HealthCheck) -> bool {
        self.http == other.http &&
        self.delay_seconds == other.delay_seconds &&
        self.interval_seconds == other.interval_seconds &&
        self.timeout_seconds == other.timeout_seconds &&
        self.consecutive_failures == other.consecutive_failures &&
        self.grace_period_seconds == other.grace_period_seconds &&
        self.command == other.command &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct HealthCheck_HTTP {
    // message fields
    port: ::std::option::Option<u32>,
    path: ::protobuf::SingularField<::std::string::String>,
    statuses: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for HealthCheck_HTTP {}

impl HealthCheck_HTTP {
    pub fn new() -> HealthCheck_HTTP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static HealthCheck_HTTP {
        static mut instance: ::protobuf::lazy::Lazy<HealthCheck_HTTP> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthCheck_HTTP,
        };
        unsafe {
            instance.get(|| {
                HealthCheck_HTTP {
                    port: ::std::option::Option::None,
                    path: ::protobuf::SingularField::none(),
                    statuses: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 port = 1;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    // optional string path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "/",
        }
    }

    // repeated uint32 statuses = 4;

    pub fn clear_statuses(&mut self) {
        self.statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_statuses(&mut self, v: ::std::vec::Vec<u32>) {
        self.statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_statuses<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.statuses
    }

    // Take field
    pub fn take_statuses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.statuses, ::std::vec::Vec::new())
    }

    pub fn get_statuses<'a>(&'a self) -> &'a [u32] {
        &self.statuses
    }
}

impl ::protobuf::Message for HealthCheck_HTTP {
    fn is_initialized(&self) -> bool {
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.statuses));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.path.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.statuses.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.port {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.statuses.iter() {
            try!(os.write_uint32(4, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<HealthCheck_HTTP>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for HealthCheck_HTTP {
    fn new() -> HealthCheck_HTTP {
        HealthCheck_HTTP::new()
    }

    fn descriptor_static(_: ::std::option::Option<HealthCheck_HTTP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "port",
                    HealthCheck_HTTP::has_port,
                    HealthCheck_HTTP::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "path",
                    HealthCheck_HTTP::has_path,
                    HealthCheck_HTTP::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "statuses",
                    HealthCheck_HTTP::get_statuses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthCheck_HTTP>(
                    "HealthCheck_HTTP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for HealthCheck_HTTP {
    fn clear(&mut self) {
        self.clear_port();
        self.clear_path();
        self.clear_statuses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for HealthCheck_HTTP {
    fn eq(&self, other: &HealthCheck_HTTP) -> bool {
        self.port == other.port &&
        self.path == other.path &&
        self.statuses == other.statuses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for HealthCheck_HTTP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CommandInfo {
    // message fields
    uris: ::protobuf::RepeatedField<CommandInfo_URI>,
    environment: ::protobuf::SingularPtrField<Environment>,
    shell: ::std::option::Option<bool>,
    value: ::protobuf::SingularField<::std::string::String>,
    arguments: ::protobuf::RepeatedField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CommandInfo {}

impl CommandInfo {
    pub fn new() -> CommandInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo,
        };
        unsafe {
            instance.get(|| {
                CommandInfo {
                    uris: ::protobuf::RepeatedField::new(),
                    environment: ::protobuf::SingularPtrField::none(),
                    shell: ::std::option::Option::None,
                    value: ::protobuf::SingularField::none(),
                    arguments: ::protobuf::RepeatedField::new(),
                    user: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.CommandInfo.URI uris = 1;

    pub fn clear_uris(&mut self) {
        self.uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_uris(&mut self, v: ::protobuf::RepeatedField<CommandInfo_URI>) {
        self.uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_uris<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CommandInfo_URI> {
        &mut self.uris
    }

    // Take field
    pub fn take_uris(&mut self) -> ::protobuf::RepeatedField<CommandInfo_URI> {
        ::std::mem::replace(&mut self.uris, ::protobuf::RepeatedField::new())
    }

    pub fn get_uris<'a>(&'a self) -> &'a [CommandInfo_URI] {
        &self.uris
    }

    // optional .mesos.v1.Environment environment = 2;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: Environment) {
        self.environment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment<'a>(&'a mut self) -> &'a mut Environment {
        if self.environment.is_none() {
            self.environment.set_default();
        };
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> Environment {
        self.environment.take().unwrap_or_else(|| Environment::new())
    }

    pub fn get_environment<'a>(&'a self) -> &'a Environment {
        self.environment.as_ref().unwrap_or_else(|| Environment::default_instance())
    }

    // optional bool shell = 6;

    pub fn clear_shell(&mut self) {
        self.shell = ::std::option::Option::None;
    }

    pub fn has_shell(&self) -> bool {
        self.shell.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shell(&mut self, v: bool) {
        self.shell = ::std::option::Option::Some(v);
    }

    pub fn get_shell<'a>(&self) -> bool {
        self.shell.unwrap_or(true)
    }

    // optional string value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string arguments = 7;

    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    pub fn get_arguments<'a>(&'a self) -> &'a [::std::string::String] {
        &self.arguments
    }

    // optional string user = 5;

    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        };
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_user<'a>(&'a self) -> &'a str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CommandInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.uris));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.environment));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.shell = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.arguments));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.uris.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.environment.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.shell.is_some() {
            my_size += 2;
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.arguments.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.user.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.uris.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.environment.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.shell {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(3, &v));
        };
        for v in self.arguments.iter() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.user.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CommandInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo {
    fn new() -> CommandInfo {
        CommandInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "uris",
                    CommandInfo::get_uris,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "environment",
                    CommandInfo::has_environment,
                    CommandInfo::get_environment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "shell",
                    CommandInfo::has_shell,
                    CommandInfo::get_shell,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    CommandInfo::has_value,
                    CommandInfo::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "arguments",
                    CommandInfo::get_arguments,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "user",
                    CommandInfo::has_user,
                    CommandInfo::get_user,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo>(
                    "CommandInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo {
    fn clear(&mut self) {
        self.clear_uris();
        self.clear_environment();
        self.clear_shell();
        self.clear_value();
        self.clear_arguments();
        self.clear_user();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CommandInfo {
    fn eq(&self, other: &CommandInfo) -> bool {
        self.uris == other.uris &&
        self.environment == other.environment &&
        self.shell == other.shell &&
        self.value == other.value &&
        self.arguments == other.arguments &&
        self.user == other.user &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CommandInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CommandInfo_URI {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    executable: ::std::option::Option<bool>,
    extract: ::std::option::Option<bool>,
    cache: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CommandInfo_URI {}

impl CommandInfo_URI {
    pub fn new() -> CommandInfo_URI {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CommandInfo_URI {
        static mut instance: ::protobuf::lazy::Lazy<CommandInfo_URI> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CommandInfo_URI,
        };
        unsafe {
            instance.get(|| {
                CommandInfo_URI {
                    value: ::protobuf::SingularField::none(),
                    executable: ::std::option::Option::None,
                    extract: ::std::option::Option::None,
                    cache: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool executable = 2;

    pub fn clear_executable(&mut self) {
        self.executable = ::std::option::Option::None;
    }

    pub fn has_executable(&self) -> bool {
        self.executable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executable(&mut self, v: bool) {
        self.executable = ::std::option::Option::Some(v);
    }

    pub fn get_executable<'a>(&self) -> bool {
        self.executable.unwrap_or(false)
    }

    // optional bool extract = 3;

    pub fn clear_extract(&mut self) {
        self.extract = ::std::option::Option::None;
    }

    pub fn has_extract(&self) -> bool {
        self.extract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extract(&mut self, v: bool) {
        self.extract = ::std::option::Option::Some(v);
    }

    pub fn get_extract<'a>(&self) -> bool {
        self.extract.unwrap_or(true)
    }

    // optional bool cache = 4;

    pub fn clear_cache(&mut self) {
        self.cache = ::std::option::Option::None;
    }

    pub fn has_cache(&self) -> bool {
        self.cache.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache(&mut self, v: bool) {
        self.cache = ::std::option::Option::Some(v);
    }

    pub fn get_cache<'a>(&self) -> bool {
        self.cache.unwrap_or(false)
    }
}

impl ::protobuf::Message for CommandInfo_URI {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.executable = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.extract = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.cache = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.executable.is_some() {
            my_size += 2;
        };
        if self.extract.is_some() {
            my_size += 2;
        };
        if self.cache.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.executable {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.extract {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.cache {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CommandInfo_URI>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CommandInfo_URI {
    fn new() -> CommandInfo_URI {
        CommandInfo_URI::new()
    }

    fn descriptor_static(_: ::std::option::Option<CommandInfo_URI>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    CommandInfo_URI::has_value,
                    CommandInfo_URI::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "executable",
                    CommandInfo_URI::has_executable,
                    CommandInfo_URI::get_executable,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "extract",
                    CommandInfo_URI::has_extract,
                    CommandInfo_URI::get_extract,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "cache",
                    CommandInfo_URI::has_cache,
                    CommandInfo_URI::get_cache,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CommandInfo_URI>(
                    "CommandInfo_URI",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CommandInfo_URI {
    fn clear(&mut self) {
        self.clear_value();
        self.clear_executable();
        self.clear_extract();
        self.clear_cache();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CommandInfo_URI {
    fn eq(&self, other: &CommandInfo_URI) -> bool {
        self.value == other.value &&
        self.executable == other.executable &&
        self.extract == other.extract &&
        self.cache == other.cache &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CommandInfo_URI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ExecutorInfo {
    // message fields
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    resources: ::protobuf::RepeatedField<Resource>,
    name: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ExecutorInfo {}

impl ExecutorInfo {
    pub fn new() -> ExecutorInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ExecutorInfo {
        static mut instance: ::protobuf::lazy::Lazy<ExecutorInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ExecutorInfo,
        };
        unsafe {
            instance.get(|| {
                ExecutorInfo {
                    executor_id: ::protobuf::SingularPtrField::none(),
                    framework_id: ::protobuf::SingularPtrField::none(),
                    command: ::protobuf::SingularPtrField::none(),
                    container: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    name: ::protobuf::SingularField::none(),
                    source: ::protobuf::SingularField::none(),
                    data: ::protobuf::SingularField::none(),
                    discovery: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.ExecutorID executor_id = 1;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // optional .mesos.v1.FrameworkID framework_id = 8;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // required .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    // optional .mesos.v1.ContainerInfo container = 11;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container<'a>(&'a mut self) -> &'a mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        };
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container<'a>(&'a self) -> &'a ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    // repeated .mesos.v1.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // optional string name = 9;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string source = 10;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        };
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_source<'a>(&'a self) -> &'a str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.v1.DiscoveryInfo discovery = 12;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery<'a>(&'a mut self) -> &'a mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        };
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery<'a>(&'a self) -> &'a DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }
}

impl ::protobuf::Message for ExecutorInfo {
    fn is_initialized(&self) -> bool {
        if self.executor_id.is_none() {
            return false;
        };
        if self.command.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_id));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                10 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data));
                },
                12 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.source.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.discovery.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.source.as_ref() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.discovery.as_ref() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ExecutorInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ExecutorInfo {
    fn new() -> ExecutorInfo {
        ExecutorInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ExecutorInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    ExecutorInfo::has_executor_id,
                    ExecutorInfo::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    ExecutorInfo::has_framework_id,
                    ExecutorInfo::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    ExecutorInfo::has_command,
                    ExecutorInfo::get_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container",
                    ExecutorInfo::has_container,
                    ExecutorInfo::get_container,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    ExecutorInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    ExecutorInfo::has_name,
                    ExecutorInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "source",
                    ExecutorInfo::has_source,
                    ExecutorInfo::get_source,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    ExecutorInfo::has_data,
                    ExecutorInfo::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "discovery",
                    ExecutorInfo::has_discovery,
                    ExecutorInfo::get_discovery,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ExecutorInfo>(
                    "ExecutorInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ExecutorInfo {
    fn clear(&mut self) {
        self.clear_executor_id();
        self.clear_framework_id();
        self.clear_command();
        self.clear_container();
        self.clear_resources();
        self.clear_name();
        self.clear_source();
        self.clear_data();
        self.clear_discovery();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ExecutorInfo {
    fn eq(&self, other: &ExecutorInfo) -> bool {
        self.executor_id == other.executor_id &&
        self.framework_id == other.framework_id &&
        self.command == other.command &&
        self.container == other.container &&
        self.resources == other.resources &&
        self.name == other.name &&
        self.source == other.source &&
        self.data == other.data &&
        self.discovery == other.discovery &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ExecutorInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct MasterInfo {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    ip: ::std::option::Option<u32>,
    port: ::std::option::Option<u32>,
    pid: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularPtrField<Address>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for MasterInfo {}

impl MasterInfo {
    pub fn new() -> MasterInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static MasterInfo {
        static mut instance: ::protobuf::lazy::Lazy<MasterInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MasterInfo,
        };
        unsafe {
            instance.get(|| {
                MasterInfo {
                    id: ::protobuf::SingularField::none(),
                    ip: ::std::option::Option::None,
                    port: ::std::option::Option::None,
                    pid: ::protobuf::SingularField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    address: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required uint32 ip = 2;

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    pub fn get_ip<'a>(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    // required uint32 port = 3;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> u32 {
        self.port.unwrap_or(5050u32)
    }

    // optional string pid = 4;

    pub fn clear_pid(&mut self) {
        self.pid.clear();
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: ::std::string::String) {
        self.pid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pid<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.pid.is_none() {
            self.pid.set_default();
        };
        self.pid.as_mut().unwrap()
    }

    // Take field
    pub fn take_pid(&mut self) -> ::std::string::String {
        self.pid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_pid<'a>(&'a self) -> &'a str {
        match self.pid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string hostname = 5;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 6;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version<'a>(&'a self) -> &'a str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Address address = 7;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address<'a>(&'a mut self) -> &'a mut Address {
        if self.address.is_none() {
            self.address.set_default();
        };
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> Address {
        self.address.take().unwrap_or_else(|| Address::new())
    }

    pub fn get_address<'a>(&'a self) -> &'a Address {
        self.address.as_ref().unwrap_or_else(|| Address::default_instance())
    }
}

impl ::protobuf::Message for MasterInfo {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.ip.is_none() {
            return false;
        };
        if self.port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pid));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pid.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.address.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.port {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.pid.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.version.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.address.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<MasterInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for MasterInfo {
    fn new() -> MasterInfo {
        MasterInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<MasterInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    MasterInfo::has_id,
                    MasterInfo::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ip",
                    MasterInfo::has_ip,
                    MasterInfo::get_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "port",
                    MasterInfo::has_port,
                    MasterInfo::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "pid",
                    MasterInfo::has_pid,
                    MasterInfo::get_pid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    MasterInfo::has_hostname,
                    MasterInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "version",
                    MasterInfo::has_version,
                    MasterInfo::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "address",
                    MasterInfo::has_address,
                    MasterInfo::get_address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MasterInfo>(
                    "MasterInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for MasterInfo {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_ip();
        self.clear_port();
        self.clear_pid();
        self.clear_hostname();
        self.clear_version();
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for MasterInfo {
    fn eq(&self, other: &MasterInfo) -> bool {
        self.id == other.id &&
        self.ip == other.ip &&
        self.port == other.port &&
        self.pid == other.pid &&
        self.hostname == other.hostname &&
        self.version == other.version &&
        self.address == other.address &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for MasterInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct AgentInfo {
    // message fields
    hostname: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    id: ::protobuf::SingularPtrField<AgentID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for AgentInfo {}

impl AgentInfo {
    pub fn new() -> AgentInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static AgentInfo {
        static mut instance: ::protobuf::lazy::Lazy<AgentInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AgentInfo,
        };
        unsafe {
            instance.get(|| {
                AgentInfo {
                    hostname: ::protobuf::SingularField::none(),
                    port: ::std::option::Option::None,
                    resources: ::protobuf::RepeatedField::new(),
                    attributes: ::protobuf::RepeatedField::new(),
                    id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string hostname = 1;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 port = 8;

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    pub fn get_port<'a>(&self) -> i32 {
        self.port.unwrap_or(5051i32)
    }

    // repeated .mesos.v1.Resource resources = 3;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // repeated .mesos.v1.Attribute attributes = 5;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes<'a>(&'a self) -> &'a [Attribute] {
        &self.attributes
    }

    // optional .mesos.v1.AgentID id = 6;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: AgentID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> AgentID {
        self.id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a AgentID {
        self.id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }
}

impl ::protobuf::Message for AgentInfo {
    fn is_initialized(&self) -> bool {
        if self.hostname.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.port.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.attributes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.port {
            try!(os.write_int32(8, v));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.attributes.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<AgentInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for AgentInfo {
    fn new() -> AgentInfo {
        AgentInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<AgentInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    AgentInfo::has_hostname,
                    AgentInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "port",
                    AgentInfo::has_port,
                    AgentInfo::get_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    AgentInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "attributes",
                    AgentInfo::get_attributes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    AgentInfo::has_id,
                    AgentInfo::get_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AgentInfo>(
                    "AgentInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for AgentInfo {
    fn clear(&mut self) {
        self.clear_hostname();
        self.clear_port();
        self.clear_resources();
        self.clear_attributes();
        self.clear_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for AgentInfo {
    fn eq(&self, other: &AgentInfo) -> bool {
        self.hostname == other.hostname &&
        self.port == other.port &&
        self.resources == other.resources &&
        self.attributes == other.attributes &&
        self.id == other.id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for AgentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value {
    // message fields
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value {}

impl Value {
    pub fn new() -> Value {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value {
        static mut instance: ::protobuf::lazy::Lazy<Value> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value,
        };
        unsafe {
            instance.get(|| {
                Value {
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    text: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.Value.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.v1.Value.Scalar scalar = 2;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.v1.Value.Ranges ranges = 3;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.v1.Value.Set set = 4;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional .mesos.v1.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }
}

impl ::protobuf::Message for Value {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.text.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value {
    fn new() -> Value {
        Value::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Value::has_field_type,
                    Value::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Value::has_scalar,
                    Value::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Value::has_ranges,
                    Value::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Value::has_set,
                    Value::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "text",
                    Value::has_text,
                    Value::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value>(
                    "Value",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value {
    fn eq(&self, other: &Value) -> bool {
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.text == other.text &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Scalar {
    // message fields
    value: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Scalar {}

impl Value_Scalar {
    pub fn new() -> Value_Scalar {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Scalar {
        static mut instance: ::protobuf::lazy::Lazy<Value_Scalar> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Scalar,
        };
        unsafe {
            instance.get(|| {
                Value_Scalar {
                    value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double value = 1;

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(v);
    }

    pub fn get_value<'a>(&self) -> f64 {
        self.value.unwrap_or(0.)
    }
}

impl ::protobuf::Message for Value_Scalar {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.value.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value {
            try!(os.write_double(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Scalar>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Scalar {
    fn new() -> Value_Scalar {
        Value_Scalar::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Scalar>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "value",
                    Value_Scalar::has_value,
                    Value_Scalar::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Scalar>(
                    "Value_Scalar",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Scalar {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Scalar {
    fn eq(&self, other: &Value_Scalar) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Scalar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Range {
    // message fields
    begin: ::std::option::Option<u64>,
    end: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Range {}

impl Value_Range {
    pub fn new() -> Value_Range {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Range {
        static mut instance: ::protobuf::lazy::Lazy<Value_Range> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Range,
        };
        unsafe {
            instance.get(|| {
                Value_Range {
                    begin: ::std::option::Option::None,
                    end: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint64 begin = 1;

    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: u64) {
        self.begin = ::std::option::Option::Some(v);
    }

    pub fn get_begin<'a>(&self) -> u64 {
        self.begin.unwrap_or(0)
    }

    // required uint64 end = 2;

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: u64) {
        self.end = ::std::option::Option::Some(v);
    }

    pub fn get_end<'a>(&self) -> u64 {
        self.end.unwrap_or(0)
    }
}

impl ::protobuf::Message for Value_Range {
    fn is_initialized(&self) -> bool {
        if self.begin.is_none() {
            return false;
        };
        if self.end.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.begin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.begin.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.end.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.begin {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.end {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Range>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Range {
    fn new() -> Value_Range {
        Value_Range::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Range>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "begin",
                    Value_Range::has_begin,
                    Value_Range::get_begin,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "end",
                    Value_Range::has_end,
                    Value_Range::get_end,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Range>(
                    "Value_Range",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Range {
    fn clear(&mut self) {
        self.clear_begin();
        self.clear_end();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Range {
    fn eq(&self, other: &Value_Range) -> bool {
        self.begin == other.begin &&
        self.end == other.end &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Ranges {
    // message fields
    range: ::protobuf::RepeatedField<Value_Range>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Ranges {}

impl Value_Ranges {
    pub fn new() -> Value_Ranges {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Ranges {
        static mut instance: ::protobuf::lazy::Lazy<Value_Ranges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Ranges,
        };
        unsafe {
            instance.get(|| {
                Value_Ranges {
                    range: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Value.Range range = 1;

    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::protobuf::RepeatedField<Value_Range>) {
        self.range = v;
    }

    // Mutable pointer to the field.
    pub fn mut_range<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Value_Range> {
        &mut self.range
    }

    // Take field
    pub fn take_range(&mut self) -> ::protobuf::RepeatedField<Value_Range> {
        ::std::mem::replace(&mut self.range, ::protobuf::RepeatedField::new())
    }

    pub fn get_range<'a>(&'a self) -> &'a [Value_Range] {
        &self.range
    }
}

impl ::protobuf::Message for Value_Ranges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.range));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.range.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.range.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Ranges>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Ranges {
    fn new() -> Value_Ranges {
        Value_Ranges::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Ranges>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "range",
                    Value_Ranges::get_range,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Ranges>(
                    "Value_Ranges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Ranges {
    fn clear(&mut self) {
        self.clear_range();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Ranges {
    fn eq(&self, other: &Value_Ranges) -> bool {
        self.range == other.range &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Ranges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Set {
    // message fields
    item: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Set {}

impl Value_Set {
    pub fn new() -> Value_Set {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Set {
        static mut instance: ::protobuf::lazy::Lazy<Value_Set> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Set,
        };
        unsafe {
            instance.get(|| {
                Value_Set {
                    item: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated string item = 1;

    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }

    pub fn get_item<'a>(&'a self) -> &'a [::std::string::String] {
        &self.item
    }
}

impl ::protobuf::Message for Value_Set {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.item));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.item.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.item.iter() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Set>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Set {
    fn new() -> Value_Set {
        Value_Set::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Set>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "item",
                    Value_Set::get_item,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Set>(
                    "Value_Set",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Set {
    fn clear(&mut self) {
        self.clear_item();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Set {
    fn eq(&self, other: &Value_Set) -> bool {
        self.item == other.item &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Value_Text {
    // message fields
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Value_Text {}

impl Value_Text {
    pub fn new() -> Value_Text {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Value_Text {
        static mut instance: ::protobuf::lazy::Lazy<Value_Text> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Value_Text,
        };
        unsafe {
            instance.get(|| {
                Value_Text {
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string value = 1;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Value_Text {
    fn is_initialized(&self) -> bool {
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Value_Text>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Value_Text {
    fn new() -> Value_Text {
        Value_Text::new()
    }

    fn descriptor_static(_: ::std::option::Option<Value_Text>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Value_Text::has_value,
                    Value_Text::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Value_Text>(
                    "Value_Text",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Value_Text {
    fn clear(&mut self) {
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Value_Text {
    fn eq(&self, other: &Value_Text) -> bool {
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Value_Text {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Value_Type {
    SCALAR = 0,
    RANGES = 1,
    SET = 2,
    TEXT = 3,
}

impl ::protobuf::ProtobufEnum for Value_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Value_Type> {
        match value {
            0 => ::std::option::Option::Some(Value_Type::SCALAR),
            1 => ::std::option::Option::Some(Value_Type::RANGES),
            2 => ::std::option::Option::Some(Value_Type::SET),
            3 => ::std::option::Option::Some(Value_Type::TEXT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Value_Type] = &[
            Value_Type::SCALAR,
            Value_Type::RANGES,
            Value_Type::SET,
            Value_Type::TEXT,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Value_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Value_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Value_Type {
}

#[derive(Clone,Default)]
pub struct Attribute {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    text: ::protobuf::SingularPtrField<Value_Text>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Attribute {}

impl Attribute {
    pub fn new() -> Attribute {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Attribute {
        static mut instance: ::protobuf::lazy::Lazy<Attribute> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attribute,
        };
        unsafe {
            instance.get(|| {
                Attribute {
                    name: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    text: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.v1.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.v1.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.v1.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.v1.Value.Set set = 6;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional .mesos.v1.Value.Text text = 5;

    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: Value_Text) {
        self.text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text<'a>(&'a mut self) -> &'a mut Value_Text {
        if self.text.is_none() {
            self.text.set_default();
        };
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> Value_Text {
        self.text.take().unwrap_or_else(|| Value_Text::new())
    }

    pub fn get_text<'a>(&'a self) -> &'a Value_Text {
        self.text.as_ref().unwrap_or_else(|| Value_Text::default_instance())
    }
}

impl ::protobuf::Message for Attribute {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.text));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.text.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(2, v.value()));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.text.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Attribute>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Attribute {
    fn new() -> Attribute {
        Attribute::new()
    }

    fn descriptor_static(_: ::std::option::Option<Attribute>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Attribute::has_name,
                    Attribute::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Attribute::has_field_type,
                    Attribute::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Attribute::has_scalar,
                    Attribute::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Attribute::has_ranges,
                    Attribute::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Attribute::has_set,
                    Attribute::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "text",
                    Attribute::has_text,
                    Attribute::get_text,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attribute>(
                    "Attribute",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Attribute {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_text();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Attribute {
    fn eq(&self, other: &Attribute) -> bool {
        self.name == other.name &&
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.text == other.text &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Attribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::std::option::Option<Value_Type>,
    scalar: ::protobuf::SingularPtrField<Value_Scalar>,
    ranges: ::protobuf::SingularPtrField<Value_Ranges>,
    set: ::protobuf::SingularPtrField<Value_Set>,
    role: ::protobuf::SingularField<::std::string::String>,
    reservation: ::protobuf::SingularPtrField<Resource_ReservationInfo>,
    disk: ::protobuf::SingularPtrField<Resource_DiskInfo>,
    revocable: ::protobuf::SingularPtrField<Resource_RevocableInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource {}

impl Resource {
    pub fn new() -> Resource {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource {
        static mut instance: ::protobuf::lazy::Lazy<Resource> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource,
        };
        unsafe {
            instance.get(|| {
                Resource {
                    name: ::protobuf::SingularField::none(),
                    field_type: ::std::option::Option::None,
                    scalar: ::protobuf::SingularPtrField::none(),
                    ranges: ::protobuf::SingularPtrField::none(),
                    set: ::protobuf::SingularPtrField::none(),
                    role: ::protobuf::SingularField::none(),
                    reservation: ::protobuf::SingularPtrField::none(),
                    disk: ::protobuf::SingularPtrField::none(),
                    revocable: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.v1.Value.Type type = 2;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Value_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Value_Type {
        self.field_type.unwrap_or(Value_Type::SCALAR)
    }

    // optional .mesos.v1.Value.Scalar scalar = 3;

    pub fn clear_scalar(&mut self) {
        self.scalar.clear();
    }

    pub fn has_scalar(&self) -> bool {
        self.scalar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: Value_Scalar) {
        self.scalar = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scalar<'a>(&'a mut self) -> &'a mut Value_Scalar {
        if self.scalar.is_none() {
            self.scalar.set_default();
        };
        self.scalar.as_mut().unwrap()
    }

    // Take field
    pub fn take_scalar(&mut self) -> Value_Scalar {
        self.scalar.take().unwrap_or_else(|| Value_Scalar::new())
    }

    pub fn get_scalar<'a>(&'a self) -> &'a Value_Scalar {
        self.scalar.as_ref().unwrap_or_else(|| Value_Scalar::default_instance())
    }

    // optional .mesos.v1.Value.Ranges ranges = 4;

    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    pub fn has_ranges(&self) -> bool {
        self.ranges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: Value_Ranges) {
        self.ranges = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ranges<'a>(&'a mut self) -> &'a mut Value_Ranges {
        if self.ranges.is_none() {
            self.ranges.set_default();
        };
        self.ranges.as_mut().unwrap()
    }

    // Take field
    pub fn take_ranges(&mut self) -> Value_Ranges {
        self.ranges.take().unwrap_or_else(|| Value_Ranges::new())
    }

    pub fn get_ranges<'a>(&'a self) -> &'a Value_Ranges {
        self.ranges.as_ref().unwrap_or_else(|| Value_Ranges::default_instance())
    }

    // optional .mesos.v1.Value.Set set = 5;

    pub fn clear_set(&mut self) {
        self.set.clear();
    }

    pub fn has_set(&self) -> bool {
        self.set.is_some()
    }

    // Param is passed by value, moved
    pub fn set_set(&mut self, v: Value_Set) {
        self.set = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_set<'a>(&'a mut self) -> &'a mut Value_Set {
        if self.set.is_none() {
            self.set.set_default();
        };
        self.set.as_mut().unwrap()
    }

    // Take field
    pub fn take_set(&mut self) -> Value_Set {
        self.set.take().unwrap_or_else(|| Value_Set::new())
    }

    pub fn get_set<'a>(&'a self) -> &'a Value_Set {
        self.set.as_ref().unwrap_or_else(|| Value_Set::default_instance())
    }

    // optional string role = 6;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        };
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role<'a>(&'a self) -> &'a str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "*",
        }
    }

    // optional .mesos.v1.Resource.ReservationInfo reservation = 8;

    pub fn clear_reservation(&mut self) {
        self.reservation.clear();
    }

    pub fn has_reservation(&self) -> bool {
        self.reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation(&mut self, v: Resource_ReservationInfo) {
        self.reservation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation<'a>(&'a mut self) -> &'a mut Resource_ReservationInfo {
        if self.reservation.is_none() {
            self.reservation.set_default();
        };
        self.reservation.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation(&mut self) -> Resource_ReservationInfo {
        self.reservation.take().unwrap_or_else(|| Resource_ReservationInfo::new())
    }

    pub fn get_reservation<'a>(&'a self) -> &'a Resource_ReservationInfo {
        self.reservation.as_ref().unwrap_or_else(|| Resource_ReservationInfo::default_instance())
    }

    // optional .mesos.v1.Resource.DiskInfo disk = 7;

    pub fn clear_disk(&mut self) {
        self.disk.clear();
    }

    pub fn has_disk(&self) -> bool {
        self.disk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk(&mut self, v: Resource_DiskInfo) {
        self.disk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disk<'a>(&'a mut self) -> &'a mut Resource_DiskInfo {
        if self.disk.is_none() {
            self.disk.set_default();
        };
        self.disk.as_mut().unwrap()
    }

    // Take field
    pub fn take_disk(&mut self) -> Resource_DiskInfo {
        self.disk.take().unwrap_or_else(|| Resource_DiskInfo::new())
    }

    pub fn get_disk<'a>(&'a self) -> &'a Resource_DiskInfo {
        self.disk.as_ref().unwrap_or_else(|| Resource_DiskInfo::default_instance())
    }

    // optional .mesos.v1.Resource.RevocableInfo revocable = 9;

    pub fn clear_revocable(&mut self) {
        self.revocable.clear();
    }

    pub fn has_revocable(&self) -> bool {
        self.revocable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revocable(&mut self, v: Resource_RevocableInfo) {
        self.revocable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revocable<'a>(&'a mut self) -> &'a mut Resource_RevocableInfo {
        if self.revocable.is_none() {
            self.revocable.set_default();
        };
        self.revocable.as_mut().unwrap()
    }

    // Take field
    pub fn take_revocable(&mut self) -> Resource_RevocableInfo {
        self.revocable.take().unwrap_or_else(|| Resource_RevocableInfo::new())
    }

    pub fn get_revocable<'a>(&'a self) -> &'a Resource_RevocableInfo {
        self.revocable.as_ref().unwrap_or_else(|| Resource_RevocableInfo::default_instance())
    }
}

impl ::protobuf::Message for Resource {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scalar));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ranges));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.set));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reservation));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.disk));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.revocable));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.scalar.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.ranges.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.set.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.role.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.reservation.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.disk.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.revocable.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.field_type {
            try!(os.write_enum(2, v.value()));
        };
        if let Some(v) = self.scalar.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.ranges.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.set.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.role.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.reservation.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.disk.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.revocable.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource {
    fn new() -> Resource {
        Resource::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Resource::has_name,
                    Resource::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Resource::has_field_type,
                    Resource::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "scalar",
                    Resource::has_scalar,
                    Resource::get_scalar,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ranges",
                    Resource::has_ranges,
                    Resource::get_ranges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "set",
                    Resource::has_set,
                    Resource::get_set,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "role",
                    Resource::has_role,
                    Resource::get_role,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "reservation",
                    Resource::has_reservation,
                    Resource::get_reservation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "disk",
                    Resource::has_disk,
                    Resource::get_disk,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "revocable",
                    Resource::has_revocable,
                    Resource::get_revocable,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource>(
                    "Resource",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_field_type();
        self.clear_scalar();
        self.clear_ranges();
        self.clear_set();
        self.clear_role();
        self.clear_reservation();
        self.clear_disk();
        self.clear_revocable();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource {
    fn eq(&self, other: &Resource) -> bool {
        self.name == other.name &&
        self.field_type == other.field_type &&
        self.scalar == other.scalar &&
        self.ranges == other.ranges &&
        self.set == other.set &&
        self.role == other.role &&
        self.reservation == other.reservation &&
        self.disk == other.disk &&
        self.revocable == other.revocable &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_ReservationInfo {
    // message fields
    principal: ::protobuf::SingularField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_ReservationInfo {}

impl Resource_ReservationInfo {
    pub fn new() -> Resource_ReservationInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_ReservationInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_ReservationInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_ReservationInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_ReservationInfo {
                    principal: ::protobuf::SingularField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Labels labels = 2;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for Resource_ReservationInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_ReservationInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_ReservationInfo {
    fn new() -> Resource_ReservationInfo {
        Resource_ReservationInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_ReservationInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    Resource_ReservationInfo::has_principal,
                    Resource_ReservationInfo::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    Resource_ReservationInfo::has_labels,
                    Resource_ReservationInfo::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_ReservationInfo>(
                    "Resource_ReservationInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_ReservationInfo {
    fn clear(&mut self) {
        self.clear_principal();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_ReservationInfo {
    fn eq(&self, other: &Resource_ReservationInfo) -> bool {
        self.principal == other.principal &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_ReservationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo {
    // message fields
    persistence: ::protobuf::SingularPtrField<Resource_DiskInfo_Persistence>,
    volume: ::protobuf::SingularPtrField<Volume>,
    source: ::protobuf::SingularPtrField<Resource_DiskInfo_Source>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo {}

impl Resource_DiskInfo {
    pub fn new() -> Resource_DiskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo {
                    persistence: ::protobuf::SingularPtrField::none(),
                    volume: ::protobuf::SingularPtrField::none(),
                    source: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.Resource.DiskInfo.Persistence persistence = 1;

    pub fn clear_persistence(&mut self) {
        self.persistence.clear();
    }

    pub fn has_persistence(&self) -> bool {
        self.persistence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistence(&mut self, v: Resource_DiskInfo_Persistence) {
        self.persistence = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistence<'a>(&'a mut self) -> &'a mut Resource_DiskInfo_Persistence {
        if self.persistence.is_none() {
            self.persistence.set_default();
        };
        self.persistence.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistence(&mut self) -> Resource_DiskInfo_Persistence {
        self.persistence.take().unwrap_or_else(|| Resource_DiskInfo_Persistence::new())
    }

    pub fn get_persistence<'a>(&'a self) -> &'a Resource_DiskInfo_Persistence {
        self.persistence.as_ref().unwrap_or_else(|| Resource_DiskInfo_Persistence::default_instance())
    }

    // optional .mesos.v1.Volume volume = 2;

    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: Volume) {
        self.volume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume<'a>(&'a mut self) -> &'a mut Volume {
        if self.volume.is_none() {
            self.volume.set_default();
        };
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> Volume {
        self.volume.take().unwrap_or_else(|| Volume::new())
    }

    pub fn get_volume<'a>(&'a self) -> &'a Volume {
        self.volume.as_ref().unwrap_or_else(|| Volume::default_instance())
    }

    // optional .mesos.v1.Resource.DiskInfo.Source source = 3;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: Resource_DiskInfo_Source) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source<'a>(&'a mut self) -> &'a mut Resource_DiskInfo_Source {
        if self.source.is_none() {
            self.source.set_default();
        };
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> Resource_DiskInfo_Source {
        self.source.take().unwrap_or_else(|| Resource_DiskInfo_Source::new())
    }

    pub fn get_source<'a>(&'a self) -> &'a Resource_DiskInfo_Source {
        self.source.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source::default_instance())
    }
}

impl ::protobuf::Message for Resource_DiskInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistence));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volume));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.persistence.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.volume.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.source.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persistence.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.volume.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.source.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo {
    fn new() -> Resource_DiskInfo {
        Resource_DiskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "persistence",
                    Resource_DiskInfo::has_persistence,
                    Resource_DiskInfo::get_persistence,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "volume",
                    Resource_DiskInfo::has_volume,
                    Resource_DiskInfo::get_volume,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "source",
                    Resource_DiskInfo::has_source,
                    Resource_DiskInfo::get_source,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo>(
                    "Resource_DiskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo {
    fn clear(&mut self) {
        self.clear_persistence();
        self.clear_volume();
        self.clear_source();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo {
    fn eq(&self, other: &Resource_DiskInfo) -> bool {
        self.persistence == other.persistence &&
        self.volume == other.volume &&
        self.source == other.source &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo_Persistence {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    principal: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Persistence {}

impl Resource_DiskInfo_Persistence {
    pub fn new() -> Resource_DiskInfo_Persistence {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Persistence {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Persistence> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Persistence,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo_Persistence {
                    id: ::protobuf::SingularField::none(),
                    principal: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string principal = 2;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Persistence {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo_Persistence>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Persistence {
    fn new() -> Resource_DiskInfo_Persistence {
        Resource_DiskInfo_Persistence::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Persistence>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    Resource_DiskInfo_Persistence::has_id,
                    Resource_DiskInfo_Persistence::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    Resource_DiskInfo_Persistence::has_principal,
                    Resource_DiskInfo_Persistence::get_principal,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Persistence>(
                    "Resource_DiskInfo_Persistence",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Persistence {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_principal();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo_Persistence {
    fn eq(&self, other: &Resource_DiskInfo_Persistence) -> bool {
        self.id == other.id &&
        self.principal == other.principal &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Persistence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo_Source {
    // message fields
    field_type: ::std::option::Option<Resource_DiskInfo_Source_Type>,
    path: ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Path>,
    mount: ::protobuf::SingularPtrField<Resource_DiskInfo_Source_Mount>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source {}

impl Resource_DiskInfo_Source {
    pub fn new() -> Resource_DiskInfo_Source {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo_Source {
                    field_type: ::std::option::Option::None,
                    path: ::protobuf::SingularPtrField::none(),
                    mount: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.Resource.DiskInfo.Source.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Resource_DiskInfo_Source_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Resource_DiskInfo_Source_Type {
        self.field_type.unwrap_or(Resource_DiskInfo_Source_Type::PATH)
    }

    // optional .mesos.v1.Resource.DiskInfo.Source.Path path = 2;

    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: Resource_DiskInfo_Source_Path) {
        self.path = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path<'a>(&'a mut self) -> &'a mut Resource_DiskInfo_Source_Path {
        if self.path.is_none() {
            self.path.set_default();
        };
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> Resource_DiskInfo_Source_Path {
        self.path.take().unwrap_or_else(|| Resource_DiskInfo_Source_Path::new())
    }

    pub fn get_path<'a>(&'a self) -> &'a Resource_DiskInfo_Source_Path {
        self.path.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source_Path::default_instance())
    }

    // optional .mesos.v1.Resource.DiskInfo.Source.Mount mount = 3;

    pub fn clear_mount(&mut self) {
        self.mount.clear();
    }

    pub fn has_mount(&self) -> bool {
        self.mount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mount(&mut self, v: Resource_DiskInfo_Source_Mount) {
        self.mount = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mount<'a>(&'a mut self) -> &'a mut Resource_DiskInfo_Source_Mount {
        if self.mount.is_none() {
            self.mount.set_default();
        };
        self.mount.as_mut().unwrap()
    }

    // Take field
    pub fn take_mount(&mut self) -> Resource_DiskInfo_Source_Mount {
        self.mount.take().unwrap_or_else(|| Resource_DiskInfo_Source_Mount::new())
    }

    pub fn get_mount<'a>(&'a self) -> &'a Resource_DiskInfo_Source_Mount {
        self.mount.as_ref().unwrap_or_else(|| Resource_DiskInfo_Source_Mount::default_instance())
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.path));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mount));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.path.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.mount.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.path.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.mount.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo_Source>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source {
    fn new() -> Resource_DiskInfo_Source {
        Resource_DiskInfo_Source::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Resource_DiskInfo_Source::has_field_type,
                    Resource_DiskInfo_Source::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "path",
                    Resource_DiskInfo_Source::has_path,
                    Resource_DiskInfo_Source::get_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "mount",
                    Resource_DiskInfo_Source::has_mount,
                    Resource_DiskInfo_Source::get_mount,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source>(
                    "Resource_DiskInfo_Source",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_path();
        self.clear_mount();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo_Source {
    fn eq(&self, other: &Resource_DiskInfo_Source) -> bool {
        self.field_type == other.field_type &&
        self.path == other.path &&
        self.mount == other.mount &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo_Source_Path {
    // message fields
    root: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source_Path {}

impl Resource_DiskInfo_Source_Path {
    pub fn new() -> Resource_DiskInfo_Source_Path {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source_Path {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source_Path> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source_Path,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo_Source_Path {
                    root: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string root = 1;

    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: ::std::string::String) {
        self.root = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.root.is_none() {
            self.root.set_default();
        };
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> ::std::string::String {
        self.root.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_root<'a>(&'a self) -> &'a str {
        match self.root.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source_Path {
    fn is_initialized(&self) -> bool {
        if self.root.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.root));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.root.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.root.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo_Source_Path>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source_Path {
    fn new() -> Resource_DiskInfo_Source_Path {
        Resource_DiskInfo_Source_Path::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source_Path>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "root",
                    Resource_DiskInfo_Source_Path::has_root,
                    Resource_DiskInfo_Source_Path::get_root,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source_Path>(
                    "Resource_DiskInfo_Source_Path",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source_Path {
    fn clear(&mut self) {
        self.clear_root();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo_Source_Path {
    fn eq(&self, other: &Resource_DiskInfo_Source_Path) -> bool {
        self.root == other.root &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source_Path {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Resource_DiskInfo_Source_Mount {
    // message fields
    root: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_DiskInfo_Source_Mount {}

impl Resource_DiskInfo_Source_Mount {
    pub fn new() -> Resource_DiskInfo_Source_Mount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_DiskInfo_Source_Mount {
        static mut instance: ::protobuf::lazy::Lazy<Resource_DiskInfo_Source_Mount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_DiskInfo_Source_Mount,
        };
        unsafe {
            instance.get(|| {
                Resource_DiskInfo_Source_Mount {
                    root: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string root = 1;

    pub fn clear_root(&mut self) {
        self.root.clear();
    }

    pub fn has_root(&self) -> bool {
        self.root.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root(&mut self, v: ::std::string::String) {
        self.root = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.root.is_none() {
            self.root.set_default();
        };
        self.root.as_mut().unwrap()
    }

    // Take field
    pub fn take_root(&mut self) -> ::std::string::String {
        self.root.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_root<'a>(&'a self) -> &'a str {
        match self.root.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Resource_DiskInfo_Source_Mount {
    fn is_initialized(&self) -> bool {
        if self.root.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.root));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.root.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.root.as_ref() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_DiskInfo_Source_Mount>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_DiskInfo_Source_Mount {
    fn new() -> Resource_DiskInfo_Source_Mount {
        Resource_DiskInfo_Source_Mount::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_DiskInfo_Source_Mount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "root",
                    Resource_DiskInfo_Source_Mount::has_root,
                    Resource_DiskInfo_Source_Mount::get_root,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Resource_DiskInfo_Source_Mount>(
                    "Resource_DiskInfo_Source_Mount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_DiskInfo_Source_Mount {
    fn clear(&mut self) {
        self.clear_root();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_DiskInfo_Source_Mount {
    fn eq(&self, other: &Resource_DiskInfo_Source_Mount) -> bool {
        self.root == other.root &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_DiskInfo_Source_Mount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Resource_DiskInfo_Source_Type {
    PATH = 1,
    MOUNT = 2,
}

impl ::protobuf::ProtobufEnum for Resource_DiskInfo_Source_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Resource_DiskInfo_Source_Type> {
        match value {
            1 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::PATH),
            2 => ::std::option::Option::Some(Resource_DiskInfo_Source_Type::MOUNT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Resource_DiskInfo_Source_Type] = &[
            Resource_DiskInfo_Source_Type::PATH,
            Resource_DiskInfo_Source_Type::MOUNT,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Resource_DiskInfo_Source_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Resource_DiskInfo_Source_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Resource_DiskInfo_Source_Type {
}

#[derive(Clone,Default)]
pub struct Resource_RevocableInfo {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Resource_RevocableInfo {}

impl Resource_RevocableInfo {
    pub fn new() -> Resource_RevocableInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Resource_RevocableInfo {
        static mut instance: ::protobuf::lazy::Lazy<Resource_RevocableInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Resource_RevocableInfo,
        };
        unsafe {
            instance.get(|| {
                Resource_RevocableInfo {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for Resource_RevocableInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Resource_RevocableInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Resource_RevocableInfo {
    fn new() -> Resource_RevocableInfo {
        Resource_RevocableInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<Resource_RevocableInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<Resource_RevocableInfo>(
                    "Resource_RevocableInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Resource_RevocableInfo {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Resource_RevocableInfo {
    fn eq(&self, other: &Resource_RevocableInfo) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Resource_RevocableInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TrafficControlStatistics {
    // message fields
    id: ::protobuf::SingularField<::std::string::String>,
    backlog: ::std::option::Option<u64>,
    bytes: ::std::option::Option<u64>,
    drops: ::std::option::Option<u64>,
    overlimits: ::std::option::Option<u64>,
    packets: ::std::option::Option<u64>,
    qlen: ::std::option::Option<u64>,
    ratebps: ::std::option::Option<u64>,
    ratepps: ::std::option::Option<u64>,
    requeues: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TrafficControlStatistics {}

impl TrafficControlStatistics {
    pub fn new() -> TrafficControlStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TrafficControlStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TrafficControlStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TrafficControlStatistics,
        };
        unsafe {
            instance.get(|| {
                TrafficControlStatistics {
                    id: ::protobuf::SingularField::none(),
                    backlog: ::std::option::Option::None,
                    bytes: ::std::option::Option::None,
                    drops: ::std::option::Option::None,
                    overlimits: ::std::option::Option::None,
                    packets: ::std::option::Option::None,
                    qlen: ::std::option::Option::None,
                    ratebps: ::std::option::Option::None,
                    ratepps: ::std::option::Option::None,
                    requeues: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 backlog = 2;

    pub fn clear_backlog(&mut self) {
        self.backlog = ::std::option::Option::None;
    }

    pub fn has_backlog(&self) -> bool {
        self.backlog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backlog(&mut self, v: u64) {
        self.backlog = ::std::option::Option::Some(v);
    }

    pub fn get_backlog<'a>(&self) -> u64 {
        self.backlog.unwrap_or(0)
    }

    // optional uint64 bytes = 3;

    pub fn clear_bytes(&mut self) {
        self.bytes = ::std::option::Option::None;
    }

    pub fn has_bytes(&self) -> bool {
        self.bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: u64) {
        self.bytes = ::std::option::Option::Some(v);
    }

    pub fn get_bytes<'a>(&self) -> u64 {
        self.bytes.unwrap_or(0)
    }

    // optional uint64 drops = 4;

    pub fn clear_drops(&mut self) {
        self.drops = ::std::option::Option::None;
    }

    pub fn has_drops(&self) -> bool {
        self.drops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_drops(&mut self, v: u64) {
        self.drops = ::std::option::Option::Some(v);
    }

    pub fn get_drops<'a>(&self) -> u64 {
        self.drops.unwrap_or(0)
    }

    // optional uint64 overlimits = 5;

    pub fn clear_overlimits(&mut self) {
        self.overlimits = ::std::option::Option::None;
    }

    pub fn has_overlimits(&self) -> bool {
        self.overlimits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overlimits(&mut self, v: u64) {
        self.overlimits = ::std::option::Option::Some(v);
    }

    pub fn get_overlimits<'a>(&self) -> u64 {
        self.overlimits.unwrap_or(0)
    }

    // optional uint64 packets = 6;

    pub fn clear_packets(&mut self) {
        self.packets = ::std::option::Option::None;
    }

    pub fn has_packets(&self) -> bool {
        self.packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: u64) {
        self.packets = ::std::option::Option::Some(v);
    }

    pub fn get_packets<'a>(&self) -> u64 {
        self.packets.unwrap_or(0)
    }

    // optional uint64 qlen = 7;

    pub fn clear_qlen(&mut self) {
        self.qlen = ::std::option::Option::None;
    }

    pub fn has_qlen(&self) -> bool {
        self.qlen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qlen(&mut self, v: u64) {
        self.qlen = ::std::option::Option::Some(v);
    }

    pub fn get_qlen<'a>(&self) -> u64 {
        self.qlen.unwrap_or(0)
    }

    // optional uint64 ratebps = 8;

    pub fn clear_ratebps(&mut self) {
        self.ratebps = ::std::option::Option::None;
    }

    pub fn has_ratebps(&self) -> bool {
        self.ratebps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratebps(&mut self, v: u64) {
        self.ratebps = ::std::option::Option::Some(v);
    }

    pub fn get_ratebps<'a>(&self) -> u64 {
        self.ratebps.unwrap_or(0)
    }

    // optional uint64 ratepps = 9;

    pub fn clear_ratepps(&mut self) {
        self.ratepps = ::std::option::Option::None;
    }

    pub fn has_ratepps(&self) -> bool {
        self.ratepps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ratepps(&mut self, v: u64) {
        self.ratepps = ::std::option::Option::Some(v);
    }

    pub fn get_ratepps<'a>(&self) -> u64 {
        self.ratepps.unwrap_or(0)
    }

    // optional uint64 requeues = 10;

    pub fn clear_requeues(&mut self) {
        self.requeues = ::std::option::Option::None;
    }

    pub fn has_requeues(&self) -> bool {
        self.requeues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requeues(&mut self, v: u64) {
        self.requeues = ::std::option::Option::Some(v);
    }

    pub fn get_requeues<'a>(&self) -> u64 {
        self.requeues.unwrap_or(0)
    }
}

impl ::protobuf::Message for TrafficControlStatistics {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.backlog = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.drops = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.overlimits = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.packets = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.qlen = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ratebps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ratepps = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.requeues = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.backlog.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.drops.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.overlimits.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.packets.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.qlen.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ratebps.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ratepps.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.requeues.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.backlog {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.bytes {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.drops {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.overlimits {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.packets {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.qlen {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.ratebps {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.ratepps {
            try!(os.write_uint64(9, v));
        };
        if let Some(v) = self.requeues {
            try!(os.write_uint64(10, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TrafficControlStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TrafficControlStatistics {
    fn new() -> TrafficControlStatistics {
        TrafficControlStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<TrafficControlStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    TrafficControlStatistics::has_id,
                    TrafficControlStatistics::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "backlog",
                    TrafficControlStatistics::has_backlog,
                    TrafficControlStatistics::get_backlog,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes",
                    TrafficControlStatistics::has_bytes,
                    TrafficControlStatistics::get_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "drops",
                    TrafficControlStatistics::has_drops,
                    TrafficControlStatistics::get_drops,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "overlimits",
                    TrafficControlStatistics::has_overlimits,
                    TrafficControlStatistics::get_overlimits,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "packets",
                    TrafficControlStatistics::has_packets,
                    TrafficControlStatistics::get_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "qlen",
                    TrafficControlStatistics::has_qlen,
                    TrafficControlStatistics::get_qlen,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ratebps",
                    TrafficControlStatistics::has_ratebps,
                    TrafficControlStatistics::get_ratebps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ratepps",
                    TrafficControlStatistics::has_ratepps,
                    TrafficControlStatistics::get_ratepps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "requeues",
                    TrafficControlStatistics::has_requeues,
                    TrafficControlStatistics::get_requeues,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TrafficControlStatistics>(
                    "TrafficControlStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TrafficControlStatistics {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_backlog();
        self.clear_bytes();
        self.clear_drops();
        self.clear_overlimits();
        self.clear_packets();
        self.clear_qlen();
        self.clear_ratebps();
        self.clear_ratepps();
        self.clear_requeues();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TrafficControlStatistics {
    fn eq(&self, other: &TrafficControlStatistics) -> bool {
        self.id == other.id &&
        self.backlog == other.backlog &&
        self.bytes == other.bytes &&
        self.drops == other.drops &&
        self.overlimits == other.overlimits &&
        self.packets == other.packets &&
        self.qlen == other.qlen &&
        self.ratebps == other.ratebps &&
        self.ratepps == other.ratepps &&
        self.requeues == other.requeues &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TrafficControlStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct IpStatistics {
    // message fields
    Forwarding: ::std::option::Option<i64>,
    DefaultTTL: ::std::option::Option<i64>,
    InReceives: ::std::option::Option<i64>,
    InHdrErrors: ::std::option::Option<i64>,
    InAddrErrors: ::std::option::Option<i64>,
    ForwDatagrams: ::std::option::Option<i64>,
    InUnknownProtos: ::std::option::Option<i64>,
    InDiscards: ::std::option::Option<i64>,
    InDelivers: ::std::option::Option<i64>,
    OutRequests: ::std::option::Option<i64>,
    OutDiscards: ::std::option::Option<i64>,
    OutNoRoutes: ::std::option::Option<i64>,
    ReasmTimeout: ::std::option::Option<i64>,
    ReasmReqds: ::std::option::Option<i64>,
    ReasmOKs: ::std::option::Option<i64>,
    ReasmFails: ::std::option::Option<i64>,
    FragOKs: ::std::option::Option<i64>,
    FragFails: ::std::option::Option<i64>,
    FragCreates: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IpStatistics {}

impl IpStatistics {
    pub fn new() -> IpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<IpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IpStatistics,
        };
        unsafe {
            instance.get(|| {
                IpStatistics {
                    Forwarding: ::std::option::Option::None,
                    DefaultTTL: ::std::option::Option::None,
                    InReceives: ::std::option::Option::None,
                    InHdrErrors: ::std::option::Option::None,
                    InAddrErrors: ::std::option::Option::None,
                    ForwDatagrams: ::std::option::Option::None,
                    InUnknownProtos: ::std::option::Option::None,
                    InDiscards: ::std::option::Option::None,
                    InDelivers: ::std::option::Option::None,
                    OutRequests: ::std::option::Option::None,
                    OutDiscards: ::std::option::Option::None,
                    OutNoRoutes: ::std::option::Option::None,
                    ReasmTimeout: ::std::option::Option::None,
                    ReasmReqds: ::std::option::Option::None,
                    ReasmOKs: ::std::option::Option::None,
                    ReasmFails: ::std::option::Option::None,
                    FragOKs: ::std::option::Option::None,
                    FragFails: ::std::option::Option::None,
                    FragCreates: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 Forwarding = 1;

    pub fn clear_Forwarding(&mut self) {
        self.Forwarding = ::std::option::Option::None;
    }

    pub fn has_Forwarding(&self) -> bool {
        self.Forwarding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Forwarding(&mut self, v: i64) {
        self.Forwarding = ::std::option::Option::Some(v);
    }

    pub fn get_Forwarding<'a>(&self) -> i64 {
        self.Forwarding.unwrap_or(0)
    }

    // optional int64 DefaultTTL = 2;

    pub fn clear_DefaultTTL(&mut self) {
        self.DefaultTTL = ::std::option::Option::None;
    }

    pub fn has_DefaultTTL(&self) -> bool {
        self.DefaultTTL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DefaultTTL(&mut self, v: i64) {
        self.DefaultTTL = ::std::option::Option::Some(v);
    }

    pub fn get_DefaultTTL<'a>(&self) -> i64 {
        self.DefaultTTL.unwrap_or(0)
    }

    // optional int64 InReceives = 3;

    pub fn clear_InReceives(&mut self) {
        self.InReceives = ::std::option::Option::None;
    }

    pub fn has_InReceives(&self) -> bool {
        self.InReceives.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InReceives(&mut self, v: i64) {
        self.InReceives = ::std::option::Option::Some(v);
    }

    pub fn get_InReceives<'a>(&self) -> i64 {
        self.InReceives.unwrap_or(0)
    }

    // optional int64 InHdrErrors = 4;

    pub fn clear_InHdrErrors(&mut self) {
        self.InHdrErrors = ::std::option::Option::None;
    }

    pub fn has_InHdrErrors(&self) -> bool {
        self.InHdrErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InHdrErrors(&mut self, v: i64) {
        self.InHdrErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InHdrErrors<'a>(&self) -> i64 {
        self.InHdrErrors.unwrap_or(0)
    }

    // optional int64 InAddrErrors = 5;

    pub fn clear_InAddrErrors(&mut self) {
        self.InAddrErrors = ::std::option::Option::None;
    }

    pub fn has_InAddrErrors(&self) -> bool {
        self.InAddrErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrErrors(&mut self, v: i64) {
        self.InAddrErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrErrors<'a>(&self) -> i64 {
        self.InAddrErrors.unwrap_or(0)
    }

    // optional int64 ForwDatagrams = 6;

    pub fn clear_ForwDatagrams(&mut self) {
        self.ForwDatagrams = ::std::option::Option::None;
    }

    pub fn has_ForwDatagrams(&self) -> bool {
        self.ForwDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ForwDatagrams(&mut self, v: i64) {
        self.ForwDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_ForwDatagrams<'a>(&self) -> i64 {
        self.ForwDatagrams.unwrap_or(0)
    }

    // optional int64 InUnknownProtos = 7;

    pub fn clear_InUnknownProtos(&mut self) {
        self.InUnknownProtos = ::std::option::Option::None;
    }

    pub fn has_InUnknownProtos(&self) -> bool {
        self.InUnknownProtos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InUnknownProtos(&mut self, v: i64) {
        self.InUnknownProtos = ::std::option::Option::Some(v);
    }

    pub fn get_InUnknownProtos<'a>(&self) -> i64 {
        self.InUnknownProtos.unwrap_or(0)
    }

    // optional int64 InDiscards = 8;

    pub fn clear_InDiscards(&mut self) {
        self.InDiscards = ::std::option::Option::None;
    }

    pub fn has_InDiscards(&self) -> bool {
        self.InDiscards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDiscards(&mut self, v: i64) {
        self.InDiscards = ::std::option::Option::Some(v);
    }

    pub fn get_InDiscards<'a>(&self) -> i64 {
        self.InDiscards.unwrap_or(0)
    }

    // optional int64 InDelivers = 9;

    pub fn clear_InDelivers(&mut self) {
        self.InDelivers = ::std::option::Option::None;
    }

    pub fn has_InDelivers(&self) -> bool {
        self.InDelivers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDelivers(&mut self, v: i64) {
        self.InDelivers = ::std::option::Option::Some(v);
    }

    pub fn get_InDelivers<'a>(&self) -> i64 {
        self.InDelivers.unwrap_or(0)
    }

    // optional int64 OutRequests = 10;

    pub fn clear_OutRequests(&mut self) {
        self.OutRequests = ::std::option::Option::None;
    }

    pub fn has_OutRequests(&self) -> bool {
        self.OutRequests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRequests(&mut self, v: i64) {
        self.OutRequests = ::std::option::Option::Some(v);
    }

    pub fn get_OutRequests<'a>(&self) -> i64 {
        self.OutRequests.unwrap_or(0)
    }

    // optional int64 OutDiscards = 11;

    pub fn clear_OutDiscards(&mut self) {
        self.OutDiscards = ::std::option::Option::None;
    }

    pub fn has_OutDiscards(&self) -> bool {
        self.OutDiscards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDiscards(&mut self, v: i64) {
        self.OutDiscards = ::std::option::Option::Some(v);
    }

    pub fn get_OutDiscards<'a>(&self) -> i64 {
        self.OutDiscards.unwrap_or(0)
    }

    // optional int64 OutNoRoutes = 12;

    pub fn clear_OutNoRoutes(&mut self) {
        self.OutNoRoutes = ::std::option::Option::None;
    }

    pub fn has_OutNoRoutes(&self) -> bool {
        self.OutNoRoutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutNoRoutes(&mut self, v: i64) {
        self.OutNoRoutes = ::std::option::Option::Some(v);
    }

    pub fn get_OutNoRoutes<'a>(&self) -> i64 {
        self.OutNoRoutes.unwrap_or(0)
    }

    // optional int64 ReasmTimeout = 13;

    pub fn clear_ReasmTimeout(&mut self) {
        self.ReasmTimeout = ::std::option::Option::None;
    }

    pub fn has_ReasmTimeout(&self) -> bool {
        self.ReasmTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmTimeout(&mut self, v: i64) {
        self.ReasmTimeout = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmTimeout<'a>(&self) -> i64 {
        self.ReasmTimeout.unwrap_or(0)
    }

    // optional int64 ReasmReqds = 14;

    pub fn clear_ReasmReqds(&mut self) {
        self.ReasmReqds = ::std::option::Option::None;
    }

    pub fn has_ReasmReqds(&self) -> bool {
        self.ReasmReqds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmReqds(&mut self, v: i64) {
        self.ReasmReqds = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmReqds<'a>(&self) -> i64 {
        self.ReasmReqds.unwrap_or(0)
    }

    // optional int64 ReasmOKs = 15;

    pub fn clear_ReasmOKs(&mut self) {
        self.ReasmOKs = ::std::option::Option::None;
    }

    pub fn has_ReasmOKs(&self) -> bool {
        self.ReasmOKs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmOKs(&mut self, v: i64) {
        self.ReasmOKs = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmOKs<'a>(&self) -> i64 {
        self.ReasmOKs.unwrap_or(0)
    }

    // optional int64 ReasmFails = 16;

    pub fn clear_ReasmFails(&mut self) {
        self.ReasmFails = ::std::option::Option::None;
    }

    pub fn has_ReasmFails(&self) -> bool {
        self.ReasmFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReasmFails(&mut self, v: i64) {
        self.ReasmFails = ::std::option::Option::Some(v);
    }

    pub fn get_ReasmFails<'a>(&self) -> i64 {
        self.ReasmFails.unwrap_or(0)
    }

    // optional int64 FragOKs = 17;

    pub fn clear_FragOKs(&mut self) {
        self.FragOKs = ::std::option::Option::None;
    }

    pub fn has_FragOKs(&self) -> bool {
        self.FragOKs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragOKs(&mut self, v: i64) {
        self.FragOKs = ::std::option::Option::Some(v);
    }

    pub fn get_FragOKs<'a>(&self) -> i64 {
        self.FragOKs.unwrap_or(0)
    }

    // optional int64 FragFails = 18;

    pub fn clear_FragFails(&mut self) {
        self.FragFails = ::std::option::Option::None;
    }

    pub fn has_FragFails(&self) -> bool {
        self.FragFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragFails(&mut self, v: i64) {
        self.FragFails = ::std::option::Option::Some(v);
    }

    pub fn get_FragFails<'a>(&self) -> i64 {
        self.FragFails.unwrap_or(0)
    }

    // optional int64 FragCreates = 19;

    pub fn clear_FragCreates(&mut self) {
        self.FragCreates = ::std::option::Option::None;
    }

    pub fn has_FragCreates(&self) -> bool {
        self.FragCreates.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FragCreates(&mut self, v: i64) {
        self.FragCreates = ::std::option::Option::Some(v);
    }

    pub fn get_FragCreates<'a>(&self) -> i64 {
        self.FragCreates.unwrap_or(0)
    }
}

impl ::protobuf::Message for IpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.Forwarding = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.DefaultTTL = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InReceives = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InHdrErrors = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InAddrErrors = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ForwDatagrams = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InUnknownProtos = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InDiscards = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InDelivers = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutRequests = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutDiscards = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutNoRoutes = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ReasmTimeout = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ReasmReqds = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ReasmOKs = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ReasmFails = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.FragOKs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.FragFails = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.FragCreates = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.Forwarding.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.DefaultTTL.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InReceives.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InHdrErrors.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InAddrErrors.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ForwDatagrams.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InUnknownProtos.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InDiscards.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InDelivers.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutRequests.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutDiscards.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutNoRoutes.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ReasmTimeout.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ReasmReqds.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ReasmOKs.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ReasmFails.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.FragOKs.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.FragFails.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.FragCreates.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Forwarding {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.DefaultTTL {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.InReceives {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.InHdrErrors {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.InAddrErrors {
            try!(os.write_int64(5, v));
        };
        if let Some(v) = self.ForwDatagrams {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.InUnknownProtos {
            try!(os.write_int64(7, v));
        };
        if let Some(v) = self.InDiscards {
            try!(os.write_int64(8, v));
        };
        if let Some(v) = self.InDelivers {
            try!(os.write_int64(9, v));
        };
        if let Some(v) = self.OutRequests {
            try!(os.write_int64(10, v));
        };
        if let Some(v) = self.OutDiscards {
            try!(os.write_int64(11, v));
        };
        if let Some(v) = self.OutNoRoutes {
            try!(os.write_int64(12, v));
        };
        if let Some(v) = self.ReasmTimeout {
            try!(os.write_int64(13, v));
        };
        if let Some(v) = self.ReasmReqds {
            try!(os.write_int64(14, v));
        };
        if let Some(v) = self.ReasmOKs {
            try!(os.write_int64(15, v));
        };
        if let Some(v) = self.ReasmFails {
            try!(os.write_int64(16, v));
        };
        if let Some(v) = self.FragOKs {
            try!(os.write_int64(17, v));
        };
        if let Some(v) = self.FragFails {
            try!(os.write_int64(18, v));
        };
        if let Some(v) = self.FragCreates {
            try!(os.write_int64(19, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<IpStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IpStatistics {
    fn new() -> IpStatistics {
        IpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<IpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "Forwarding",
                    IpStatistics::has_Forwarding,
                    IpStatistics::get_Forwarding,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "DefaultTTL",
                    IpStatistics::has_DefaultTTL,
                    IpStatistics::get_DefaultTTL,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InReceives",
                    IpStatistics::has_InReceives,
                    IpStatistics::get_InReceives,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InHdrErrors",
                    IpStatistics::has_InHdrErrors,
                    IpStatistics::get_InHdrErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InAddrErrors",
                    IpStatistics::has_InAddrErrors,
                    IpStatistics::get_InAddrErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ForwDatagrams",
                    IpStatistics::has_ForwDatagrams,
                    IpStatistics::get_ForwDatagrams,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InUnknownProtos",
                    IpStatistics::has_InUnknownProtos,
                    IpStatistics::get_InUnknownProtos,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InDiscards",
                    IpStatistics::has_InDiscards,
                    IpStatistics::get_InDiscards,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InDelivers",
                    IpStatistics::has_InDelivers,
                    IpStatistics::get_InDelivers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutRequests",
                    IpStatistics::has_OutRequests,
                    IpStatistics::get_OutRequests,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutDiscards",
                    IpStatistics::has_OutDiscards,
                    IpStatistics::get_OutDiscards,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutNoRoutes",
                    IpStatistics::has_OutNoRoutes,
                    IpStatistics::get_OutNoRoutes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ReasmTimeout",
                    IpStatistics::has_ReasmTimeout,
                    IpStatistics::get_ReasmTimeout,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ReasmReqds",
                    IpStatistics::has_ReasmReqds,
                    IpStatistics::get_ReasmReqds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ReasmOKs",
                    IpStatistics::has_ReasmOKs,
                    IpStatistics::get_ReasmOKs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ReasmFails",
                    IpStatistics::has_ReasmFails,
                    IpStatistics::get_ReasmFails,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "FragOKs",
                    IpStatistics::has_FragOKs,
                    IpStatistics::get_FragOKs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "FragFails",
                    IpStatistics::has_FragFails,
                    IpStatistics::get_FragFails,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "FragCreates",
                    IpStatistics::has_FragCreates,
                    IpStatistics::get_FragCreates,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IpStatistics>(
                    "IpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IpStatistics {
    fn clear(&mut self) {
        self.clear_Forwarding();
        self.clear_DefaultTTL();
        self.clear_InReceives();
        self.clear_InHdrErrors();
        self.clear_InAddrErrors();
        self.clear_ForwDatagrams();
        self.clear_InUnknownProtos();
        self.clear_InDiscards();
        self.clear_InDelivers();
        self.clear_OutRequests();
        self.clear_OutDiscards();
        self.clear_OutNoRoutes();
        self.clear_ReasmTimeout();
        self.clear_ReasmReqds();
        self.clear_ReasmOKs();
        self.clear_ReasmFails();
        self.clear_FragOKs();
        self.clear_FragFails();
        self.clear_FragCreates();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for IpStatistics {
    fn eq(&self, other: &IpStatistics) -> bool {
        self.Forwarding == other.Forwarding &&
        self.DefaultTTL == other.DefaultTTL &&
        self.InReceives == other.InReceives &&
        self.InHdrErrors == other.InHdrErrors &&
        self.InAddrErrors == other.InAddrErrors &&
        self.ForwDatagrams == other.ForwDatagrams &&
        self.InUnknownProtos == other.InUnknownProtos &&
        self.InDiscards == other.InDiscards &&
        self.InDelivers == other.InDelivers &&
        self.OutRequests == other.OutRequests &&
        self.OutDiscards == other.OutDiscards &&
        self.OutNoRoutes == other.OutNoRoutes &&
        self.ReasmTimeout == other.ReasmTimeout &&
        self.ReasmReqds == other.ReasmReqds &&
        self.ReasmOKs == other.ReasmOKs &&
        self.ReasmFails == other.ReasmFails &&
        self.FragOKs == other.FragOKs &&
        self.FragFails == other.FragFails &&
        self.FragCreates == other.FragCreates &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for IpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct IcmpStatistics {
    // message fields
    InMsgs: ::std::option::Option<i64>,
    InErrors: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    InDestUnreachs: ::std::option::Option<i64>,
    InTimeExcds: ::std::option::Option<i64>,
    InParmProbs: ::std::option::Option<i64>,
    InSrcQuenchs: ::std::option::Option<i64>,
    InRedirects: ::std::option::Option<i64>,
    InEchos: ::std::option::Option<i64>,
    InEchoReps: ::std::option::Option<i64>,
    InTimestamps: ::std::option::Option<i64>,
    InTimestampReps: ::std::option::Option<i64>,
    InAddrMasks: ::std::option::Option<i64>,
    InAddrMaskReps: ::std::option::Option<i64>,
    OutMsgs: ::std::option::Option<i64>,
    OutErrors: ::std::option::Option<i64>,
    OutDestUnreachs: ::std::option::Option<i64>,
    OutTimeExcds: ::std::option::Option<i64>,
    OutParmProbs: ::std::option::Option<i64>,
    OutSrcQuenchs: ::std::option::Option<i64>,
    OutRedirects: ::std::option::Option<i64>,
    OutEchos: ::std::option::Option<i64>,
    OutEchoReps: ::std::option::Option<i64>,
    OutTimestamps: ::std::option::Option<i64>,
    OutTimestampReps: ::std::option::Option<i64>,
    OutAddrMasks: ::std::option::Option<i64>,
    OutAddrMaskReps: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for IcmpStatistics {}

impl IcmpStatistics {
    pub fn new() -> IcmpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static IcmpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<IcmpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IcmpStatistics,
        };
        unsafe {
            instance.get(|| {
                IcmpStatistics {
                    InMsgs: ::std::option::Option::None,
                    InErrors: ::std::option::Option::None,
                    InCsumErrors: ::std::option::Option::None,
                    InDestUnreachs: ::std::option::Option::None,
                    InTimeExcds: ::std::option::Option::None,
                    InParmProbs: ::std::option::Option::None,
                    InSrcQuenchs: ::std::option::Option::None,
                    InRedirects: ::std::option::Option::None,
                    InEchos: ::std::option::Option::None,
                    InEchoReps: ::std::option::Option::None,
                    InTimestamps: ::std::option::Option::None,
                    InTimestampReps: ::std::option::Option::None,
                    InAddrMasks: ::std::option::Option::None,
                    InAddrMaskReps: ::std::option::Option::None,
                    OutMsgs: ::std::option::Option::None,
                    OutErrors: ::std::option::Option::None,
                    OutDestUnreachs: ::std::option::Option::None,
                    OutTimeExcds: ::std::option::Option::None,
                    OutParmProbs: ::std::option::Option::None,
                    OutSrcQuenchs: ::std::option::Option::None,
                    OutRedirects: ::std::option::Option::None,
                    OutEchos: ::std::option::Option::None,
                    OutEchoReps: ::std::option::Option::None,
                    OutTimestamps: ::std::option::Option::None,
                    OutTimestampReps: ::std::option::Option::None,
                    OutAddrMasks: ::std::option::Option::None,
                    OutAddrMaskReps: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 InMsgs = 1;

    pub fn clear_InMsgs(&mut self) {
        self.InMsgs = ::std::option::Option::None;
    }

    pub fn has_InMsgs(&self) -> bool {
        self.InMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InMsgs(&mut self, v: i64) {
        self.InMsgs = ::std::option::Option::Some(v);
    }

    pub fn get_InMsgs<'a>(&self) -> i64 {
        self.InMsgs.unwrap_or(0)
    }

    // optional int64 InErrors = 2;

    pub fn clear_InErrors(&mut self) {
        self.InErrors = ::std::option::Option::None;
    }

    pub fn has_InErrors(&self) -> bool {
        self.InErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrors(&mut self, v: i64) {
        self.InErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InErrors<'a>(&self) -> i64 {
        self.InErrors.unwrap_or(0)
    }

    // optional int64 InCsumErrors = 3;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors<'a>(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }

    // optional int64 InDestUnreachs = 4;

    pub fn clear_InDestUnreachs(&mut self) {
        self.InDestUnreachs = ::std::option::Option::None;
    }

    pub fn has_InDestUnreachs(&self) -> bool {
        self.InDestUnreachs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDestUnreachs(&mut self, v: i64) {
        self.InDestUnreachs = ::std::option::Option::Some(v);
    }

    pub fn get_InDestUnreachs<'a>(&self) -> i64 {
        self.InDestUnreachs.unwrap_or(0)
    }

    // optional int64 InTimeExcds = 5;

    pub fn clear_InTimeExcds(&mut self) {
        self.InTimeExcds = ::std::option::Option::None;
    }

    pub fn has_InTimeExcds(&self) -> bool {
        self.InTimeExcds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimeExcds(&mut self, v: i64) {
        self.InTimeExcds = ::std::option::Option::Some(v);
    }

    pub fn get_InTimeExcds<'a>(&self) -> i64 {
        self.InTimeExcds.unwrap_or(0)
    }

    // optional int64 InParmProbs = 6;

    pub fn clear_InParmProbs(&mut self) {
        self.InParmProbs = ::std::option::Option::None;
    }

    pub fn has_InParmProbs(&self) -> bool {
        self.InParmProbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InParmProbs(&mut self, v: i64) {
        self.InParmProbs = ::std::option::Option::Some(v);
    }

    pub fn get_InParmProbs<'a>(&self) -> i64 {
        self.InParmProbs.unwrap_or(0)
    }

    // optional int64 InSrcQuenchs = 7;

    pub fn clear_InSrcQuenchs(&mut self) {
        self.InSrcQuenchs = ::std::option::Option::None;
    }

    pub fn has_InSrcQuenchs(&self) -> bool {
        self.InSrcQuenchs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InSrcQuenchs(&mut self, v: i64) {
        self.InSrcQuenchs = ::std::option::Option::Some(v);
    }

    pub fn get_InSrcQuenchs<'a>(&self) -> i64 {
        self.InSrcQuenchs.unwrap_or(0)
    }

    // optional int64 InRedirects = 8;

    pub fn clear_InRedirects(&mut self) {
        self.InRedirects = ::std::option::Option::None;
    }

    pub fn has_InRedirects(&self) -> bool {
        self.InRedirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InRedirects(&mut self, v: i64) {
        self.InRedirects = ::std::option::Option::Some(v);
    }

    pub fn get_InRedirects<'a>(&self) -> i64 {
        self.InRedirects.unwrap_or(0)
    }

    // optional int64 InEchos = 9;

    pub fn clear_InEchos(&mut self) {
        self.InEchos = ::std::option::Option::None;
    }

    pub fn has_InEchos(&self) -> bool {
        self.InEchos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InEchos(&mut self, v: i64) {
        self.InEchos = ::std::option::Option::Some(v);
    }

    pub fn get_InEchos<'a>(&self) -> i64 {
        self.InEchos.unwrap_or(0)
    }

    // optional int64 InEchoReps = 10;

    pub fn clear_InEchoReps(&mut self) {
        self.InEchoReps = ::std::option::Option::None;
    }

    pub fn has_InEchoReps(&self) -> bool {
        self.InEchoReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InEchoReps(&mut self, v: i64) {
        self.InEchoReps = ::std::option::Option::Some(v);
    }

    pub fn get_InEchoReps<'a>(&self) -> i64 {
        self.InEchoReps.unwrap_or(0)
    }

    // optional int64 InTimestamps = 11;

    pub fn clear_InTimestamps(&mut self) {
        self.InTimestamps = ::std::option::Option::None;
    }

    pub fn has_InTimestamps(&self) -> bool {
        self.InTimestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimestamps(&mut self, v: i64) {
        self.InTimestamps = ::std::option::Option::Some(v);
    }

    pub fn get_InTimestamps<'a>(&self) -> i64 {
        self.InTimestamps.unwrap_or(0)
    }

    // optional int64 InTimestampReps = 12;

    pub fn clear_InTimestampReps(&mut self) {
        self.InTimestampReps = ::std::option::Option::None;
    }

    pub fn has_InTimestampReps(&self) -> bool {
        self.InTimestampReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InTimestampReps(&mut self, v: i64) {
        self.InTimestampReps = ::std::option::Option::Some(v);
    }

    pub fn get_InTimestampReps<'a>(&self) -> i64 {
        self.InTimestampReps.unwrap_or(0)
    }

    // optional int64 InAddrMasks = 13;

    pub fn clear_InAddrMasks(&mut self) {
        self.InAddrMasks = ::std::option::Option::None;
    }

    pub fn has_InAddrMasks(&self) -> bool {
        self.InAddrMasks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrMasks(&mut self, v: i64) {
        self.InAddrMasks = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrMasks<'a>(&self) -> i64 {
        self.InAddrMasks.unwrap_or(0)
    }

    // optional int64 InAddrMaskReps = 14;

    pub fn clear_InAddrMaskReps(&mut self) {
        self.InAddrMaskReps = ::std::option::Option::None;
    }

    pub fn has_InAddrMaskReps(&self) -> bool {
        self.InAddrMaskReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InAddrMaskReps(&mut self, v: i64) {
        self.InAddrMaskReps = ::std::option::Option::Some(v);
    }

    pub fn get_InAddrMaskReps<'a>(&self) -> i64 {
        self.InAddrMaskReps.unwrap_or(0)
    }

    // optional int64 OutMsgs = 15;

    pub fn clear_OutMsgs(&mut self) {
        self.OutMsgs = ::std::option::Option::None;
    }

    pub fn has_OutMsgs(&self) -> bool {
        self.OutMsgs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutMsgs(&mut self, v: i64) {
        self.OutMsgs = ::std::option::Option::Some(v);
    }

    pub fn get_OutMsgs<'a>(&self) -> i64 {
        self.OutMsgs.unwrap_or(0)
    }

    // optional int64 OutErrors = 16;

    pub fn clear_OutErrors(&mut self) {
        self.OutErrors = ::std::option::Option::None;
    }

    pub fn has_OutErrors(&self) -> bool {
        self.OutErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutErrors(&mut self, v: i64) {
        self.OutErrors = ::std::option::Option::Some(v);
    }

    pub fn get_OutErrors<'a>(&self) -> i64 {
        self.OutErrors.unwrap_or(0)
    }

    // optional int64 OutDestUnreachs = 17;

    pub fn clear_OutDestUnreachs(&mut self) {
        self.OutDestUnreachs = ::std::option::Option::None;
    }

    pub fn has_OutDestUnreachs(&self) -> bool {
        self.OutDestUnreachs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDestUnreachs(&mut self, v: i64) {
        self.OutDestUnreachs = ::std::option::Option::Some(v);
    }

    pub fn get_OutDestUnreachs<'a>(&self) -> i64 {
        self.OutDestUnreachs.unwrap_or(0)
    }

    // optional int64 OutTimeExcds = 18;

    pub fn clear_OutTimeExcds(&mut self) {
        self.OutTimeExcds = ::std::option::Option::None;
    }

    pub fn has_OutTimeExcds(&self) -> bool {
        self.OutTimeExcds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimeExcds(&mut self, v: i64) {
        self.OutTimeExcds = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimeExcds<'a>(&self) -> i64 {
        self.OutTimeExcds.unwrap_or(0)
    }

    // optional int64 OutParmProbs = 19;

    pub fn clear_OutParmProbs(&mut self) {
        self.OutParmProbs = ::std::option::Option::None;
    }

    pub fn has_OutParmProbs(&self) -> bool {
        self.OutParmProbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutParmProbs(&mut self, v: i64) {
        self.OutParmProbs = ::std::option::Option::Some(v);
    }

    pub fn get_OutParmProbs<'a>(&self) -> i64 {
        self.OutParmProbs.unwrap_or(0)
    }

    // optional int64 OutSrcQuenchs = 20;

    pub fn clear_OutSrcQuenchs(&mut self) {
        self.OutSrcQuenchs = ::std::option::Option::None;
    }

    pub fn has_OutSrcQuenchs(&self) -> bool {
        self.OutSrcQuenchs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutSrcQuenchs(&mut self, v: i64) {
        self.OutSrcQuenchs = ::std::option::Option::Some(v);
    }

    pub fn get_OutSrcQuenchs<'a>(&self) -> i64 {
        self.OutSrcQuenchs.unwrap_or(0)
    }

    // optional int64 OutRedirects = 21;

    pub fn clear_OutRedirects(&mut self) {
        self.OutRedirects = ::std::option::Option::None;
    }

    pub fn has_OutRedirects(&self) -> bool {
        self.OutRedirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRedirects(&mut self, v: i64) {
        self.OutRedirects = ::std::option::Option::Some(v);
    }

    pub fn get_OutRedirects<'a>(&self) -> i64 {
        self.OutRedirects.unwrap_or(0)
    }

    // optional int64 OutEchos = 22;

    pub fn clear_OutEchos(&mut self) {
        self.OutEchos = ::std::option::Option::None;
    }

    pub fn has_OutEchos(&self) -> bool {
        self.OutEchos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutEchos(&mut self, v: i64) {
        self.OutEchos = ::std::option::Option::Some(v);
    }

    pub fn get_OutEchos<'a>(&self) -> i64 {
        self.OutEchos.unwrap_or(0)
    }

    // optional int64 OutEchoReps = 23;

    pub fn clear_OutEchoReps(&mut self) {
        self.OutEchoReps = ::std::option::Option::None;
    }

    pub fn has_OutEchoReps(&self) -> bool {
        self.OutEchoReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutEchoReps(&mut self, v: i64) {
        self.OutEchoReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutEchoReps<'a>(&self) -> i64 {
        self.OutEchoReps.unwrap_or(0)
    }

    // optional int64 OutTimestamps = 24;

    pub fn clear_OutTimestamps(&mut self) {
        self.OutTimestamps = ::std::option::Option::None;
    }

    pub fn has_OutTimestamps(&self) -> bool {
        self.OutTimestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimestamps(&mut self, v: i64) {
        self.OutTimestamps = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimestamps<'a>(&self) -> i64 {
        self.OutTimestamps.unwrap_or(0)
    }

    // optional int64 OutTimestampReps = 25;

    pub fn clear_OutTimestampReps(&mut self) {
        self.OutTimestampReps = ::std::option::Option::None;
    }

    pub fn has_OutTimestampReps(&self) -> bool {
        self.OutTimestampReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutTimestampReps(&mut self, v: i64) {
        self.OutTimestampReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutTimestampReps<'a>(&self) -> i64 {
        self.OutTimestampReps.unwrap_or(0)
    }

    // optional int64 OutAddrMasks = 26;

    pub fn clear_OutAddrMasks(&mut self) {
        self.OutAddrMasks = ::std::option::Option::None;
    }

    pub fn has_OutAddrMasks(&self) -> bool {
        self.OutAddrMasks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutAddrMasks(&mut self, v: i64) {
        self.OutAddrMasks = ::std::option::Option::Some(v);
    }

    pub fn get_OutAddrMasks<'a>(&self) -> i64 {
        self.OutAddrMasks.unwrap_or(0)
    }

    // optional int64 OutAddrMaskReps = 27;

    pub fn clear_OutAddrMaskReps(&mut self) {
        self.OutAddrMaskReps = ::std::option::Option::None;
    }

    pub fn has_OutAddrMaskReps(&self) -> bool {
        self.OutAddrMaskReps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutAddrMaskReps(&mut self, v: i64) {
        self.OutAddrMaskReps = ::std::option::Option::Some(v);
    }

    pub fn get_OutAddrMaskReps<'a>(&self) -> i64 {
        self.OutAddrMaskReps.unwrap_or(0)
    }
}

impl ::protobuf::Message for IcmpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InMsgs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InErrors = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InDestUnreachs = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InTimeExcds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InParmProbs = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InSrcQuenchs = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InRedirects = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InEchos = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InEchoReps = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InTimestamps = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InTimestampReps = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InAddrMasks = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InAddrMaskReps = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutMsgs = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutErrors = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutDestUnreachs = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutTimeExcds = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutParmProbs = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutSrcQuenchs = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutRedirects = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutEchos = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutEchoReps = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutTimestamps = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutTimestampReps = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutAddrMasks = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutAddrMaskReps = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.InMsgs.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InErrors.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InCsumErrors.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InDestUnreachs.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InTimeExcds.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InParmProbs.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InSrcQuenchs.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InRedirects.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InEchos.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InEchoReps.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InTimestamps.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InTimestampReps.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InAddrMasks.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InAddrMaskReps.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutMsgs.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutErrors.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutDestUnreachs.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutTimeExcds.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutParmProbs.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutSrcQuenchs.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutRedirects.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutEchos.iter() {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutEchoReps.iter() {
            my_size += ::protobuf::rt::value_size(23, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutTimestamps.iter() {
            my_size += ::protobuf::rt::value_size(24, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutTimestampReps.iter() {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutAddrMasks.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutAddrMaskReps.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.InMsgs {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.InErrors {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.InCsumErrors {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.InDestUnreachs {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.InTimeExcds {
            try!(os.write_int64(5, v));
        };
        if let Some(v) = self.InParmProbs {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.InSrcQuenchs {
            try!(os.write_int64(7, v));
        };
        if let Some(v) = self.InRedirects {
            try!(os.write_int64(8, v));
        };
        if let Some(v) = self.InEchos {
            try!(os.write_int64(9, v));
        };
        if let Some(v) = self.InEchoReps {
            try!(os.write_int64(10, v));
        };
        if let Some(v) = self.InTimestamps {
            try!(os.write_int64(11, v));
        };
        if let Some(v) = self.InTimestampReps {
            try!(os.write_int64(12, v));
        };
        if let Some(v) = self.InAddrMasks {
            try!(os.write_int64(13, v));
        };
        if let Some(v) = self.InAddrMaskReps {
            try!(os.write_int64(14, v));
        };
        if let Some(v) = self.OutMsgs {
            try!(os.write_int64(15, v));
        };
        if let Some(v) = self.OutErrors {
            try!(os.write_int64(16, v));
        };
        if let Some(v) = self.OutDestUnreachs {
            try!(os.write_int64(17, v));
        };
        if let Some(v) = self.OutTimeExcds {
            try!(os.write_int64(18, v));
        };
        if let Some(v) = self.OutParmProbs {
            try!(os.write_int64(19, v));
        };
        if let Some(v) = self.OutSrcQuenchs {
            try!(os.write_int64(20, v));
        };
        if let Some(v) = self.OutRedirects {
            try!(os.write_int64(21, v));
        };
        if let Some(v) = self.OutEchos {
            try!(os.write_int64(22, v));
        };
        if let Some(v) = self.OutEchoReps {
            try!(os.write_int64(23, v));
        };
        if let Some(v) = self.OutTimestamps {
            try!(os.write_int64(24, v));
        };
        if let Some(v) = self.OutTimestampReps {
            try!(os.write_int64(25, v));
        };
        if let Some(v) = self.OutAddrMasks {
            try!(os.write_int64(26, v));
        };
        if let Some(v) = self.OutAddrMaskReps {
            try!(os.write_int64(27, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<IcmpStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for IcmpStatistics {
    fn new() -> IcmpStatistics {
        IcmpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<IcmpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InMsgs",
                    IcmpStatistics::has_InMsgs,
                    IcmpStatistics::get_InMsgs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InErrors",
                    IcmpStatistics::has_InErrors,
                    IcmpStatistics::get_InErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InCsumErrors",
                    IcmpStatistics::has_InCsumErrors,
                    IcmpStatistics::get_InCsumErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InDestUnreachs",
                    IcmpStatistics::has_InDestUnreachs,
                    IcmpStatistics::get_InDestUnreachs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InTimeExcds",
                    IcmpStatistics::has_InTimeExcds,
                    IcmpStatistics::get_InTimeExcds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InParmProbs",
                    IcmpStatistics::has_InParmProbs,
                    IcmpStatistics::get_InParmProbs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InSrcQuenchs",
                    IcmpStatistics::has_InSrcQuenchs,
                    IcmpStatistics::get_InSrcQuenchs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InRedirects",
                    IcmpStatistics::has_InRedirects,
                    IcmpStatistics::get_InRedirects,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InEchos",
                    IcmpStatistics::has_InEchos,
                    IcmpStatistics::get_InEchos,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InEchoReps",
                    IcmpStatistics::has_InEchoReps,
                    IcmpStatistics::get_InEchoReps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InTimestamps",
                    IcmpStatistics::has_InTimestamps,
                    IcmpStatistics::get_InTimestamps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InTimestampReps",
                    IcmpStatistics::has_InTimestampReps,
                    IcmpStatistics::get_InTimestampReps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InAddrMasks",
                    IcmpStatistics::has_InAddrMasks,
                    IcmpStatistics::get_InAddrMasks,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InAddrMaskReps",
                    IcmpStatistics::has_InAddrMaskReps,
                    IcmpStatistics::get_InAddrMaskReps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutMsgs",
                    IcmpStatistics::has_OutMsgs,
                    IcmpStatistics::get_OutMsgs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutErrors",
                    IcmpStatistics::has_OutErrors,
                    IcmpStatistics::get_OutErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutDestUnreachs",
                    IcmpStatistics::has_OutDestUnreachs,
                    IcmpStatistics::get_OutDestUnreachs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutTimeExcds",
                    IcmpStatistics::has_OutTimeExcds,
                    IcmpStatistics::get_OutTimeExcds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutParmProbs",
                    IcmpStatistics::has_OutParmProbs,
                    IcmpStatistics::get_OutParmProbs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutSrcQuenchs",
                    IcmpStatistics::has_OutSrcQuenchs,
                    IcmpStatistics::get_OutSrcQuenchs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutRedirects",
                    IcmpStatistics::has_OutRedirects,
                    IcmpStatistics::get_OutRedirects,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutEchos",
                    IcmpStatistics::has_OutEchos,
                    IcmpStatistics::get_OutEchos,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutEchoReps",
                    IcmpStatistics::has_OutEchoReps,
                    IcmpStatistics::get_OutEchoReps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutTimestamps",
                    IcmpStatistics::has_OutTimestamps,
                    IcmpStatistics::get_OutTimestamps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutTimestampReps",
                    IcmpStatistics::has_OutTimestampReps,
                    IcmpStatistics::get_OutTimestampReps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutAddrMasks",
                    IcmpStatistics::has_OutAddrMasks,
                    IcmpStatistics::get_OutAddrMasks,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutAddrMaskReps",
                    IcmpStatistics::has_OutAddrMaskReps,
                    IcmpStatistics::get_OutAddrMaskReps,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IcmpStatistics>(
                    "IcmpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for IcmpStatistics {
    fn clear(&mut self) {
        self.clear_InMsgs();
        self.clear_InErrors();
        self.clear_InCsumErrors();
        self.clear_InDestUnreachs();
        self.clear_InTimeExcds();
        self.clear_InParmProbs();
        self.clear_InSrcQuenchs();
        self.clear_InRedirects();
        self.clear_InEchos();
        self.clear_InEchoReps();
        self.clear_InTimestamps();
        self.clear_InTimestampReps();
        self.clear_InAddrMasks();
        self.clear_InAddrMaskReps();
        self.clear_OutMsgs();
        self.clear_OutErrors();
        self.clear_OutDestUnreachs();
        self.clear_OutTimeExcds();
        self.clear_OutParmProbs();
        self.clear_OutSrcQuenchs();
        self.clear_OutRedirects();
        self.clear_OutEchos();
        self.clear_OutEchoReps();
        self.clear_OutTimestamps();
        self.clear_OutTimestampReps();
        self.clear_OutAddrMasks();
        self.clear_OutAddrMaskReps();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for IcmpStatistics {
    fn eq(&self, other: &IcmpStatistics) -> bool {
        self.InMsgs == other.InMsgs &&
        self.InErrors == other.InErrors &&
        self.InCsumErrors == other.InCsumErrors &&
        self.InDestUnreachs == other.InDestUnreachs &&
        self.InTimeExcds == other.InTimeExcds &&
        self.InParmProbs == other.InParmProbs &&
        self.InSrcQuenchs == other.InSrcQuenchs &&
        self.InRedirects == other.InRedirects &&
        self.InEchos == other.InEchos &&
        self.InEchoReps == other.InEchoReps &&
        self.InTimestamps == other.InTimestamps &&
        self.InTimestampReps == other.InTimestampReps &&
        self.InAddrMasks == other.InAddrMasks &&
        self.InAddrMaskReps == other.InAddrMaskReps &&
        self.OutMsgs == other.OutMsgs &&
        self.OutErrors == other.OutErrors &&
        self.OutDestUnreachs == other.OutDestUnreachs &&
        self.OutTimeExcds == other.OutTimeExcds &&
        self.OutParmProbs == other.OutParmProbs &&
        self.OutSrcQuenchs == other.OutSrcQuenchs &&
        self.OutRedirects == other.OutRedirects &&
        self.OutEchos == other.OutEchos &&
        self.OutEchoReps == other.OutEchoReps &&
        self.OutTimestamps == other.OutTimestamps &&
        self.OutTimestampReps == other.OutTimestampReps &&
        self.OutAddrMasks == other.OutAddrMasks &&
        self.OutAddrMaskReps == other.OutAddrMaskReps &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for IcmpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TcpStatistics {
    // message fields
    RtoAlgorithm: ::std::option::Option<i64>,
    RtoMin: ::std::option::Option<i64>,
    RtoMax: ::std::option::Option<i64>,
    MaxConn: ::std::option::Option<i64>,
    ActiveOpens: ::std::option::Option<i64>,
    PassiveOpens: ::std::option::Option<i64>,
    AttemptFails: ::std::option::Option<i64>,
    EstabResets: ::std::option::Option<i64>,
    CurrEstab: ::std::option::Option<i64>,
    InSegs: ::std::option::Option<i64>,
    OutSegs: ::std::option::Option<i64>,
    RetransSegs: ::std::option::Option<i64>,
    InErrs: ::std::option::Option<i64>,
    OutRsts: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TcpStatistics {}

impl TcpStatistics {
    pub fn new() -> TcpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TcpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<TcpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TcpStatistics,
        };
        unsafe {
            instance.get(|| {
                TcpStatistics {
                    RtoAlgorithm: ::std::option::Option::None,
                    RtoMin: ::std::option::Option::None,
                    RtoMax: ::std::option::Option::None,
                    MaxConn: ::std::option::Option::None,
                    ActiveOpens: ::std::option::Option::None,
                    PassiveOpens: ::std::option::Option::None,
                    AttemptFails: ::std::option::Option::None,
                    EstabResets: ::std::option::Option::None,
                    CurrEstab: ::std::option::Option::None,
                    InSegs: ::std::option::Option::None,
                    OutSegs: ::std::option::Option::None,
                    RetransSegs: ::std::option::Option::None,
                    InErrs: ::std::option::Option::None,
                    OutRsts: ::std::option::Option::None,
                    InCsumErrors: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 RtoAlgorithm = 1;

    pub fn clear_RtoAlgorithm(&mut self) {
        self.RtoAlgorithm = ::std::option::Option::None;
    }

    pub fn has_RtoAlgorithm(&self) -> bool {
        self.RtoAlgorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoAlgorithm(&mut self, v: i64) {
        self.RtoAlgorithm = ::std::option::Option::Some(v);
    }

    pub fn get_RtoAlgorithm<'a>(&self) -> i64 {
        self.RtoAlgorithm.unwrap_or(0)
    }

    // optional int64 RtoMin = 2;

    pub fn clear_RtoMin(&mut self) {
        self.RtoMin = ::std::option::Option::None;
    }

    pub fn has_RtoMin(&self) -> bool {
        self.RtoMin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoMin(&mut self, v: i64) {
        self.RtoMin = ::std::option::Option::Some(v);
    }

    pub fn get_RtoMin<'a>(&self) -> i64 {
        self.RtoMin.unwrap_or(0)
    }

    // optional int64 RtoMax = 3;

    pub fn clear_RtoMax(&mut self) {
        self.RtoMax = ::std::option::Option::None;
    }

    pub fn has_RtoMax(&self) -> bool {
        self.RtoMax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RtoMax(&mut self, v: i64) {
        self.RtoMax = ::std::option::Option::Some(v);
    }

    pub fn get_RtoMax<'a>(&self) -> i64 {
        self.RtoMax.unwrap_or(0)
    }

    // optional int64 MaxConn = 4;

    pub fn clear_MaxConn(&mut self) {
        self.MaxConn = ::std::option::Option::None;
    }

    pub fn has_MaxConn(&self) -> bool {
        self.MaxConn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_MaxConn(&mut self, v: i64) {
        self.MaxConn = ::std::option::Option::Some(v);
    }

    pub fn get_MaxConn<'a>(&self) -> i64 {
        self.MaxConn.unwrap_or(0)
    }

    // optional int64 ActiveOpens = 5;

    pub fn clear_ActiveOpens(&mut self) {
        self.ActiveOpens = ::std::option::Option::None;
    }

    pub fn has_ActiveOpens(&self) -> bool {
        self.ActiveOpens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ActiveOpens(&mut self, v: i64) {
        self.ActiveOpens = ::std::option::Option::Some(v);
    }

    pub fn get_ActiveOpens<'a>(&self) -> i64 {
        self.ActiveOpens.unwrap_or(0)
    }

    // optional int64 PassiveOpens = 6;

    pub fn clear_PassiveOpens(&mut self) {
        self.PassiveOpens = ::std::option::Option::None;
    }

    pub fn has_PassiveOpens(&self) -> bool {
        self.PassiveOpens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PassiveOpens(&mut self, v: i64) {
        self.PassiveOpens = ::std::option::Option::Some(v);
    }

    pub fn get_PassiveOpens<'a>(&self) -> i64 {
        self.PassiveOpens.unwrap_or(0)
    }

    // optional int64 AttemptFails = 7;

    pub fn clear_AttemptFails(&mut self) {
        self.AttemptFails = ::std::option::Option::None;
    }

    pub fn has_AttemptFails(&self) -> bool {
        self.AttemptFails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_AttemptFails(&mut self, v: i64) {
        self.AttemptFails = ::std::option::Option::Some(v);
    }

    pub fn get_AttemptFails<'a>(&self) -> i64 {
        self.AttemptFails.unwrap_or(0)
    }

    // optional int64 EstabResets = 8;

    pub fn clear_EstabResets(&mut self) {
        self.EstabResets = ::std::option::Option::None;
    }

    pub fn has_EstabResets(&self) -> bool {
        self.EstabResets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_EstabResets(&mut self, v: i64) {
        self.EstabResets = ::std::option::Option::Some(v);
    }

    pub fn get_EstabResets<'a>(&self) -> i64 {
        self.EstabResets.unwrap_or(0)
    }

    // optional int64 CurrEstab = 9;

    pub fn clear_CurrEstab(&mut self) {
        self.CurrEstab = ::std::option::Option::None;
    }

    pub fn has_CurrEstab(&self) -> bool {
        self.CurrEstab.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CurrEstab(&mut self, v: i64) {
        self.CurrEstab = ::std::option::Option::Some(v);
    }

    pub fn get_CurrEstab<'a>(&self) -> i64 {
        self.CurrEstab.unwrap_or(0)
    }

    // optional int64 InSegs = 10;

    pub fn clear_InSegs(&mut self) {
        self.InSegs = ::std::option::Option::None;
    }

    pub fn has_InSegs(&self) -> bool {
        self.InSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InSegs(&mut self, v: i64) {
        self.InSegs = ::std::option::Option::Some(v);
    }

    pub fn get_InSegs<'a>(&self) -> i64 {
        self.InSegs.unwrap_or(0)
    }

    // optional int64 OutSegs = 11;

    pub fn clear_OutSegs(&mut self) {
        self.OutSegs = ::std::option::Option::None;
    }

    pub fn has_OutSegs(&self) -> bool {
        self.OutSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutSegs(&mut self, v: i64) {
        self.OutSegs = ::std::option::Option::Some(v);
    }

    pub fn get_OutSegs<'a>(&self) -> i64 {
        self.OutSegs.unwrap_or(0)
    }

    // optional int64 RetransSegs = 12;

    pub fn clear_RetransSegs(&mut self) {
        self.RetransSegs = ::std::option::Option::None;
    }

    pub fn has_RetransSegs(&self) -> bool {
        self.RetransSegs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RetransSegs(&mut self, v: i64) {
        self.RetransSegs = ::std::option::Option::Some(v);
    }

    pub fn get_RetransSegs<'a>(&self) -> i64 {
        self.RetransSegs.unwrap_or(0)
    }

    // optional int64 InErrs = 13;

    pub fn clear_InErrs(&mut self) {
        self.InErrs = ::std::option::Option::None;
    }

    pub fn has_InErrs(&self) -> bool {
        self.InErrs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrs(&mut self, v: i64) {
        self.InErrs = ::std::option::Option::Some(v);
    }

    pub fn get_InErrs<'a>(&self) -> i64 {
        self.InErrs.unwrap_or(0)
    }

    // optional int64 OutRsts = 14;

    pub fn clear_OutRsts(&mut self) {
        self.OutRsts = ::std::option::Option::None;
    }

    pub fn has_OutRsts(&self) -> bool {
        self.OutRsts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutRsts(&mut self, v: i64) {
        self.OutRsts = ::std::option::Option::Some(v);
    }

    pub fn get_OutRsts<'a>(&self) -> i64 {
        self.OutRsts.unwrap_or(0)
    }

    // optional int64 InCsumErrors = 15;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors<'a>(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }
}

impl ::protobuf::Message for TcpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.RtoAlgorithm = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.RtoMin = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.RtoMax = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.MaxConn = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ActiveOpens = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.PassiveOpens = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.AttemptFails = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.EstabResets = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.CurrEstab = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InSegs = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutSegs = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.RetransSegs = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InErrs = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutRsts = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.RtoAlgorithm.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.RtoMin.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.RtoMax.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.MaxConn.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ActiveOpens.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.PassiveOpens.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.AttemptFails.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.EstabResets.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.CurrEstab.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InSegs.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutSegs.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.RetransSegs.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InErrs.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutRsts.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InCsumErrors.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.RtoAlgorithm {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.RtoMin {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.RtoMax {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.MaxConn {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.ActiveOpens {
            try!(os.write_int64(5, v));
        };
        if let Some(v) = self.PassiveOpens {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.AttemptFails {
            try!(os.write_int64(7, v));
        };
        if let Some(v) = self.EstabResets {
            try!(os.write_int64(8, v));
        };
        if let Some(v) = self.CurrEstab {
            try!(os.write_int64(9, v));
        };
        if let Some(v) = self.InSegs {
            try!(os.write_int64(10, v));
        };
        if let Some(v) = self.OutSegs {
            try!(os.write_int64(11, v));
        };
        if let Some(v) = self.RetransSegs {
            try!(os.write_int64(12, v));
        };
        if let Some(v) = self.InErrs {
            try!(os.write_int64(13, v));
        };
        if let Some(v) = self.OutRsts {
            try!(os.write_int64(14, v));
        };
        if let Some(v) = self.InCsumErrors {
            try!(os.write_int64(15, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TcpStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TcpStatistics {
    fn new() -> TcpStatistics {
        TcpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<TcpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "RtoAlgorithm",
                    TcpStatistics::has_RtoAlgorithm,
                    TcpStatistics::get_RtoAlgorithm,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "RtoMin",
                    TcpStatistics::has_RtoMin,
                    TcpStatistics::get_RtoMin,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "RtoMax",
                    TcpStatistics::has_RtoMax,
                    TcpStatistics::get_RtoMax,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "MaxConn",
                    TcpStatistics::has_MaxConn,
                    TcpStatistics::get_MaxConn,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ActiveOpens",
                    TcpStatistics::has_ActiveOpens,
                    TcpStatistics::get_ActiveOpens,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "PassiveOpens",
                    TcpStatistics::has_PassiveOpens,
                    TcpStatistics::get_PassiveOpens,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "AttemptFails",
                    TcpStatistics::has_AttemptFails,
                    TcpStatistics::get_AttemptFails,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "EstabResets",
                    TcpStatistics::has_EstabResets,
                    TcpStatistics::get_EstabResets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "CurrEstab",
                    TcpStatistics::has_CurrEstab,
                    TcpStatistics::get_CurrEstab,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InSegs",
                    TcpStatistics::has_InSegs,
                    TcpStatistics::get_InSegs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutSegs",
                    TcpStatistics::has_OutSegs,
                    TcpStatistics::get_OutSegs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "RetransSegs",
                    TcpStatistics::has_RetransSegs,
                    TcpStatistics::get_RetransSegs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InErrs",
                    TcpStatistics::has_InErrs,
                    TcpStatistics::get_InErrs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutRsts",
                    TcpStatistics::has_OutRsts,
                    TcpStatistics::get_OutRsts,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InCsumErrors",
                    TcpStatistics::has_InCsumErrors,
                    TcpStatistics::get_InCsumErrors,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TcpStatistics>(
                    "TcpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TcpStatistics {
    fn clear(&mut self) {
        self.clear_RtoAlgorithm();
        self.clear_RtoMin();
        self.clear_RtoMax();
        self.clear_MaxConn();
        self.clear_ActiveOpens();
        self.clear_PassiveOpens();
        self.clear_AttemptFails();
        self.clear_EstabResets();
        self.clear_CurrEstab();
        self.clear_InSegs();
        self.clear_OutSegs();
        self.clear_RetransSegs();
        self.clear_InErrs();
        self.clear_OutRsts();
        self.clear_InCsumErrors();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TcpStatistics {
    fn eq(&self, other: &TcpStatistics) -> bool {
        self.RtoAlgorithm == other.RtoAlgorithm &&
        self.RtoMin == other.RtoMin &&
        self.RtoMax == other.RtoMax &&
        self.MaxConn == other.MaxConn &&
        self.ActiveOpens == other.ActiveOpens &&
        self.PassiveOpens == other.PassiveOpens &&
        self.AttemptFails == other.AttemptFails &&
        self.EstabResets == other.EstabResets &&
        self.CurrEstab == other.CurrEstab &&
        self.InSegs == other.InSegs &&
        self.OutSegs == other.OutSegs &&
        self.RetransSegs == other.RetransSegs &&
        self.InErrs == other.InErrs &&
        self.OutRsts == other.OutRsts &&
        self.InCsumErrors == other.InCsumErrors &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TcpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct UdpStatistics {
    // message fields
    InDatagrams: ::std::option::Option<i64>,
    NoPorts: ::std::option::Option<i64>,
    InErrors: ::std::option::Option<i64>,
    OutDatagrams: ::std::option::Option<i64>,
    RcvbufErrors: ::std::option::Option<i64>,
    SndbufErrors: ::std::option::Option<i64>,
    InCsumErrors: ::std::option::Option<i64>,
    IgnoredMulti: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for UdpStatistics {}

impl UdpStatistics {
    pub fn new() -> UdpStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static UdpStatistics {
        static mut instance: ::protobuf::lazy::Lazy<UdpStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UdpStatistics,
        };
        unsafe {
            instance.get(|| {
                UdpStatistics {
                    InDatagrams: ::std::option::Option::None,
                    NoPorts: ::std::option::Option::None,
                    InErrors: ::std::option::Option::None,
                    OutDatagrams: ::std::option::Option::None,
                    RcvbufErrors: ::std::option::Option::None,
                    SndbufErrors: ::std::option::Option::None,
                    InCsumErrors: ::std::option::Option::None,
                    IgnoredMulti: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int64 InDatagrams = 1;

    pub fn clear_InDatagrams(&mut self) {
        self.InDatagrams = ::std::option::Option::None;
    }

    pub fn has_InDatagrams(&self) -> bool {
        self.InDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InDatagrams(&mut self, v: i64) {
        self.InDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_InDatagrams<'a>(&self) -> i64 {
        self.InDatagrams.unwrap_or(0)
    }

    // optional int64 NoPorts = 2;

    pub fn clear_NoPorts(&mut self) {
        self.NoPorts = ::std::option::Option::None;
    }

    pub fn has_NoPorts(&self) -> bool {
        self.NoPorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_NoPorts(&mut self, v: i64) {
        self.NoPorts = ::std::option::Option::Some(v);
    }

    pub fn get_NoPorts<'a>(&self) -> i64 {
        self.NoPorts.unwrap_or(0)
    }

    // optional int64 InErrors = 3;

    pub fn clear_InErrors(&mut self) {
        self.InErrors = ::std::option::Option::None;
    }

    pub fn has_InErrors(&self) -> bool {
        self.InErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InErrors(&mut self, v: i64) {
        self.InErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InErrors<'a>(&self) -> i64 {
        self.InErrors.unwrap_or(0)
    }

    // optional int64 OutDatagrams = 4;

    pub fn clear_OutDatagrams(&mut self) {
        self.OutDatagrams = ::std::option::Option::None;
    }

    pub fn has_OutDatagrams(&self) -> bool {
        self.OutDatagrams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_OutDatagrams(&mut self, v: i64) {
        self.OutDatagrams = ::std::option::Option::Some(v);
    }

    pub fn get_OutDatagrams<'a>(&self) -> i64 {
        self.OutDatagrams.unwrap_or(0)
    }

    // optional int64 RcvbufErrors = 5;

    pub fn clear_RcvbufErrors(&mut self) {
        self.RcvbufErrors = ::std::option::Option::None;
    }

    pub fn has_RcvbufErrors(&self) -> bool {
        self.RcvbufErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RcvbufErrors(&mut self, v: i64) {
        self.RcvbufErrors = ::std::option::Option::Some(v);
    }

    pub fn get_RcvbufErrors<'a>(&self) -> i64 {
        self.RcvbufErrors.unwrap_or(0)
    }

    // optional int64 SndbufErrors = 6;

    pub fn clear_SndbufErrors(&mut self) {
        self.SndbufErrors = ::std::option::Option::None;
    }

    pub fn has_SndbufErrors(&self) -> bool {
        self.SndbufErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SndbufErrors(&mut self, v: i64) {
        self.SndbufErrors = ::std::option::Option::Some(v);
    }

    pub fn get_SndbufErrors<'a>(&self) -> i64 {
        self.SndbufErrors.unwrap_or(0)
    }

    // optional int64 InCsumErrors = 7;

    pub fn clear_InCsumErrors(&mut self) {
        self.InCsumErrors = ::std::option::Option::None;
    }

    pub fn has_InCsumErrors(&self) -> bool {
        self.InCsumErrors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InCsumErrors(&mut self, v: i64) {
        self.InCsumErrors = ::std::option::Option::Some(v);
    }

    pub fn get_InCsumErrors<'a>(&self) -> i64 {
        self.InCsumErrors.unwrap_or(0)
    }

    // optional int64 IgnoredMulti = 8;

    pub fn clear_IgnoredMulti(&mut self) {
        self.IgnoredMulti = ::std::option::Option::None;
    }

    pub fn has_IgnoredMulti(&self) -> bool {
        self.IgnoredMulti.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IgnoredMulti(&mut self, v: i64) {
        self.IgnoredMulti = ::std::option::Option::Some(v);
    }

    pub fn get_IgnoredMulti<'a>(&self) -> i64 {
        self.IgnoredMulti.unwrap_or(0)
    }
}

impl ::protobuf::Message for UdpStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InDatagrams = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.NoPorts = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InErrors = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.OutDatagrams = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.RcvbufErrors = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.SndbufErrors = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.InCsumErrors = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.IgnoredMulti = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.InDatagrams.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.NoPorts.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InErrors.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.OutDatagrams.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.RcvbufErrors.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.SndbufErrors.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.InCsumErrors.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.IgnoredMulti.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.InDatagrams {
            try!(os.write_int64(1, v));
        };
        if let Some(v) = self.NoPorts {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.InErrors {
            try!(os.write_int64(3, v));
        };
        if let Some(v) = self.OutDatagrams {
            try!(os.write_int64(4, v));
        };
        if let Some(v) = self.RcvbufErrors {
            try!(os.write_int64(5, v));
        };
        if let Some(v) = self.SndbufErrors {
            try!(os.write_int64(6, v));
        };
        if let Some(v) = self.InCsumErrors {
            try!(os.write_int64(7, v));
        };
        if let Some(v) = self.IgnoredMulti {
            try!(os.write_int64(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<UdpStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for UdpStatistics {
    fn new() -> UdpStatistics {
        UdpStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<UdpStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InDatagrams",
                    UdpStatistics::has_InDatagrams,
                    UdpStatistics::get_InDatagrams,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "NoPorts",
                    UdpStatistics::has_NoPorts,
                    UdpStatistics::get_NoPorts,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InErrors",
                    UdpStatistics::has_InErrors,
                    UdpStatistics::get_InErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "OutDatagrams",
                    UdpStatistics::has_OutDatagrams,
                    UdpStatistics::get_OutDatagrams,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "RcvbufErrors",
                    UdpStatistics::has_RcvbufErrors,
                    UdpStatistics::get_RcvbufErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "SndbufErrors",
                    UdpStatistics::has_SndbufErrors,
                    UdpStatistics::get_SndbufErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "InCsumErrors",
                    UdpStatistics::has_InCsumErrors,
                    UdpStatistics::get_InCsumErrors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "IgnoredMulti",
                    UdpStatistics::has_IgnoredMulti,
                    UdpStatistics::get_IgnoredMulti,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UdpStatistics>(
                    "UdpStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for UdpStatistics {
    fn clear(&mut self) {
        self.clear_InDatagrams();
        self.clear_NoPorts();
        self.clear_InErrors();
        self.clear_OutDatagrams();
        self.clear_RcvbufErrors();
        self.clear_SndbufErrors();
        self.clear_InCsumErrors();
        self.clear_IgnoredMulti();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for UdpStatistics {
    fn eq(&self, other: &UdpStatistics) -> bool {
        self.InDatagrams == other.InDatagrams &&
        self.NoPorts == other.NoPorts &&
        self.InErrors == other.InErrors &&
        self.OutDatagrams == other.OutDatagrams &&
        self.RcvbufErrors == other.RcvbufErrors &&
        self.SndbufErrors == other.SndbufErrors &&
        self.InCsumErrors == other.InCsumErrors &&
        self.IgnoredMulti == other.IgnoredMulti &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for UdpStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct SNMPStatistics {
    // message fields
    ip_stats: ::protobuf::SingularPtrField<IpStatistics>,
    icmp_stats: ::protobuf::SingularPtrField<IcmpStatistics>,
    tcp_stats: ::protobuf::SingularPtrField<TcpStatistics>,
    udp_stats: ::protobuf::SingularPtrField<UdpStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for SNMPStatistics {}

impl SNMPStatistics {
    pub fn new() -> SNMPStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static SNMPStatistics {
        static mut instance: ::protobuf::lazy::Lazy<SNMPStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SNMPStatistics,
        };
        unsafe {
            instance.get(|| {
                SNMPStatistics {
                    ip_stats: ::protobuf::SingularPtrField::none(),
                    icmp_stats: ::protobuf::SingularPtrField::none(),
                    tcp_stats: ::protobuf::SingularPtrField::none(),
                    udp_stats: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.IpStatistics ip_stats = 1;

    pub fn clear_ip_stats(&mut self) {
        self.ip_stats.clear();
    }

    pub fn has_ip_stats(&self) -> bool {
        self.ip_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_stats(&mut self, v: IpStatistics) {
        self.ip_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_stats<'a>(&'a mut self) -> &'a mut IpStatistics {
        if self.ip_stats.is_none() {
            self.ip_stats.set_default();
        };
        self.ip_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_stats(&mut self) -> IpStatistics {
        self.ip_stats.take().unwrap_or_else(|| IpStatistics::new())
    }

    pub fn get_ip_stats<'a>(&'a self) -> &'a IpStatistics {
        self.ip_stats.as_ref().unwrap_or_else(|| IpStatistics::default_instance())
    }

    // optional .mesos.v1.IcmpStatistics icmp_stats = 2;

    pub fn clear_icmp_stats(&mut self) {
        self.icmp_stats.clear();
    }

    pub fn has_icmp_stats(&self) -> bool {
        self.icmp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icmp_stats(&mut self, v: IcmpStatistics) {
        self.icmp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icmp_stats<'a>(&'a mut self) -> &'a mut IcmpStatistics {
        if self.icmp_stats.is_none() {
            self.icmp_stats.set_default();
        };
        self.icmp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_icmp_stats(&mut self) -> IcmpStatistics {
        self.icmp_stats.take().unwrap_or_else(|| IcmpStatistics::new())
    }

    pub fn get_icmp_stats<'a>(&'a self) -> &'a IcmpStatistics {
        self.icmp_stats.as_ref().unwrap_or_else(|| IcmpStatistics::default_instance())
    }

    // optional .mesos.v1.TcpStatistics tcp_stats = 3;

    pub fn clear_tcp_stats(&mut self) {
        self.tcp_stats.clear();
    }

    pub fn has_tcp_stats(&self) -> bool {
        self.tcp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcp_stats(&mut self, v: TcpStatistics) {
        self.tcp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcp_stats<'a>(&'a mut self) -> &'a mut TcpStatistics {
        if self.tcp_stats.is_none() {
            self.tcp_stats.set_default();
        };
        self.tcp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcp_stats(&mut self) -> TcpStatistics {
        self.tcp_stats.take().unwrap_or_else(|| TcpStatistics::new())
    }

    pub fn get_tcp_stats<'a>(&'a self) -> &'a TcpStatistics {
        self.tcp_stats.as_ref().unwrap_or_else(|| TcpStatistics::default_instance())
    }

    // optional .mesos.v1.UdpStatistics udp_stats = 4;

    pub fn clear_udp_stats(&mut self) {
        self.udp_stats.clear();
    }

    pub fn has_udp_stats(&self) -> bool {
        self.udp_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_udp_stats(&mut self, v: UdpStatistics) {
        self.udp_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_udp_stats<'a>(&'a mut self) -> &'a mut UdpStatistics {
        if self.udp_stats.is_none() {
            self.udp_stats.set_default();
        };
        self.udp_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_udp_stats(&mut self) -> UdpStatistics {
        self.udp_stats.take().unwrap_or_else(|| UdpStatistics::new())
    }

    pub fn get_udp_stats<'a>(&'a self) -> &'a UdpStatistics {
        self.udp_stats.as_ref().unwrap_or_else(|| UdpStatistics::default_instance())
    }
}

impl ::protobuf::Message for SNMPStatistics {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ip_stats));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.icmp_stats));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcp_stats));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.udp_stats));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ip_stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.icmp_stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.tcp_stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.udp_stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ip_stats.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.icmp_stats.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.tcp_stats.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.udp_stats.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<SNMPStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for SNMPStatistics {
    fn new() -> SNMPStatistics {
        SNMPStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<SNMPStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ip_stats",
                    SNMPStatistics::has_ip_stats,
                    SNMPStatistics::get_ip_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "icmp_stats",
                    SNMPStatistics::has_icmp_stats,
                    SNMPStatistics::get_icmp_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "tcp_stats",
                    SNMPStatistics::has_tcp_stats,
                    SNMPStatistics::get_tcp_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "udp_stats",
                    SNMPStatistics::has_udp_stats,
                    SNMPStatistics::get_udp_stats,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SNMPStatistics>(
                    "SNMPStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for SNMPStatistics {
    fn clear(&mut self) {
        self.clear_ip_stats();
        self.clear_icmp_stats();
        self.clear_tcp_stats();
        self.clear_udp_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for SNMPStatistics {
    fn eq(&self, other: &SNMPStatistics) -> bool {
        self.ip_stats == other.ip_stats &&
        self.icmp_stats == other.icmp_stats &&
        self.tcp_stats == other.tcp_stats &&
        self.udp_stats == other.udp_stats &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for SNMPStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    processes: ::std::option::Option<u32>,
    threads: ::std::option::Option<u32>,
    cpus_user_time_secs: ::std::option::Option<f64>,
    cpus_system_time_secs: ::std::option::Option<f64>,
    cpus_limit: ::std::option::Option<f64>,
    cpus_nr_periods: ::std::option::Option<u32>,
    cpus_nr_throttled: ::std::option::Option<u32>,
    cpus_throttled_time_secs: ::std::option::Option<f64>,
    mem_total_bytes: ::std::option::Option<u64>,
    mem_total_memsw_bytes: ::std::option::Option<u64>,
    mem_limit_bytes: ::std::option::Option<u64>,
    mem_soft_limit_bytes: ::std::option::Option<u64>,
    mem_file_bytes: ::std::option::Option<u64>,
    mem_anon_bytes: ::std::option::Option<u64>,
    mem_cache_bytes: ::std::option::Option<u64>,
    mem_rss_bytes: ::std::option::Option<u64>,
    mem_mapped_file_bytes: ::std::option::Option<u64>,
    mem_swap_bytes: ::std::option::Option<u64>,
    mem_unevictable_bytes: ::std::option::Option<u64>,
    mem_low_pressure_counter: ::std::option::Option<u64>,
    mem_medium_pressure_counter: ::std::option::Option<u64>,
    mem_critical_pressure_counter: ::std::option::Option<u64>,
    disk_limit_bytes: ::std::option::Option<u64>,
    disk_used_bytes: ::std::option::Option<u64>,
    perf: ::protobuf::SingularPtrField<PerfStatistics>,
    net_rx_packets: ::std::option::Option<u64>,
    net_rx_bytes: ::std::option::Option<u64>,
    net_rx_errors: ::std::option::Option<u64>,
    net_rx_dropped: ::std::option::Option<u64>,
    net_tx_packets: ::std::option::Option<u64>,
    net_tx_bytes: ::std::option::Option<u64>,
    net_tx_errors: ::std::option::Option<u64>,
    net_tx_dropped: ::std::option::Option<u64>,
    net_tcp_rtt_microsecs_p50: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p90: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p95: ::std::option::Option<f64>,
    net_tcp_rtt_microsecs_p99: ::std::option::Option<f64>,
    net_tcp_active_connections: ::std::option::Option<f64>,
    net_tcp_time_wait_connections: ::std::option::Option<f64>,
    net_traffic_control_statistics: ::protobuf::RepeatedField<TrafficControlStatistics>,
    net_snmp_statistics: ::protobuf::SingularPtrField<SNMPStatistics>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceStatistics {}

impl ResourceStatistics {
    pub fn new() -> ResourceStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceStatistics {
        static mut instance: ::protobuf::lazy::Lazy<ResourceStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceStatistics,
        };
        unsafe {
            instance.get(|| {
                ResourceStatistics {
                    timestamp: ::std::option::Option::None,
                    processes: ::std::option::Option::None,
                    threads: ::std::option::Option::None,
                    cpus_user_time_secs: ::std::option::Option::None,
                    cpus_system_time_secs: ::std::option::Option::None,
                    cpus_limit: ::std::option::Option::None,
                    cpus_nr_periods: ::std::option::Option::None,
                    cpus_nr_throttled: ::std::option::Option::None,
                    cpus_throttled_time_secs: ::std::option::Option::None,
                    mem_total_bytes: ::std::option::Option::None,
                    mem_total_memsw_bytes: ::std::option::Option::None,
                    mem_limit_bytes: ::std::option::Option::None,
                    mem_soft_limit_bytes: ::std::option::Option::None,
                    mem_file_bytes: ::std::option::Option::None,
                    mem_anon_bytes: ::std::option::Option::None,
                    mem_cache_bytes: ::std::option::Option::None,
                    mem_rss_bytes: ::std::option::Option::None,
                    mem_mapped_file_bytes: ::std::option::Option::None,
                    mem_swap_bytes: ::std::option::Option::None,
                    mem_unevictable_bytes: ::std::option::Option::None,
                    mem_low_pressure_counter: ::std::option::Option::None,
                    mem_medium_pressure_counter: ::std::option::Option::None,
                    mem_critical_pressure_counter: ::std::option::Option::None,
                    disk_limit_bytes: ::std::option::Option::None,
                    disk_used_bytes: ::std::option::Option::None,
                    perf: ::protobuf::SingularPtrField::none(),
                    net_rx_packets: ::std::option::Option::None,
                    net_rx_bytes: ::std::option::Option::None,
                    net_rx_errors: ::std::option::Option::None,
                    net_rx_dropped: ::std::option::Option::None,
                    net_tx_packets: ::std::option::Option::None,
                    net_tx_bytes: ::std::option::Option::None,
                    net_tx_errors: ::std::option::Option::None,
                    net_tx_dropped: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p50: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p90: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p95: ::std::option::Option::None,
                    net_tcp_rtt_microsecs_p99: ::std::option::Option::None,
                    net_tcp_active_connections: ::std::option::Option::None,
                    net_tcp_time_wait_connections: ::std::option::Option::None,
                    net_traffic_control_statistics: ::protobuf::RepeatedField::new(),
                    net_snmp_statistics: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // optional uint32 processes = 30;

    pub fn clear_processes(&mut self) {
        self.processes = ::std::option::Option::None;
    }

    pub fn has_processes(&self) -> bool {
        self.processes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_processes(&mut self, v: u32) {
        self.processes = ::std::option::Option::Some(v);
    }

    pub fn get_processes<'a>(&self) -> u32 {
        self.processes.unwrap_or(0)
    }

    // optional uint32 threads = 31;

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: u32) {
        self.threads = ::std::option::Option::Some(v);
    }

    pub fn get_threads<'a>(&self) -> u32 {
        self.threads.unwrap_or(0)
    }

    // optional double cpus_user_time_secs = 2;

    pub fn clear_cpus_user_time_secs(&mut self) {
        self.cpus_user_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_user_time_secs(&self) -> bool {
        self.cpus_user_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_user_time_secs(&mut self, v: f64) {
        self.cpus_user_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_user_time_secs<'a>(&self) -> f64 {
        self.cpus_user_time_secs.unwrap_or(0.)
    }

    // optional double cpus_system_time_secs = 3;

    pub fn clear_cpus_system_time_secs(&mut self) {
        self.cpus_system_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_system_time_secs(&self) -> bool {
        self.cpus_system_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_system_time_secs(&mut self, v: f64) {
        self.cpus_system_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_system_time_secs<'a>(&self) -> f64 {
        self.cpus_system_time_secs.unwrap_or(0.)
    }

    // optional double cpus_limit = 4;

    pub fn clear_cpus_limit(&mut self) {
        self.cpus_limit = ::std::option::Option::None;
    }

    pub fn has_cpus_limit(&self) -> bool {
        self.cpus_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_limit(&mut self, v: f64) {
        self.cpus_limit = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_limit<'a>(&self) -> f64 {
        self.cpus_limit.unwrap_or(0.)
    }

    // optional uint32 cpus_nr_periods = 7;

    pub fn clear_cpus_nr_periods(&mut self) {
        self.cpus_nr_periods = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_periods(&self) -> bool {
        self.cpus_nr_periods.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_periods(&mut self, v: u32) {
        self.cpus_nr_periods = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_periods<'a>(&self) -> u32 {
        self.cpus_nr_periods.unwrap_or(0)
    }

    // optional uint32 cpus_nr_throttled = 8;

    pub fn clear_cpus_nr_throttled(&mut self) {
        self.cpus_nr_throttled = ::std::option::Option::None;
    }

    pub fn has_cpus_nr_throttled(&self) -> bool {
        self.cpus_nr_throttled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_nr_throttled(&mut self, v: u32) {
        self.cpus_nr_throttled = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_nr_throttled<'a>(&self) -> u32 {
        self.cpus_nr_throttled.unwrap_or(0)
    }

    // optional double cpus_throttled_time_secs = 9;

    pub fn clear_cpus_throttled_time_secs(&mut self) {
        self.cpus_throttled_time_secs = ::std::option::Option::None;
    }

    pub fn has_cpus_throttled_time_secs(&self) -> bool {
        self.cpus_throttled_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpus_throttled_time_secs(&mut self, v: f64) {
        self.cpus_throttled_time_secs = ::std::option::Option::Some(v);
    }

    pub fn get_cpus_throttled_time_secs<'a>(&self) -> f64 {
        self.cpus_throttled_time_secs.unwrap_or(0.)
    }

    // optional uint64 mem_total_bytes = 36;

    pub fn clear_mem_total_bytes(&mut self) {
        self.mem_total_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_bytes(&self) -> bool {
        self.mem_total_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_bytes(&mut self, v: u64) {
        self.mem_total_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_bytes<'a>(&self) -> u64 {
        self.mem_total_bytes.unwrap_or(0)
    }

    // optional uint64 mem_total_memsw_bytes = 37;

    pub fn clear_mem_total_memsw_bytes(&mut self) {
        self.mem_total_memsw_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_total_memsw_bytes(&self) -> bool {
        self.mem_total_memsw_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_total_memsw_bytes(&mut self, v: u64) {
        self.mem_total_memsw_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_total_memsw_bytes<'a>(&self) -> u64 {
        self.mem_total_memsw_bytes.unwrap_or(0)
    }

    // optional uint64 mem_limit_bytes = 6;

    pub fn clear_mem_limit_bytes(&mut self) {
        self.mem_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_limit_bytes(&self) -> bool {
        self.mem_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_limit_bytes(&mut self, v: u64) {
        self.mem_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_limit_bytes<'a>(&self) -> u64 {
        self.mem_limit_bytes.unwrap_or(0)
    }

    // optional uint64 mem_soft_limit_bytes = 38;

    pub fn clear_mem_soft_limit_bytes(&mut self) {
        self.mem_soft_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_soft_limit_bytes(&self) -> bool {
        self.mem_soft_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_soft_limit_bytes(&mut self, v: u64) {
        self.mem_soft_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_soft_limit_bytes<'a>(&self) -> u64 {
        self.mem_soft_limit_bytes.unwrap_or(0)
    }

    // optional uint64 mem_file_bytes = 10;

    pub fn clear_mem_file_bytes(&mut self) {
        self.mem_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_file_bytes(&self) -> bool {
        self.mem_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_file_bytes(&mut self, v: u64) {
        self.mem_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_file_bytes<'a>(&self) -> u64 {
        self.mem_file_bytes.unwrap_or(0)
    }

    // optional uint64 mem_anon_bytes = 11;

    pub fn clear_mem_anon_bytes(&mut self) {
        self.mem_anon_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_anon_bytes(&self) -> bool {
        self.mem_anon_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_anon_bytes(&mut self, v: u64) {
        self.mem_anon_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_anon_bytes<'a>(&self) -> u64 {
        self.mem_anon_bytes.unwrap_or(0)
    }

    // optional uint64 mem_cache_bytes = 39;

    pub fn clear_mem_cache_bytes(&mut self) {
        self.mem_cache_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_cache_bytes(&self) -> bool {
        self.mem_cache_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_cache_bytes(&mut self, v: u64) {
        self.mem_cache_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_cache_bytes<'a>(&self) -> u64 {
        self.mem_cache_bytes.unwrap_or(0)
    }

    // optional uint64 mem_rss_bytes = 5;

    pub fn clear_mem_rss_bytes(&mut self) {
        self.mem_rss_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_rss_bytes(&self) -> bool {
        self.mem_rss_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_rss_bytes(&mut self, v: u64) {
        self.mem_rss_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_rss_bytes<'a>(&self) -> u64 {
        self.mem_rss_bytes.unwrap_or(0)
    }

    // optional uint64 mem_mapped_file_bytes = 12;

    pub fn clear_mem_mapped_file_bytes(&mut self) {
        self.mem_mapped_file_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_mapped_file_bytes(&self) -> bool {
        self.mem_mapped_file_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_mapped_file_bytes(&mut self, v: u64) {
        self.mem_mapped_file_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_mapped_file_bytes<'a>(&self) -> u64 {
        self.mem_mapped_file_bytes.unwrap_or(0)
    }

    // optional uint64 mem_swap_bytes = 40;

    pub fn clear_mem_swap_bytes(&mut self) {
        self.mem_swap_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_swap_bytes(&self) -> bool {
        self.mem_swap_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_swap_bytes(&mut self, v: u64) {
        self.mem_swap_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_swap_bytes<'a>(&self) -> u64 {
        self.mem_swap_bytes.unwrap_or(0)
    }

    // optional uint64 mem_unevictable_bytes = 41;

    pub fn clear_mem_unevictable_bytes(&mut self) {
        self.mem_unevictable_bytes = ::std::option::Option::None;
    }

    pub fn has_mem_unevictable_bytes(&self) -> bool {
        self.mem_unevictable_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_unevictable_bytes(&mut self, v: u64) {
        self.mem_unevictable_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_mem_unevictable_bytes<'a>(&self) -> u64 {
        self.mem_unevictable_bytes.unwrap_or(0)
    }

    // optional uint64 mem_low_pressure_counter = 32;

    pub fn clear_mem_low_pressure_counter(&mut self) {
        self.mem_low_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_low_pressure_counter(&self) -> bool {
        self.mem_low_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_low_pressure_counter(&mut self, v: u64) {
        self.mem_low_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_low_pressure_counter<'a>(&self) -> u64 {
        self.mem_low_pressure_counter.unwrap_or(0)
    }

    // optional uint64 mem_medium_pressure_counter = 33;

    pub fn clear_mem_medium_pressure_counter(&mut self) {
        self.mem_medium_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_medium_pressure_counter(&self) -> bool {
        self.mem_medium_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_medium_pressure_counter(&mut self, v: u64) {
        self.mem_medium_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_medium_pressure_counter<'a>(&self) -> u64 {
        self.mem_medium_pressure_counter.unwrap_or(0)
    }

    // optional uint64 mem_critical_pressure_counter = 34;

    pub fn clear_mem_critical_pressure_counter(&mut self) {
        self.mem_critical_pressure_counter = ::std::option::Option::None;
    }

    pub fn has_mem_critical_pressure_counter(&self) -> bool {
        self.mem_critical_pressure_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_critical_pressure_counter(&mut self, v: u64) {
        self.mem_critical_pressure_counter = ::std::option::Option::Some(v);
    }

    pub fn get_mem_critical_pressure_counter<'a>(&self) -> u64 {
        self.mem_critical_pressure_counter.unwrap_or(0)
    }

    // optional uint64 disk_limit_bytes = 26;

    pub fn clear_disk_limit_bytes(&mut self) {
        self.disk_limit_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_limit_bytes(&self) -> bool {
        self.disk_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_limit_bytes(&mut self, v: u64) {
        self.disk_limit_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_limit_bytes<'a>(&self) -> u64 {
        self.disk_limit_bytes.unwrap_or(0)
    }

    // optional uint64 disk_used_bytes = 27;

    pub fn clear_disk_used_bytes(&mut self) {
        self.disk_used_bytes = ::std::option::Option::None;
    }

    pub fn has_disk_used_bytes(&self) -> bool {
        self.disk_used_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disk_used_bytes(&mut self, v: u64) {
        self.disk_used_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_disk_used_bytes<'a>(&self) -> u64 {
        self.disk_used_bytes.unwrap_or(0)
    }

    // optional .mesos.v1.PerfStatistics perf = 13;

    pub fn clear_perf(&mut self) {
        self.perf.clear();
    }

    pub fn has_perf(&self) -> bool {
        self.perf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf(&mut self, v: PerfStatistics) {
        self.perf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_perf<'a>(&'a mut self) -> &'a mut PerfStatistics {
        if self.perf.is_none() {
            self.perf.set_default();
        };
        self.perf.as_mut().unwrap()
    }

    // Take field
    pub fn take_perf(&mut self) -> PerfStatistics {
        self.perf.take().unwrap_or_else(|| PerfStatistics::new())
    }

    pub fn get_perf<'a>(&'a self) -> &'a PerfStatistics {
        self.perf.as_ref().unwrap_or_else(|| PerfStatistics::default_instance())
    }

    // optional uint64 net_rx_packets = 14;

    pub fn clear_net_rx_packets(&mut self) {
        self.net_rx_packets = ::std::option::Option::None;
    }

    pub fn has_net_rx_packets(&self) -> bool {
        self.net_rx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_packets(&mut self, v: u64) {
        self.net_rx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_packets<'a>(&self) -> u64 {
        self.net_rx_packets.unwrap_or(0)
    }

    // optional uint64 net_rx_bytes = 15;

    pub fn clear_net_rx_bytes(&mut self) {
        self.net_rx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_rx_bytes(&self) -> bool {
        self.net_rx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_bytes(&mut self, v: u64) {
        self.net_rx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_bytes<'a>(&self) -> u64 {
        self.net_rx_bytes.unwrap_or(0)
    }

    // optional uint64 net_rx_errors = 16;

    pub fn clear_net_rx_errors(&mut self) {
        self.net_rx_errors = ::std::option::Option::None;
    }

    pub fn has_net_rx_errors(&self) -> bool {
        self.net_rx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_errors(&mut self, v: u64) {
        self.net_rx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_errors<'a>(&self) -> u64 {
        self.net_rx_errors.unwrap_or(0)
    }

    // optional uint64 net_rx_dropped = 17;

    pub fn clear_net_rx_dropped(&mut self) {
        self.net_rx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_rx_dropped(&self) -> bool {
        self.net_rx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_rx_dropped(&mut self, v: u64) {
        self.net_rx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_rx_dropped<'a>(&self) -> u64 {
        self.net_rx_dropped.unwrap_or(0)
    }

    // optional uint64 net_tx_packets = 18;

    pub fn clear_net_tx_packets(&mut self) {
        self.net_tx_packets = ::std::option::Option::None;
    }

    pub fn has_net_tx_packets(&self) -> bool {
        self.net_tx_packets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_packets(&mut self, v: u64) {
        self.net_tx_packets = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_packets<'a>(&self) -> u64 {
        self.net_tx_packets.unwrap_or(0)
    }

    // optional uint64 net_tx_bytes = 19;

    pub fn clear_net_tx_bytes(&mut self) {
        self.net_tx_bytes = ::std::option::Option::None;
    }

    pub fn has_net_tx_bytes(&self) -> bool {
        self.net_tx_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_bytes(&mut self, v: u64) {
        self.net_tx_bytes = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_bytes<'a>(&self) -> u64 {
        self.net_tx_bytes.unwrap_or(0)
    }

    // optional uint64 net_tx_errors = 20;

    pub fn clear_net_tx_errors(&mut self) {
        self.net_tx_errors = ::std::option::Option::None;
    }

    pub fn has_net_tx_errors(&self) -> bool {
        self.net_tx_errors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_errors(&mut self, v: u64) {
        self.net_tx_errors = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_errors<'a>(&self) -> u64 {
        self.net_tx_errors.unwrap_or(0)
    }

    // optional uint64 net_tx_dropped = 21;

    pub fn clear_net_tx_dropped(&mut self) {
        self.net_tx_dropped = ::std::option::Option::None;
    }

    pub fn has_net_tx_dropped(&self) -> bool {
        self.net_tx_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tx_dropped(&mut self, v: u64) {
        self.net_tx_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_net_tx_dropped<'a>(&self) -> u64 {
        self.net_tx_dropped.unwrap_or(0)
    }

    // optional double net_tcp_rtt_microsecs_p50 = 22;

    pub fn clear_net_tcp_rtt_microsecs_p50(&mut self) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p50(&self) -> bool {
        self.net_tcp_rtt_microsecs_p50.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p50(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p50<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p50.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p90 = 23;

    pub fn clear_net_tcp_rtt_microsecs_p90(&mut self) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p90(&self) -> bool {
        self.net_tcp_rtt_microsecs_p90.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p90(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p90<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p90.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p95 = 24;

    pub fn clear_net_tcp_rtt_microsecs_p95(&mut self) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p95(&self) -> bool {
        self.net_tcp_rtt_microsecs_p95.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p95(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p95<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p95.unwrap_or(0.)
    }

    // optional double net_tcp_rtt_microsecs_p99 = 25;

    pub fn clear_net_tcp_rtt_microsecs_p99(&mut self) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::None;
    }

    pub fn has_net_tcp_rtt_microsecs_p99(&self) -> bool {
        self.net_tcp_rtt_microsecs_p99.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_rtt_microsecs_p99(&mut self, v: f64) {
        self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_rtt_microsecs_p99<'a>(&self) -> f64 {
        self.net_tcp_rtt_microsecs_p99.unwrap_or(0.)
    }

    // optional double net_tcp_active_connections = 28;

    pub fn clear_net_tcp_active_connections(&mut self) {
        self.net_tcp_active_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_active_connections(&self) -> bool {
        self.net_tcp_active_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_active_connections(&mut self, v: f64) {
        self.net_tcp_active_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_active_connections<'a>(&self) -> f64 {
        self.net_tcp_active_connections.unwrap_or(0.)
    }

    // optional double net_tcp_time_wait_connections = 29;

    pub fn clear_net_tcp_time_wait_connections(&mut self) {
        self.net_tcp_time_wait_connections = ::std::option::Option::None;
    }

    pub fn has_net_tcp_time_wait_connections(&self) -> bool {
        self.net_tcp_time_wait_connections.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_tcp_time_wait_connections(&mut self, v: f64) {
        self.net_tcp_time_wait_connections = ::std::option::Option::Some(v);
    }

    pub fn get_net_tcp_time_wait_connections<'a>(&self) -> f64 {
        self.net_tcp_time_wait_connections.unwrap_or(0.)
    }

    // repeated .mesos.v1.TrafficControlStatistics net_traffic_control_statistics = 35;

    pub fn clear_net_traffic_control_statistics(&mut self) {
        self.net_traffic_control_statistics.clear();
    }

    // Param is passed by value, moved
    pub fn set_net_traffic_control_statistics(&mut self, v: ::protobuf::RepeatedField<TrafficControlStatistics>) {
        self.net_traffic_control_statistics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_net_traffic_control_statistics<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<TrafficControlStatistics> {
        &mut self.net_traffic_control_statistics
    }

    // Take field
    pub fn take_net_traffic_control_statistics(&mut self) -> ::protobuf::RepeatedField<TrafficControlStatistics> {
        ::std::mem::replace(&mut self.net_traffic_control_statistics, ::protobuf::RepeatedField::new())
    }

    pub fn get_net_traffic_control_statistics<'a>(&'a self) -> &'a [TrafficControlStatistics] {
        &self.net_traffic_control_statistics
    }

    // optional .mesos.v1.SNMPStatistics net_snmp_statistics = 42;

    pub fn clear_net_snmp_statistics(&mut self) {
        self.net_snmp_statistics.clear();
    }

    pub fn has_net_snmp_statistics(&self) -> bool {
        self.net_snmp_statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_snmp_statistics(&mut self, v: SNMPStatistics) {
        self.net_snmp_statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_snmp_statistics<'a>(&'a mut self) -> &'a mut SNMPStatistics {
        if self.net_snmp_statistics.is_none() {
            self.net_snmp_statistics.set_default();
        };
        self.net_snmp_statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_snmp_statistics(&mut self) -> SNMPStatistics {
        self.net_snmp_statistics.take().unwrap_or_else(|| SNMPStatistics::new())
    }

    pub fn get_net_snmp_statistics<'a>(&'a self) -> &'a SNMPStatistics {
        self.net_snmp_statistics.as_ref().unwrap_or_else(|| SNMPStatistics::default_instance())
    }
}

impl ::protobuf::Message for ResourceStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.processes = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.threads = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_user_time_secs = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_system_time_secs = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_limit = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cpus_nr_periods = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cpus_nr_throttled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.cpus_throttled_time_secs = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_total_bytes = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_total_memsw_bytes = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_limit_bytes = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_soft_limit_bytes = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_file_bytes = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_anon_bytes = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_cache_bytes = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_rss_bytes = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_mapped_file_bytes = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_swap_bytes = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_unevictable_bytes = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_low_pressure_counter = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_medium_pressure_counter = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.mem_critical_pressure_counter = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.disk_limit_bytes = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.disk_used_bytes = ::std::option::Option::Some(tmp);
                },
                13 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.perf));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_packets = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_bytes = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_errors = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_rx_dropped = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_packets = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_bytes = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_errors = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.net_tx_dropped = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p50 = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p90 = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p95 = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_rtt_microsecs_p99 = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_active_connections = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.net_tcp_time_wait_connections = ::std::option::Option::Some(tmp);
                },
                35 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.net_traffic_control_statistics));
                },
                42 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_snmp_statistics));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp.is_some() {
            my_size += 9;
        };
        for value in self.processes.iter() {
            my_size += ::protobuf::rt::value_size(30, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.threads.iter() {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpus_user_time_secs.is_some() {
            my_size += 9;
        };
        if self.cpus_system_time_secs.is_some() {
            my_size += 9;
        };
        if self.cpus_limit.is_some() {
            my_size += 9;
        };
        for value in self.cpus_nr_periods.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cpus_nr_throttled.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpus_throttled_time_secs.is_some() {
            my_size += 9;
        };
        for value in self.mem_total_bytes.iter() {
            my_size += ::protobuf::rt::value_size(36, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_total_memsw_bytes.iter() {
            my_size += ::protobuf::rt::value_size(37, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_soft_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(38, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_file_bytes.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_anon_bytes.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_cache_bytes.iter() {
            my_size += ::protobuf::rt::value_size(39, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_rss_bytes.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_mapped_file_bytes.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_swap_bytes.iter() {
            my_size += ::protobuf::rt::value_size(40, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_unevictable_bytes.iter() {
            my_size += ::protobuf::rt::value_size(41, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_low_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_medium_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_critical_pressure_counter.iter() {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.disk_limit_bytes.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.disk_used_bytes.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.perf.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.net_rx_packets.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_bytes.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_errors.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_rx_dropped.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_packets.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_bytes.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_errors.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.net_tx_dropped.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.net_tcp_rtt_microsecs_p50.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p90.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p95.is_some() {
            my_size += 10;
        };
        if self.net_tcp_rtt_microsecs_p99.is_some() {
            my_size += 10;
        };
        if self.net_tcp_active_connections.is_some() {
            my_size += 10;
        };
        if self.net_tcp_time_wait_connections.is_some() {
            my_size += 10;
        };
        for value in self.net_traffic_control_statistics.iter() {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.net_snmp_statistics.iter() {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.processes {
            try!(os.write_uint32(30, v));
        };
        if let Some(v) = self.threads {
            try!(os.write_uint32(31, v));
        };
        if let Some(v) = self.cpus_user_time_secs {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.cpus_system_time_secs {
            try!(os.write_double(3, v));
        };
        if let Some(v) = self.cpus_limit {
            try!(os.write_double(4, v));
        };
        if let Some(v) = self.cpus_nr_periods {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.cpus_nr_throttled {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.cpus_throttled_time_secs {
            try!(os.write_double(9, v));
        };
        if let Some(v) = self.mem_total_bytes {
            try!(os.write_uint64(36, v));
        };
        if let Some(v) = self.mem_total_memsw_bytes {
            try!(os.write_uint64(37, v));
        };
        if let Some(v) = self.mem_limit_bytes {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.mem_soft_limit_bytes {
            try!(os.write_uint64(38, v));
        };
        if let Some(v) = self.mem_file_bytes {
            try!(os.write_uint64(10, v));
        };
        if let Some(v) = self.mem_anon_bytes {
            try!(os.write_uint64(11, v));
        };
        if let Some(v) = self.mem_cache_bytes {
            try!(os.write_uint64(39, v));
        };
        if let Some(v) = self.mem_rss_bytes {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.mem_mapped_file_bytes {
            try!(os.write_uint64(12, v));
        };
        if let Some(v) = self.mem_swap_bytes {
            try!(os.write_uint64(40, v));
        };
        if let Some(v) = self.mem_unevictable_bytes {
            try!(os.write_uint64(41, v));
        };
        if let Some(v) = self.mem_low_pressure_counter {
            try!(os.write_uint64(32, v));
        };
        if let Some(v) = self.mem_medium_pressure_counter {
            try!(os.write_uint64(33, v));
        };
        if let Some(v) = self.mem_critical_pressure_counter {
            try!(os.write_uint64(34, v));
        };
        if let Some(v) = self.disk_limit_bytes {
            try!(os.write_uint64(26, v));
        };
        if let Some(v) = self.disk_used_bytes {
            try!(os.write_uint64(27, v));
        };
        if let Some(v) = self.perf.as_ref() {
            try!(os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.net_rx_packets {
            try!(os.write_uint64(14, v));
        };
        if let Some(v) = self.net_rx_bytes {
            try!(os.write_uint64(15, v));
        };
        if let Some(v) = self.net_rx_errors {
            try!(os.write_uint64(16, v));
        };
        if let Some(v) = self.net_rx_dropped {
            try!(os.write_uint64(17, v));
        };
        if let Some(v) = self.net_tx_packets {
            try!(os.write_uint64(18, v));
        };
        if let Some(v) = self.net_tx_bytes {
            try!(os.write_uint64(19, v));
        };
        if let Some(v) = self.net_tx_errors {
            try!(os.write_uint64(20, v));
        };
        if let Some(v) = self.net_tx_dropped {
            try!(os.write_uint64(21, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p50 {
            try!(os.write_double(22, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p90 {
            try!(os.write_double(23, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p95 {
            try!(os.write_double(24, v));
        };
        if let Some(v) = self.net_tcp_rtt_microsecs_p99 {
            try!(os.write_double(25, v));
        };
        if let Some(v) = self.net_tcp_active_connections {
            try!(os.write_double(28, v));
        };
        if let Some(v) = self.net_tcp_time_wait_connections {
            try!(os.write_double(29, v));
        };
        for v in self.net_traffic_control_statistics.iter() {
            try!(os.write_tag(35, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.net_snmp_statistics.as_ref() {
            try!(os.write_tag(42, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceStatistics {
    fn new() -> ResourceStatistics {
        ResourceStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    ResourceStatistics::has_timestamp,
                    ResourceStatistics::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "processes",
                    ResourceStatistics::has_processes,
                    ResourceStatistics::get_processes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "threads",
                    ResourceStatistics::has_threads,
                    ResourceStatistics::get_threads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_user_time_secs",
                    ResourceStatistics::has_cpus_user_time_secs,
                    ResourceStatistics::get_cpus_user_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_system_time_secs",
                    ResourceStatistics::has_cpus_system_time_secs,
                    ResourceStatistics::get_cpus_system_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_limit",
                    ResourceStatistics::has_cpus_limit,
                    ResourceStatistics::get_cpus_limit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cpus_nr_periods",
                    ResourceStatistics::has_cpus_nr_periods,
                    ResourceStatistics::get_cpus_nr_periods,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cpus_nr_throttled",
                    ResourceStatistics::has_cpus_nr_throttled,
                    ResourceStatistics::get_cpus_nr_throttled,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpus_throttled_time_secs",
                    ResourceStatistics::has_cpus_throttled_time_secs,
                    ResourceStatistics::get_cpus_throttled_time_secs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_total_bytes",
                    ResourceStatistics::has_mem_total_bytes,
                    ResourceStatistics::get_mem_total_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_total_memsw_bytes",
                    ResourceStatistics::has_mem_total_memsw_bytes,
                    ResourceStatistics::get_mem_total_memsw_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_limit_bytes",
                    ResourceStatistics::has_mem_limit_bytes,
                    ResourceStatistics::get_mem_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_soft_limit_bytes",
                    ResourceStatistics::has_mem_soft_limit_bytes,
                    ResourceStatistics::get_mem_soft_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_file_bytes",
                    ResourceStatistics::has_mem_file_bytes,
                    ResourceStatistics::get_mem_file_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_anon_bytes",
                    ResourceStatistics::has_mem_anon_bytes,
                    ResourceStatistics::get_mem_anon_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_cache_bytes",
                    ResourceStatistics::has_mem_cache_bytes,
                    ResourceStatistics::get_mem_cache_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_rss_bytes",
                    ResourceStatistics::has_mem_rss_bytes,
                    ResourceStatistics::get_mem_rss_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_mapped_file_bytes",
                    ResourceStatistics::has_mem_mapped_file_bytes,
                    ResourceStatistics::get_mem_mapped_file_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_swap_bytes",
                    ResourceStatistics::has_mem_swap_bytes,
                    ResourceStatistics::get_mem_swap_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_unevictable_bytes",
                    ResourceStatistics::has_mem_unevictable_bytes,
                    ResourceStatistics::get_mem_unevictable_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_low_pressure_counter",
                    ResourceStatistics::has_mem_low_pressure_counter,
                    ResourceStatistics::get_mem_low_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_medium_pressure_counter",
                    ResourceStatistics::has_mem_medium_pressure_counter,
                    ResourceStatistics::get_mem_medium_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "mem_critical_pressure_counter",
                    ResourceStatistics::has_mem_critical_pressure_counter,
                    ResourceStatistics::get_mem_critical_pressure_counter,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "disk_limit_bytes",
                    ResourceStatistics::has_disk_limit_bytes,
                    ResourceStatistics::get_disk_limit_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "disk_used_bytes",
                    ResourceStatistics::has_disk_used_bytes,
                    ResourceStatistics::get_disk_used_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "perf",
                    ResourceStatistics::has_perf,
                    ResourceStatistics::get_perf,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_packets",
                    ResourceStatistics::has_net_rx_packets,
                    ResourceStatistics::get_net_rx_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_bytes",
                    ResourceStatistics::has_net_rx_bytes,
                    ResourceStatistics::get_net_rx_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_errors",
                    ResourceStatistics::has_net_rx_errors,
                    ResourceStatistics::get_net_rx_errors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_rx_dropped",
                    ResourceStatistics::has_net_rx_dropped,
                    ResourceStatistics::get_net_rx_dropped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_packets",
                    ResourceStatistics::has_net_tx_packets,
                    ResourceStatistics::get_net_tx_packets,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_bytes",
                    ResourceStatistics::has_net_tx_bytes,
                    ResourceStatistics::get_net_tx_bytes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_errors",
                    ResourceStatistics::has_net_tx_errors,
                    ResourceStatistics::get_net_tx_errors,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "net_tx_dropped",
                    ResourceStatistics::has_net_tx_dropped,
                    ResourceStatistics::get_net_tx_dropped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p50",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p50,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p50,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p90",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p90,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p90,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p95",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p95,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p95,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_rtt_microsecs_p99",
                    ResourceStatistics::has_net_tcp_rtt_microsecs_p99,
                    ResourceStatistics::get_net_tcp_rtt_microsecs_p99,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_active_connections",
                    ResourceStatistics::has_net_tcp_active_connections,
                    ResourceStatistics::get_net_tcp_active_connections,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "net_tcp_time_wait_connections",
                    ResourceStatistics::has_net_tcp_time_wait_connections,
                    ResourceStatistics::get_net_tcp_time_wait_connections,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "net_traffic_control_statistics",
                    ResourceStatistics::get_net_traffic_control_statistics,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "net_snmp_statistics",
                    ResourceStatistics::has_net_snmp_statistics,
                    ResourceStatistics::get_net_snmp_statistics,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceStatistics>(
                    "ResourceStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_processes();
        self.clear_threads();
        self.clear_cpus_user_time_secs();
        self.clear_cpus_system_time_secs();
        self.clear_cpus_limit();
        self.clear_cpus_nr_periods();
        self.clear_cpus_nr_throttled();
        self.clear_cpus_throttled_time_secs();
        self.clear_mem_total_bytes();
        self.clear_mem_total_memsw_bytes();
        self.clear_mem_limit_bytes();
        self.clear_mem_soft_limit_bytes();
        self.clear_mem_file_bytes();
        self.clear_mem_anon_bytes();
        self.clear_mem_cache_bytes();
        self.clear_mem_rss_bytes();
        self.clear_mem_mapped_file_bytes();
        self.clear_mem_swap_bytes();
        self.clear_mem_unevictable_bytes();
        self.clear_mem_low_pressure_counter();
        self.clear_mem_medium_pressure_counter();
        self.clear_mem_critical_pressure_counter();
        self.clear_disk_limit_bytes();
        self.clear_disk_used_bytes();
        self.clear_perf();
        self.clear_net_rx_packets();
        self.clear_net_rx_bytes();
        self.clear_net_rx_errors();
        self.clear_net_rx_dropped();
        self.clear_net_tx_packets();
        self.clear_net_tx_bytes();
        self.clear_net_tx_errors();
        self.clear_net_tx_dropped();
        self.clear_net_tcp_rtt_microsecs_p50();
        self.clear_net_tcp_rtt_microsecs_p90();
        self.clear_net_tcp_rtt_microsecs_p95();
        self.clear_net_tcp_rtt_microsecs_p99();
        self.clear_net_tcp_active_connections();
        self.clear_net_tcp_time_wait_connections();
        self.clear_net_traffic_control_statistics();
        self.clear_net_snmp_statistics();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceStatistics {
    fn eq(&self, other: &ResourceStatistics) -> bool {
        self.timestamp == other.timestamp &&
        self.processes == other.processes &&
        self.threads == other.threads &&
        self.cpus_user_time_secs == other.cpus_user_time_secs &&
        self.cpus_system_time_secs == other.cpus_system_time_secs &&
        self.cpus_limit == other.cpus_limit &&
        self.cpus_nr_periods == other.cpus_nr_periods &&
        self.cpus_nr_throttled == other.cpus_nr_throttled &&
        self.cpus_throttled_time_secs == other.cpus_throttled_time_secs &&
        self.mem_total_bytes == other.mem_total_bytes &&
        self.mem_total_memsw_bytes == other.mem_total_memsw_bytes &&
        self.mem_limit_bytes == other.mem_limit_bytes &&
        self.mem_soft_limit_bytes == other.mem_soft_limit_bytes &&
        self.mem_file_bytes == other.mem_file_bytes &&
        self.mem_anon_bytes == other.mem_anon_bytes &&
        self.mem_cache_bytes == other.mem_cache_bytes &&
        self.mem_rss_bytes == other.mem_rss_bytes &&
        self.mem_mapped_file_bytes == other.mem_mapped_file_bytes &&
        self.mem_swap_bytes == other.mem_swap_bytes &&
        self.mem_unevictable_bytes == other.mem_unevictable_bytes &&
        self.mem_low_pressure_counter == other.mem_low_pressure_counter &&
        self.mem_medium_pressure_counter == other.mem_medium_pressure_counter &&
        self.mem_critical_pressure_counter == other.mem_critical_pressure_counter &&
        self.disk_limit_bytes == other.disk_limit_bytes &&
        self.disk_used_bytes == other.disk_used_bytes &&
        self.perf == other.perf &&
        self.net_rx_packets == other.net_rx_packets &&
        self.net_rx_bytes == other.net_rx_bytes &&
        self.net_rx_errors == other.net_rx_errors &&
        self.net_rx_dropped == other.net_rx_dropped &&
        self.net_tx_packets == other.net_tx_packets &&
        self.net_tx_bytes == other.net_tx_bytes &&
        self.net_tx_errors == other.net_tx_errors &&
        self.net_tx_dropped == other.net_tx_dropped &&
        self.net_tcp_rtt_microsecs_p50 == other.net_tcp_rtt_microsecs_p50 &&
        self.net_tcp_rtt_microsecs_p90 == other.net_tcp_rtt_microsecs_p90 &&
        self.net_tcp_rtt_microsecs_p95 == other.net_tcp_rtt_microsecs_p95 &&
        self.net_tcp_rtt_microsecs_p99 == other.net_tcp_rtt_microsecs_p99 &&
        self.net_tcp_active_connections == other.net_tcp_active_connections &&
        self.net_tcp_time_wait_connections == other.net_tcp_time_wait_connections &&
        self.net_traffic_control_statistics == other.net_traffic_control_statistics &&
        self.net_snmp_statistics == other.net_snmp_statistics &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceUsage {
    // message fields
    executors: ::protobuf::RepeatedField<ResourceUsage_Executor>,
    total: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceUsage {}

impl ResourceUsage {
    pub fn new() -> ResourceUsage {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage,
        };
        unsafe {
            instance.get(|| {
                ResourceUsage {
                    executors: ::protobuf::RepeatedField::new(),
                    total: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.ResourceUsage.Executor executors = 1;

    pub fn clear_executors(&mut self) {
        self.executors.clear();
    }

    // Param is passed by value, moved
    pub fn set_executors(&mut self, v: ::protobuf::RepeatedField<ResourceUsage_Executor>) {
        self.executors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executors<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ResourceUsage_Executor> {
        &mut self.executors
    }

    // Take field
    pub fn take_executors(&mut self) -> ::protobuf::RepeatedField<ResourceUsage_Executor> {
        ::std::mem::replace(&mut self.executors, ::protobuf::RepeatedField::new())
    }

    pub fn get_executors<'a>(&'a self) -> &'a [ResourceUsage_Executor] {
        &self.executors
    }

    // repeated .mesos.v1.Resource total = 2;

    pub fn clear_total(&mut self) {
        self.total.clear();
    }

    // Param is passed by value, moved
    pub fn set_total(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.total = v;
    }

    // Mutable pointer to the field.
    pub fn mut_total<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.total
    }

    // Take field
    pub fn take_total(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.total, ::protobuf::RepeatedField::new())
    }

    pub fn get_total<'a>(&'a self) -> &'a [Resource] {
        &self.total
    }
}

impl ::protobuf::Message for ResourceUsage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executors));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.total));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executors.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.total.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.executors.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.total.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceUsage>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage {
    fn new() -> ResourceUsage {
        ResourceUsage::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "executors",
                    ResourceUsage::get_executors,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "total",
                    ResourceUsage::get_total,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage>(
                    "ResourceUsage",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage {
    fn clear(&mut self) {
        self.clear_executors();
        self.clear_total();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceUsage {
    fn eq(&self, other: &ResourceUsage) -> bool {
        self.executors == other.executors &&
        self.total == other.total &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceUsage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ResourceUsage_Executor {
    // message fields
    executor_info: ::protobuf::SingularPtrField<ExecutorInfo>,
    allocated: ::protobuf::RepeatedField<Resource>,
    statistics: ::protobuf::SingularPtrField<ResourceStatistics>,
    container_id: ::protobuf::SingularPtrField<ContainerID>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ResourceUsage_Executor {}

impl ResourceUsage_Executor {
    pub fn new() -> ResourceUsage_Executor {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ResourceUsage_Executor {
        static mut instance: ::protobuf::lazy::Lazy<ResourceUsage_Executor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ResourceUsage_Executor,
        };
        unsafe {
            instance.get(|| {
                ResourceUsage_Executor {
                    executor_info: ::protobuf::SingularPtrField::none(),
                    allocated: ::protobuf::RepeatedField::new(),
                    statistics: ::protobuf::SingularPtrField::none(),
                    container_id: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.ExecutorInfo executor_info = 1;

    pub fn clear_executor_info(&mut self) {
        self.executor_info.clear();
    }

    pub fn has_executor_info(&self) -> bool {
        self.executor_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_info(&mut self, v: ExecutorInfo) {
        self.executor_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_info<'a>(&'a mut self) -> &'a mut ExecutorInfo {
        if self.executor_info.is_none() {
            self.executor_info.set_default();
        };
        self.executor_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_info(&mut self) -> ExecutorInfo {
        self.executor_info.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor_info<'a>(&'a self) -> &'a ExecutorInfo {
        self.executor_info.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    // repeated .mesos.v1.Resource allocated = 2;

    pub fn clear_allocated(&mut self) {
        self.allocated.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocated(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.allocated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocated<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.allocated
    }

    // Take field
    pub fn take_allocated(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.allocated, ::protobuf::RepeatedField::new())
    }

    pub fn get_allocated<'a>(&'a self) -> &'a [Resource] {
        &self.allocated
    }

    // optional .mesos.v1.ResourceStatistics statistics = 3;

    pub fn clear_statistics(&mut self) {
        self.statistics.clear();
    }

    pub fn has_statistics(&self) -> bool {
        self.statistics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statistics(&mut self, v: ResourceStatistics) {
        self.statistics = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_statistics<'a>(&'a mut self) -> &'a mut ResourceStatistics {
        if self.statistics.is_none() {
            self.statistics.set_default();
        };
        self.statistics.as_mut().unwrap()
    }

    // Take field
    pub fn take_statistics(&mut self) -> ResourceStatistics {
        self.statistics.take().unwrap_or_else(|| ResourceStatistics::new())
    }

    pub fn get_statistics<'a>(&'a self) -> &'a ResourceStatistics {
        self.statistics.as_ref().unwrap_or_else(|| ResourceStatistics::default_instance())
    }

    // required .mesos.v1.ContainerID container_id = 4;

    pub fn clear_container_id(&mut self) {
        self.container_id.clear();
    }

    pub fn has_container_id(&self) -> bool {
        self.container_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_id(&mut self, v: ContainerID) {
        self.container_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_id<'a>(&'a mut self) -> &'a mut ContainerID {
        if self.container_id.is_none() {
            self.container_id.set_default();
        };
        self.container_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_id(&mut self) -> ContainerID {
        self.container_id.take().unwrap_or_else(|| ContainerID::new())
    }

    pub fn get_container_id<'a>(&'a self) -> &'a ContainerID {
        self.container_id.as_ref().unwrap_or_else(|| ContainerID::default_instance())
    }
}

impl ::protobuf::Message for ResourceUsage_Executor {
    fn is_initialized(&self) -> bool {
        if self.executor_info.is_none() {
            return false;
        };
        if self.container_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_info));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allocated));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.statistics));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container_id));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.executor_info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.allocated.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.statistics.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.executor_info.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.allocated.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.statistics.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container_id.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ResourceUsage_Executor>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ResourceUsage_Executor {
    fn new() -> ResourceUsage_Executor {
        ResourceUsage_Executor::new()
    }

    fn descriptor_static(_: ::std::option::Option<ResourceUsage_Executor>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_info",
                    ResourceUsage_Executor::has_executor_info,
                    ResourceUsage_Executor::get_executor_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "allocated",
                    ResourceUsage_Executor::get_allocated,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "statistics",
                    ResourceUsage_Executor::has_statistics,
                    ResourceUsage_Executor::get_statistics,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container_id",
                    ResourceUsage_Executor::has_container_id,
                    ResourceUsage_Executor::get_container_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ResourceUsage_Executor>(
                    "ResourceUsage_Executor",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ResourceUsage_Executor {
    fn clear(&mut self) {
        self.clear_executor_info();
        self.clear_allocated();
        self.clear_statistics();
        self.clear_container_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ResourceUsage_Executor {
    fn eq(&self, other: &ResourceUsage_Executor) -> bool {
        self.executor_info == other.executor_info &&
        self.allocated == other.allocated &&
        self.statistics == other.statistics &&
        self.container_id == other.container_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ResourceUsage_Executor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct PerfStatistics {
    // message fields
    timestamp: ::std::option::Option<f64>,
    duration: ::std::option::Option<f64>,
    cycles: ::std::option::Option<u64>,
    stalled_cycles_frontend: ::std::option::Option<u64>,
    stalled_cycles_backend: ::std::option::Option<u64>,
    instructions: ::std::option::Option<u64>,
    cache_references: ::std::option::Option<u64>,
    cache_misses: ::std::option::Option<u64>,
    branches: ::std::option::Option<u64>,
    branch_misses: ::std::option::Option<u64>,
    bus_cycles: ::std::option::Option<u64>,
    ref_cycles: ::std::option::Option<u64>,
    cpu_clock: ::std::option::Option<f64>,
    task_clock: ::std::option::Option<f64>,
    page_faults: ::std::option::Option<u64>,
    minor_faults: ::std::option::Option<u64>,
    major_faults: ::std::option::Option<u64>,
    context_switches: ::std::option::Option<u64>,
    cpu_migrations: ::std::option::Option<u64>,
    alignment_faults: ::std::option::Option<u64>,
    emulation_faults: ::std::option::Option<u64>,
    l1_dcache_loads: ::std::option::Option<u64>,
    l1_dcache_load_misses: ::std::option::Option<u64>,
    l1_dcache_stores: ::std::option::Option<u64>,
    l1_dcache_store_misses: ::std::option::Option<u64>,
    l1_dcache_prefetches: ::std::option::Option<u64>,
    l1_dcache_prefetch_misses: ::std::option::Option<u64>,
    l1_icache_loads: ::std::option::Option<u64>,
    l1_icache_load_misses: ::std::option::Option<u64>,
    l1_icache_prefetches: ::std::option::Option<u64>,
    l1_icache_prefetch_misses: ::std::option::Option<u64>,
    llc_loads: ::std::option::Option<u64>,
    llc_load_misses: ::std::option::Option<u64>,
    llc_stores: ::std::option::Option<u64>,
    llc_store_misses: ::std::option::Option<u64>,
    llc_prefetches: ::std::option::Option<u64>,
    llc_prefetch_misses: ::std::option::Option<u64>,
    dtlb_loads: ::std::option::Option<u64>,
    dtlb_load_misses: ::std::option::Option<u64>,
    dtlb_stores: ::std::option::Option<u64>,
    dtlb_store_misses: ::std::option::Option<u64>,
    dtlb_prefetches: ::std::option::Option<u64>,
    dtlb_prefetch_misses: ::std::option::Option<u64>,
    itlb_loads: ::std::option::Option<u64>,
    itlb_load_misses: ::std::option::Option<u64>,
    branch_loads: ::std::option::Option<u64>,
    branch_load_misses: ::std::option::Option<u64>,
    node_loads: ::std::option::Option<u64>,
    node_load_misses: ::std::option::Option<u64>,
    node_stores: ::std::option::Option<u64>,
    node_store_misses: ::std::option::Option<u64>,
    node_prefetches: ::std::option::Option<u64>,
    node_prefetch_misses: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for PerfStatistics {}

impl PerfStatistics {
    pub fn new() -> PerfStatistics {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static PerfStatistics {
        static mut instance: ::protobuf::lazy::Lazy<PerfStatistics> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PerfStatistics,
        };
        unsafe {
            instance.get(|| {
                PerfStatistics {
                    timestamp: ::std::option::Option::None,
                    duration: ::std::option::Option::None,
                    cycles: ::std::option::Option::None,
                    stalled_cycles_frontend: ::std::option::Option::None,
                    stalled_cycles_backend: ::std::option::Option::None,
                    instructions: ::std::option::Option::None,
                    cache_references: ::std::option::Option::None,
                    cache_misses: ::std::option::Option::None,
                    branches: ::std::option::Option::None,
                    branch_misses: ::std::option::Option::None,
                    bus_cycles: ::std::option::Option::None,
                    ref_cycles: ::std::option::Option::None,
                    cpu_clock: ::std::option::Option::None,
                    task_clock: ::std::option::Option::None,
                    page_faults: ::std::option::Option::None,
                    minor_faults: ::std::option::Option::None,
                    major_faults: ::std::option::Option::None,
                    context_switches: ::std::option::Option::None,
                    cpu_migrations: ::std::option::Option::None,
                    alignment_faults: ::std::option::Option::None,
                    emulation_faults: ::std::option::Option::None,
                    l1_dcache_loads: ::std::option::Option::None,
                    l1_dcache_load_misses: ::std::option::Option::None,
                    l1_dcache_stores: ::std::option::Option::None,
                    l1_dcache_store_misses: ::std::option::Option::None,
                    l1_dcache_prefetches: ::std::option::Option::None,
                    l1_dcache_prefetch_misses: ::std::option::Option::None,
                    l1_icache_loads: ::std::option::Option::None,
                    l1_icache_load_misses: ::std::option::Option::None,
                    l1_icache_prefetches: ::std::option::Option::None,
                    l1_icache_prefetch_misses: ::std::option::Option::None,
                    llc_loads: ::std::option::Option::None,
                    llc_load_misses: ::std::option::Option::None,
                    llc_stores: ::std::option::Option::None,
                    llc_store_misses: ::std::option::Option::None,
                    llc_prefetches: ::std::option::Option::None,
                    llc_prefetch_misses: ::std::option::Option::None,
                    dtlb_loads: ::std::option::Option::None,
                    dtlb_load_misses: ::std::option::Option::None,
                    dtlb_stores: ::std::option::Option::None,
                    dtlb_store_misses: ::std::option::Option::None,
                    dtlb_prefetches: ::std::option::Option::None,
                    dtlb_prefetch_misses: ::std::option::Option::None,
                    itlb_loads: ::std::option::Option::None,
                    itlb_load_misses: ::std::option::Option::None,
                    branch_loads: ::std::option::Option::None,
                    branch_load_misses: ::std::option::Option::None,
                    node_loads: ::std::option::Option::None,
                    node_load_misses: ::std::option::Option::None,
                    node_stores: ::std::option::Option::None,
                    node_store_misses: ::std::option::Option::None,
                    node_prefetches: ::std::option::Option::None,
                    node_prefetch_misses: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double timestamp = 1;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // required double duration = 2;

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f64) {
        self.duration = ::std::option::Option::Some(v);
    }

    pub fn get_duration<'a>(&self) -> f64 {
        self.duration.unwrap_or(0.)
    }

    // optional uint64 cycles = 3;

    pub fn clear_cycles(&mut self) {
        self.cycles = ::std::option::Option::None;
    }

    pub fn has_cycles(&self) -> bool {
        self.cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycles(&mut self, v: u64) {
        self.cycles = ::std::option::Option::Some(v);
    }

    pub fn get_cycles<'a>(&self) -> u64 {
        self.cycles.unwrap_or(0)
    }

    // optional uint64 stalled_cycles_frontend = 4;

    pub fn clear_stalled_cycles_frontend(&mut self) {
        self.stalled_cycles_frontend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_frontend(&self) -> bool {
        self.stalled_cycles_frontend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_frontend(&mut self, v: u64) {
        self.stalled_cycles_frontend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_frontend<'a>(&self) -> u64 {
        self.stalled_cycles_frontend.unwrap_or(0)
    }

    // optional uint64 stalled_cycles_backend = 5;

    pub fn clear_stalled_cycles_backend(&mut self) {
        self.stalled_cycles_backend = ::std::option::Option::None;
    }

    pub fn has_stalled_cycles_backend(&self) -> bool {
        self.stalled_cycles_backend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stalled_cycles_backend(&mut self, v: u64) {
        self.stalled_cycles_backend = ::std::option::Option::Some(v);
    }

    pub fn get_stalled_cycles_backend<'a>(&self) -> u64 {
        self.stalled_cycles_backend.unwrap_or(0)
    }

    // optional uint64 instructions = 6;

    pub fn clear_instructions(&mut self) {
        self.instructions = ::std::option::Option::None;
    }

    pub fn has_instructions(&self) -> bool {
        self.instructions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instructions(&mut self, v: u64) {
        self.instructions = ::std::option::Option::Some(v);
    }

    pub fn get_instructions<'a>(&self) -> u64 {
        self.instructions.unwrap_or(0)
    }

    // optional uint64 cache_references = 7;

    pub fn clear_cache_references(&mut self) {
        self.cache_references = ::std::option::Option::None;
    }

    pub fn has_cache_references(&self) -> bool {
        self.cache_references.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_references(&mut self, v: u64) {
        self.cache_references = ::std::option::Option::Some(v);
    }

    pub fn get_cache_references<'a>(&self) -> u64 {
        self.cache_references.unwrap_or(0)
    }

    // optional uint64 cache_misses = 8;

    pub fn clear_cache_misses(&mut self) {
        self.cache_misses = ::std::option::Option::None;
    }

    pub fn has_cache_misses(&self) -> bool {
        self.cache_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_misses(&mut self, v: u64) {
        self.cache_misses = ::std::option::Option::Some(v);
    }

    pub fn get_cache_misses<'a>(&self) -> u64 {
        self.cache_misses.unwrap_or(0)
    }

    // optional uint64 branches = 9;

    pub fn clear_branches(&mut self) {
        self.branches = ::std::option::Option::None;
    }

    pub fn has_branches(&self) -> bool {
        self.branches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branches(&mut self, v: u64) {
        self.branches = ::std::option::Option::Some(v);
    }

    pub fn get_branches<'a>(&self) -> u64 {
        self.branches.unwrap_or(0)
    }

    // optional uint64 branch_misses = 10;

    pub fn clear_branch_misses(&mut self) {
        self.branch_misses = ::std::option::Option::None;
    }

    pub fn has_branch_misses(&self) -> bool {
        self.branch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_misses(&mut self, v: u64) {
        self.branch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_misses<'a>(&self) -> u64 {
        self.branch_misses.unwrap_or(0)
    }

    // optional uint64 bus_cycles = 11;

    pub fn clear_bus_cycles(&mut self) {
        self.bus_cycles = ::std::option::Option::None;
    }

    pub fn has_bus_cycles(&self) -> bool {
        self.bus_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bus_cycles(&mut self, v: u64) {
        self.bus_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_bus_cycles<'a>(&self) -> u64 {
        self.bus_cycles.unwrap_or(0)
    }

    // optional uint64 ref_cycles = 12;

    pub fn clear_ref_cycles(&mut self) {
        self.ref_cycles = ::std::option::Option::None;
    }

    pub fn has_ref_cycles(&self) -> bool {
        self.ref_cycles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ref_cycles(&mut self, v: u64) {
        self.ref_cycles = ::std::option::Option::Some(v);
    }

    pub fn get_ref_cycles<'a>(&self) -> u64 {
        self.ref_cycles.unwrap_or(0)
    }

    // optional double cpu_clock = 13;

    pub fn clear_cpu_clock(&mut self) {
        self.cpu_clock = ::std::option::Option::None;
    }

    pub fn has_cpu_clock(&self) -> bool {
        self.cpu_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_clock(&mut self, v: f64) {
        self.cpu_clock = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_clock<'a>(&self) -> f64 {
        self.cpu_clock.unwrap_or(0.)
    }

    // optional double task_clock = 14;

    pub fn clear_task_clock(&mut self) {
        self.task_clock = ::std::option::Option::None;
    }

    pub fn has_task_clock(&self) -> bool {
        self.task_clock.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_clock(&mut self, v: f64) {
        self.task_clock = ::std::option::Option::Some(v);
    }

    pub fn get_task_clock<'a>(&self) -> f64 {
        self.task_clock.unwrap_or(0.)
    }

    // optional uint64 page_faults = 15;

    pub fn clear_page_faults(&mut self) {
        self.page_faults = ::std::option::Option::None;
    }

    pub fn has_page_faults(&self) -> bool {
        self.page_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_faults(&mut self, v: u64) {
        self.page_faults = ::std::option::Option::Some(v);
    }

    pub fn get_page_faults<'a>(&self) -> u64 {
        self.page_faults.unwrap_or(0)
    }

    // optional uint64 minor_faults = 16;

    pub fn clear_minor_faults(&mut self) {
        self.minor_faults = ::std::option::Option::None;
    }

    pub fn has_minor_faults(&self) -> bool {
        self.minor_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor_faults(&mut self, v: u64) {
        self.minor_faults = ::std::option::Option::Some(v);
    }

    pub fn get_minor_faults<'a>(&self) -> u64 {
        self.minor_faults.unwrap_or(0)
    }

    // optional uint64 major_faults = 17;

    pub fn clear_major_faults(&mut self) {
        self.major_faults = ::std::option::Option::None;
    }

    pub fn has_major_faults(&self) -> bool {
        self.major_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major_faults(&mut self, v: u64) {
        self.major_faults = ::std::option::Option::Some(v);
    }

    pub fn get_major_faults<'a>(&self) -> u64 {
        self.major_faults.unwrap_or(0)
    }

    // optional uint64 context_switches = 18;

    pub fn clear_context_switches(&mut self) {
        self.context_switches = ::std::option::Option::None;
    }

    pub fn has_context_switches(&self) -> bool {
        self.context_switches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_switches(&mut self, v: u64) {
        self.context_switches = ::std::option::Option::Some(v);
    }

    pub fn get_context_switches<'a>(&self) -> u64 {
        self.context_switches.unwrap_or(0)
    }

    // optional uint64 cpu_migrations = 19;

    pub fn clear_cpu_migrations(&mut self) {
        self.cpu_migrations = ::std::option::Option::None;
    }

    pub fn has_cpu_migrations(&self) -> bool {
        self.cpu_migrations.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cpu_migrations(&mut self, v: u64) {
        self.cpu_migrations = ::std::option::Option::Some(v);
    }

    pub fn get_cpu_migrations<'a>(&self) -> u64 {
        self.cpu_migrations.unwrap_or(0)
    }

    // optional uint64 alignment_faults = 20;

    pub fn clear_alignment_faults(&mut self) {
        self.alignment_faults = ::std::option::Option::None;
    }

    pub fn has_alignment_faults(&self) -> bool {
        self.alignment_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alignment_faults(&mut self, v: u64) {
        self.alignment_faults = ::std::option::Option::Some(v);
    }

    pub fn get_alignment_faults<'a>(&self) -> u64 {
        self.alignment_faults.unwrap_or(0)
    }

    // optional uint64 emulation_faults = 21;

    pub fn clear_emulation_faults(&mut self) {
        self.emulation_faults = ::std::option::Option::None;
    }

    pub fn has_emulation_faults(&self) -> bool {
        self.emulation_faults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emulation_faults(&mut self, v: u64) {
        self.emulation_faults = ::std::option::Option::Some(v);
    }

    pub fn get_emulation_faults<'a>(&self) -> u64 {
        self.emulation_faults.unwrap_or(0)
    }

    // optional uint64 l1_dcache_loads = 22;

    pub fn clear_l1_dcache_loads(&mut self) {
        self.l1_dcache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_loads(&self) -> bool {
        self.l1_dcache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_loads(&mut self, v: u64) {
        self.l1_dcache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_loads<'a>(&self) -> u64 {
        self.l1_dcache_loads.unwrap_or(0)
    }

    // optional uint64 l1_dcache_load_misses = 23;

    pub fn clear_l1_dcache_load_misses(&mut self) {
        self.l1_dcache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_load_misses(&self) -> bool {
        self.l1_dcache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_load_misses(&mut self, v: u64) {
        self.l1_dcache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_load_misses<'a>(&self) -> u64 {
        self.l1_dcache_load_misses.unwrap_or(0)
    }

    // optional uint64 l1_dcache_stores = 24;

    pub fn clear_l1_dcache_stores(&mut self) {
        self.l1_dcache_stores = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_stores(&self) -> bool {
        self.l1_dcache_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_stores(&mut self, v: u64) {
        self.l1_dcache_stores = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_stores<'a>(&self) -> u64 {
        self.l1_dcache_stores.unwrap_or(0)
    }

    // optional uint64 l1_dcache_store_misses = 25;

    pub fn clear_l1_dcache_store_misses(&mut self) {
        self.l1_dcache_store_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_store_misses(&self) -> bool {
        self.l1_dcache_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_store_misses(&mut self, v: u64) {
        self.l1_dcache_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_store_misses<'a>(&self) -> u64 {
        self.l1_dcache_store_misses.unwrap_or(0)
    }

    // optional uint64 l1_dcache_prefetches = 26;

    pub fn clear_l1_dcache_prefetches(&mut self) {
        self.l1_dcache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetches(&self) -> bool {
        self.l1_dcache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetches(&mut self, v: u64) {
        self.l1_dcache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetches<'a>(&self) -> u64 {
        self.l1_dcache_prefetches.unwrap_or(0)
    }

    // optional uint64 l1_dcache_prefetch_misses = 27;

    pub fn clear_l1_dcache_prefetch_misses(&mut self) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_dcache_prefetch_misses(&self) -> bool {
        self.l1_dcache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_dcache_prefetch_misses(&mut self, v: u64) {
        self.l1_dcache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_dcache_prefetch_misses<'a>(&self) -> u64 {
        self.l1_dcache_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 l1_icache_loads = 28;

    pub fn clear_l1_icache_loads(&mut self) {
        self.l1_icache_loads = ::std::option::Option::None;
    }

    pub fn has_l1_icache_loads(&self) -> bool {
        self.l1_icache_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_loads(&mut self, v: u64) {
        self.l1_icache_loads = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_loads<'a>(&self) -> u64 {
        self.l1_icache_loads.unwrap_or(0)
    }

    // optional uint64 l1_icache_load_misses = 29;

    pub fn clear_l1_icache_load_misses(&mut self) {
        self.l1_icache_load_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_load_misses(&self) -> bool {
        self.l1_icache_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_load_misses(&mut self, v: u64) {
        self.l1_icache_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_load_misses<'a>(&self) -> u64 {
        self.l1_icache_load_misses.unwrap_or(0)
    }

    // optional uint64 l1_icache_prefetches = 30;

    pub fn clear_l1_icache_prefetches(&mut self) {
        self.l1_icache_prefetches = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetches(&self) -> bool {
        self.l1_icache_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetches(&mut self, v: u64) {
        self.l1_icache_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetches<'a>(&self) -> u64 {
        self.l1_icache_prefetches.unwrap_or(0)
    }

    // optional uint64 l1_icache_prefetch_misses = 31;

    pub fn clear_l1_icache_prefetch_misses(&mut self) {
        self.l1_icache_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_l1_icache_prefetch_misses(&self) -> bool {
        self.l1_icache_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_l1_icache_prefetch_misses(&mut self, v: u64) {
        self.l1_icache_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_l1_icache_prefetch_misses<'a>(&self) -> u64 {
        self.l1_icache_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 llc_loads = 32;

    pub fn clear_llc_loads(&mut self) {
        self.llc_loads = ::std::option::Option::None;
    }

    pub fn has_llc_loads(&self) -> bool {
        self.llc_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_loads(&mut self, v: u64) {
        self.llc_loads = ::std::option::Option::Some(v);
    }

    pub fn get_llc_loads<'a>(&self) -> u64 {
        self.llc_loads.unwrap_or(0)
    }

    // optional uint64 llc_load_misses = 33;

    pub fn clear_llc_load_misses(&mut self) {
        self.llc_load_misses = ::std::option::Option::None;
    }

    pub fn has_llc_load_misses(&self) -> bool {
        self.llc_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_load_misses(&mut self, v: u64) {
        self.llc_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_load_misses<'a>(&self) -> u64 {
        self.llc_load_misses.unwrap_or(0)
    }

    // optional uint64 llc_stores = 34;

    pub fn clear_llc_stores(&mut self) {
        self.llc_stores = ::std::option::Option::None;
    }

    pub fn has_llc_stores(&self) -> bool {
        self.llc_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_stores(&mut self, v: u64) {
        self.llc_stores = ::std::option::Option::Some(v);
    }

    pub fn get_llc_stores<'a>(&self) -> u64 {
        self.llc_stores.unwrap_or(0)
    }

    // optional uint64 llc_store_misses = 35;

    pub fn clear_llc_store_misses(&mut self) {
        self.llc_store_misses = ::std::option::Option::None;
    }

    pub fn has_llc_store_misses(&self) -> bool {
        self.llc_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_store_misses(&mut self, v: u64) {
        self.llc_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_store_misses<'a>(&self) -> u64 {
        self.llc_store_misses.unwrap_or(0)
    }

    // optional uint64 llc_prefetches = 36;

    pub fn clear_llc_prefetches(&mut self) {
        self.llc_prefetches = ::std::option::Option::None;
    }

    pub fn has_llc_prefetches(&self) -> bool {
        self.llc_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetches(&mut self, v: u64) {
        self.llc_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetches<'a>(&self) -> u64 {
        self.llc_prefetches.unwrap_or(0)
    }

    // optional uint64 llc_prefetch_misses = 37;

    pub fn clear_llc_prefetch_misses(&mut self) {
        self.llc_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_llc_prefetch_misses(&self) -> bool {
        self.llc_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_llc_prefetch_misses(&mut self, v: u64) {
        self.llc_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_llc_prefetch_misses<'a>(&self) -> u64 {
        self.llc_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_loads = 38;

    pub fn clear_dtlb_loads(&mut self) {
        self.dtlb_loads = ::std::option::Option::None;
    }

    pub fn has_dtlb_loads(&self) -> bool {
        self.dtlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_loads(&mut self, v: u64) {
        self.dtlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_loads<'a>(&self) -> u64 {
        self.dtlb_loads.unwrap_or(0)
    }

    // optional uint64 dtlb_load_misses = 39;

    pub fn clear_dtlb_load_misses(&mut self) {
        self.dtlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_load_misses(&self) -> bool {
        self.dtlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_load_misses(&mut self, v: u64) {
        self.dtlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_load_misses<'a>(&self) -> u64 {
        self.dtlb_load_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_stores = 40;

    pub fn clear_dtlb_stores(&mut self) {
        self.dtlb_stores = ::std::option::Option::None;
    }

    pub fn has_dtlb_stores(&self) -> bool {
        self.dtlb_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_stores(&mut self, v: u64) {
        self.dtlb_stores = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_stores<'a>(&self) -> u64 {
        self.dtlb_stores.unwrap_or(0)
    }

    // optional uint64 dtlb_store_misses = 41;

    pub fn clear_dtlb_store_misses(&mut self) {
        self.dtlb_store_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_store_misses(&self) -> bool {
        self.dtlb_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_store_misses(&mut self, v: u64) {
        self.dtlb_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_store_misses<'a>(&self) -> u64 {
        self.dtlb_store_misses.unwrap_or(0)
    }

    // optional uint64 dtlb_prefetches = 42;

    pub fn clear_dtlb_prefetches(&mut self) {
        self.dtlb_prefetches = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetches(&self) -> bool {
        self.dtlb_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetches(&mut self, v: u64) {
        self.dtlb_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetches<'a>(&self) -> u64 {
        self.dtlb_prefetches.unwrap_or(0)
    }

    // optional uint64 dtlb_prefetch_misses = 43;

    pub fn clear_dtlb_prefetch_misses(&mut self) {
        self.dtlb_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_dtlb_prefetch_misses(&self) -> bool {
        self.dtlb_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dtlb_prefetch_misses(&mut self, v: u64) {
        self.dtlb_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_dtlb_prefetch_misses<'a>(&self) -> u64 {
        self.dtlb_prefetch_misses.unwrap_or(0)
    }

    // optional uint64 itlb_loads = 44;

    pub fn clear_itlb_loads(&mut self) {
        self.itlb_loads = ::std::option::Option::None;
    }

    pub fn has_itlb_loads(&self) -> bool {
        self.itlb_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_loads(&mut self, v: u64) {
        self.itlb_loads = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_loads<'a>(&self) -> u64 {
        self.itlb_loads.unwrap_or(0)
    }

    // optional uint64 itlb_load_misses = 45;

    pub fn clear_itlb_load_misses(&mut self) {
        self.itlb_load_misses = ::std::option::Option::None;
    }

    pub fn has_itlb_load_misses(&self) -> bool {
        self.itlb_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itlb_load_misses(&mut self, v: u64) {
        self.itlb_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_itlb_load_misses<'a>(&self) -> u64 {
        self.itlb_load_misses.unwrap_or(0)
    }

    // optional uint64 branch_loads = 46;

    pub fn clear_branch_loads(&mut self) {
        self.branch_loads = ::std::option::Option::None;
    }

    pub fn has_branch_loads(&self) -> bool {
        self.branch_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_loads(&mut self, v: u64) {
        self.branch_loads = ::std::option::Option::Some(v);
    }

    pub fn get_branch_loads<'a>(&self) -> u64 {
        self.branch_loads.unwrap_or(0)
    }

    // optional uint64 branch_load_misses = 47;

    pub fn clear_branch_load_misses(&mut self) {
        self.branch_load_misses = ::std::option::Option::None;
    }

    pub fn has_branch_load_misses(&self) -> bool {
        self.branch_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_branch_load_misses(&mut self, v: u64) {
        self.branch_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_branch_load_misses<'a>(&self) -> u64 {
        self.branch_load_misses.unwrap_or(0)
    }

    // optional uint64 node_loads = 48;

    pub fn clear_node_loads(&mut self) {
        self.node_loads = ::std::option::Option::None;
    }

    pub fn has_node_loads(&self) -> bool {
        self.node_loads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_loads(&mut self, v: u64) {
        self.node_loads = ::std::option::Option::Some(v);
    }

    pub fn get_node_loads<'a>(&self) -> u64 {
        self.node_loads.unwrap_or(0)
    }

    // optional uint64 node_load_misses = 49;

    pub fn clear_node_load_misses(&mut self) {
        self.node_load_misses = ::std::option::Option::None;
    }

    pub fn has_node_load_misses(&self) -> bool {
        self.node_load_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_load_misses(&mut self, v: u64) {
        self.node_load_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_load_misses<'a>(&self) -> u64 {
        self.node_load_misses.unwrap_or(0)
    }

    // optional uint64 node_stores = 50;

    pub fn clear_node_stores(&mut self) {
        self.node_stores = ::std::option::Option::None;
    }

    pub fn has_node_stores(&self) -> bool {
        self.node_stores.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_stores(&mut self, v: u64) {
        self.node_stores = ::std::option::Option::Some(v);
    }

    pub fn get_node_stores<'a>(&self) -> u64 {
        self.node_stores.unwrap_or(0)
    }

    // optional uint64 node_store_misses = 51;

    pub fn clear_node_store_misses(&mut self) {
        self.node_store_misses = ::std::option::Option::None;
    }

    pub fn has_node_store_misses(&self) -> bool {
        self.node_store_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_store_misses(&mut self, v: u64) {
        self.node_store_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_store_misses<'a>(&self) -> u64 {
        self.node_store_misses.unwrap_or(0)
    }

    // optional uint64 node_prefetches = 52;

    pub fn clear_node_prefetches(&mut self) {
        self.node_prefetches = ::std::option::Option::None;
    }

    pub fn has_node_prefetches(&self) -> bool {
        self.node_prefetches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetches(&mut self, v: u64) {
        self.node_prefetches = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetches<'a>(&self) -> u64 {
        self.node_prefetches.unwrap_or(0)
    }

    // optional uint64 node_prefetch_misses = 53;

    pub fn clear_node_prefetch_misses(&mut self) {
        self.node_prefetch_misses = ::std::option::Option::None;
    }

    pub fn has_node_prefetch_misses(&self) -> bool {
        self.node_prefetch_misses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_prefetch_misses(&mut self, v: u64) {
        self.node_prefetch_misses = ::std::option::Option::Some(v);
    }

    pub fn get_node_prefetch_misses<'a>(&self) -> u64 {
        self.node_prefetch_misses.unwrap_or(0)
    }
}

impl ::protobuf::Message for PerfStatistics {
    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        };
        if self.duration.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.duration = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cycles = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.stalled_cycles_frontend = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.stalled_cycles_backend = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.instructions = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cache_references = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cache_misses = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branches = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_misses = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bus_cycles = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.ref_cycles = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.cpu_clock = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.task_clock = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.page_faults = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.minor_faults = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.major_faults = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.context_switches = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.cpu_migrations = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.alignment_faults = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.emulation_faults = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_loads = ::std::option::Option::Some(tmp);
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_load_misses = ::std::option::Option::Some(tmp);
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_stores = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_store_misses = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_prefetches = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_dcache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_loads = ::std::option::Option::Some(tmp);
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_load_misses = ::std::option::Option::Some(tmp);
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_prefetches = ::std::option::Option::Some(tmp);
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.l1_icache_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_loads = ::std::option::Option::Some(tmp);
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_load_misses = ::std::option::Option::Some(tmp);
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_stores = ::std::option::Option::Some(tmp);
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_store_misses = ::std::option::Option::Some(tmp);
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_prefetches = ::std::option::Option::Some(tmp);
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.llc_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_loads = ::std::option::Option::Some(tmp);
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_load_misses = ::std::option::Option::Some(tmp);
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_stores = ::std::option::Option::Some(tmp);
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_store_misses = ::std::option::Option::Some(tmp);
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_prefetches = ::std::option::Option::Some(tmp);
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dtlb_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.itlb_loads = ::std::option::Option::Some(tmp);
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.itlb_load_misses = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_loads = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.branch_load_misses = ::std::option::Option::Some(tmp);
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_loads = ::std::option::Option::Some(tmp);
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_load_misses = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_stores = ::std::option::Option::Some(tmp);
                },
                51 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_store_misses = ::std::option::Option::Some(tmp);
                },
                52 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_prefetches = ::std::option::Option::Some(tmp);
                },
                53 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.node_prefetch_misses = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.timestamp.is_some() {
            my_size += 9;
        };
        if self.duration.is_some() {
            my_size += 9;
        };
        for value in self.cycles.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stalled_cycles_frontend.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stalled_cycles_backend.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.instructions.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cache_references.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cache_misses.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branches.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_misses.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bus_cycles.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ref_cycles.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.cpu_clock.is_some() {
            my_size += 9;
        };
        if self.task_clock.is_some() {
            my_size += 9;
        };
        for value in self.page_faults.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.minor_faults.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.major_faults.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.context_switches.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cpu_migrations.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.alignment_faults.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.emulation_faults.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_loads.iter() {
            my_size += ::protobuf::rt::value_size(22, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(23, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_stores.iter() {
            my_size += ::protobuf::rt::value_size(24, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_dcache_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_loads.iter() {
            my_size += ::protobuf::rt::value_size(28, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(29, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(30, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.l1_icache_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_loads.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(33, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_stores.iter() {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(35, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(36, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.llc_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(37, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_loads.iter() {
            my_size += ::protobuf::rt::value_size(38, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(39, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_stores.iter() {
            my_size += ::protobuf::rt::value_size(40, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(41, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(42, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dtlb_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(43, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.itlb_loads.iter() {
            my_size += ::protobuf::rt::value_size(44, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.itlb_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(45, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_loads.iter() {
            my_size += ::protobuf::rt::value_size(46, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.branch_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(47, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_loads.iter() {
            my_size += ::protobuf::rt::value_size(48, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_load_misses.iter() {
            my_size += ::protobuf::rt::value_size(49, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_stores.iter() {
            my_size += ::protobuf::rt::value_size(50, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_store_misses.iter() {
            my_size += ::protobuf::rt::value_size(51, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_prefetches.iter() {
            my_size += ::protobuf::rt::value_size(52, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.node_prefetch_misses.iter() {
            my_size += ::protobuf::rt::value_size(53, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timestamp {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.duration {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.cycles {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.stalled_cycles_frontend {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.stalled_cycles_backend {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.instructions {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.cache_references {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.cache_misses {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.branches {
            try!(os.write_uint64(9, v));
        };
        if let Some(v) = self.branch_misses {
            try!(os.write_uint64(10, v));
        };
        if let Some(v) = self.bus_cycles {
            try!(os.write_uint64(11, v));
        };
        if let Some(v) = self.ref_cycles {
            try!(os.write_uint64(12, v));
        };
        if let Some(v) = self.cpu_clock {
            try!(os.write_double(13, v));
        };
        if let Some(v) = self.task_clock {
            try!(os.write_double(14, v));
        };
        if let Some(v) = self.page_faults {
            try!(os.write_uint64(15, v));
        };
        if let Some(v) = self.minor_faults {
            try!(os.write_uint64(16, v));
        };
        if let Some(v) = self.major_faults {
            try!(os.write_uint64(17, v));
        };
        if let Some(v) = self.context_switches {
            try!(os.write_uint64(18, v));
        };
        if let Some(v) = self.cpu_migrations {
            try!(os.write_uint64(19, v));
        };
        if let Some(v) = self.alignment_faults {
            try!(os.write_uint64(20, v));
        };
        if let Some(v) = self.emulation_faults {
            try!(os.write_uint64(21, v));
        };
        if let Some(v) = self.l1_dcache_loads {
            try!(os.write_uint64(22, v));
        };
        if let Some(v) = self.l1_dcache_load_misses {
            try!(os.write_uint64(23, v));
        };
        if let Some(v) = self.l1_dcache_stores {
            try!(os.write_uint64(24, v));
        };
        if let Some(v) = self.l1_dcache_store_misses {
            try!(os.write_uint64(25, v));
        };
        if let Some(v) = self.l1_dcache_prefetches {
            try!(os.write_uint64(26, v));
        };
        if let Some(v) = self.l1_dcache_prefetch_misses {
            try!(os.write_uint64(27, v));
        };
        if let Some(v) = self.l1_icache_loads {
            try!(os.write_uint64(28, v));
        };
        if let Some(v) = self.l1_icache_load_misses {
            try!(os.write_uint64(29, v));
        };
        if let Some(v) = self.l1_icache_prefetches {
            try!(os.write_uint64(30, v));
        };
        if let Some(v) = self.l1_icache_prefetch_misses {
            try!(os.write_uint64(31, v));
        };
        if let Some(v) = self.llc_loads {
            try!(os.write_uint64(32, v));
        };
        if let Some(v) = self.llc_load_misses {
            try!(os.write_uint64(33, v));
        };
        if let Some(v) = self.llc_stores {
            try!(os.write_uint64(34, v));
        };
        if let Some(v) = self.llc_store_misses {
            try!(os.write_uint64(35, v));
        };
        if let Some(v) = self.llc_prefetches {
            try!(os.write_uint64(36, v));
        };
        if let Some(v) = self.llc_prefetch_misses {
            try!(os.write_uint64(37, v));
        };
        if let Some(v) = self.dtlb_loads {
            try!(os.write_uint64(38, v));
        };
        if let Some(v) = self.dtlb_load_misses {
            try!(os.write_uint64(39, v));
        };
        if let Some(v) = self.dtlb_stores {
            try!(os.write_uint64(40, v));
        };
        if let Some(v) = self.dtlb_store_misses {
            try!(os.write_uint64(41, v));
        };
        if let Some(v) = self.dtlb_prefetches {
            try!(os.write_uint64(42, v));
        };
        if let Some(v) = self.dtlb_prefetch_misses {
            try!(os.write_uint64(43, v));
        };
        if let Some(v) = self.itlb_loads {
            try!(os.write_uint64(44, v));
        };
        if let Some(v) = self.itlb_load_misses {
            try!(os.write_uint64(45, v));
        };
        if let Some(v) = self.branch_loads {
            try!(os.write_uint64(46, v));
        };
        if let Some(v) = self.branch_load_misses {
            try!(os.write_uint64(47, v));
        };
        if let Some(v) = self.node_loads {
            try!(os.write_uint64(48, v));
        };
        if let Some(v) = self.node_load_misses {
            try!(os.write_uint64(49, v));
        };
        if let Some(v) = self.node_stores {
            try!(os.write_uint64(50, v));
        };
        if let Some(v) = self.node_store_misses {
            try!(os.write_uint64(51, v));
        };
        if let Some(v) = self.node_prefetches {
            try!(os.write_uint64(52, v));
        };
        if let Some(v) = self.node_prefetch_misses {
            try!(os.write_uint64(53, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<PerfStatistics>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for PerfStatistics {
    fn new() -> PerfStatistics {
        PerfStatistics::new()
    }

    fn descriptor_static(_: ::std::option::Option<PerfStatistics>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    PerfStatistics::has_timestamp,
                    PerfStatistics::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "duration",
                    PerfStatistics::has_duration,
                    PerfStatistics::get_duration,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cycles",
                    PerfStatistics::has_cycles,
                    PerfStatistics::get_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "stalled_cycles_frontend",
                    PerfStatistics::has_stalled_cycles_frontend,
                    PerfStatistics::get_stalled_cycles_frontend,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "stalled_cycles_backend",
                    PerfStatistics::has_stalled_cycles_backend,
                    PerfStatistics::get_stalled_cycles_backend,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "instructions",
                    PerfStatistics::has_instructions,
                    PerfStatistics::get_instructions,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cache_references",
                    PerfStatistics::has_cache_references,
                    PerfStatistics::get_cache_references,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cache_misses",
                    PerfStatistics::has_cache_misses,
                    PerfStatistics::get_cache_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branches",
                    PerfStatistics::has_branches,
                    PerfStatistics::get_branches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_misses",
                    PerfStatistics::has_branch_misses,
                    PerfStatistics::get_branch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bus_cycles",
                    PerfStatistics::has_bus_cycles,
                    PerfStatistics::get_bus_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ref_cycles",
                    PerfStatistics::has_ref_cycles,
                    PerfStatistics::get_ref_cycles,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "cpu_clock",
                    PerfStatistics::has_cpu_clock,
                    PerfStatistics::get_cpu_clock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "task_clock",
                    PerfStatistics::has_task_clock,
                    PerfStatistics::get_task_clock,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "page_faults",
                    PerfStatistics::has_page_faults,
                    PerfStatistics::get_page_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "minor_faults",
                    PerfStatistics::has_minor_faults,
                    PerfStatistics::get_minor_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "major_faults",
                    PerfStatistics::has_major_faults,
                    PerfStatistics::get_major_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "context_switches",
                    PerfStatistics::has_context_switches,
                    PerfStatistics::get_context_switches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "cpu_migrations",
                    PerfStatistics::has_cpu_migrations,
                    PerfStatistics::get_cpu_migrations,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "alignment_faults",
                    PerfStatistics::has_alignment_faults,
                    PerfStatistics::get_alignment_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "emulation_faults",
                    PerfStatistics::has_emulation_faults,
                    PerfStatistics::get_emulation_faults,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_loads",
                    PerfStatistics::has_l1_dcache_loads,
                    PerfStatistics::get_l1_dcache_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_load_misses",
                    PerfStatistics::has_l1_dcache_load_misses,
                    PerfStatistics::get_l1_dcache_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_stores",
                    PerfStatistics::has_l1_dcache_stores,
                    PerfStatistics::get_l1_dcache_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_store_misses",
                    PerfStatistics::has_l1_dcache_store_misses,
                    PerfStatistics::get_l1_dcache_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_prefetches",
                    PerfStatistics::has_l1_dcache_prefetches,
                    PerfStatistics::get_l1_dcache_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_dcache_prefetch_misses",
                    PerfStatistics::has_l1_dcache_prefetch_misses,
                    PerfStatistics::get_l1_dcache_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_loads",
                    PerfStatistics::has_l1_icache_loads,
                    PerfStatistics::get_l1_icache_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_load_misses",
                    PerfStatistics::has_l1_icache_load_misses,
                    PerfStatistics::get_l1_icache_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_prefetches",
                    PerfStatistics::has_l1_icache_prefetches,
                    PerfStatistics::get_l1_icache_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "l1_icache_prefetch_misses",
                    PerfStatistics::has_l1_icache_prefetch_misses,
                    PerfStatistics::get_l1_icache_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_loads",
                    PerfStatistics::has_llc_loads,
                    PerfStatistics::get_llc_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_load_misses",
                    PerfStatistics::has_llc_load_misses,
                    PerfStatistics::get_llc_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_stores",
                    PerfStatistics::has_llc_stores,
                    PerfStatistics::get_llc_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_store_misses",
                    PerfStatistics::has_llc_store_misses,
                    PerfStatistics::get_llc_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_prefetches",
                    PerfStatistics::has_llc_prefetches,
                    PerfStatistics::get_llc_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "llc_prefetch_misses",
                    PerfStatistics::has_llc_prefetch_misses,
                    PerfStatistics::get_llc_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_loads",
                    PerfStatistics::has_dtlb_loads,
                    PerfStatistics::get_dtlb_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_load_misses",
                    PerfStatistics::has_dtlb_load_misses,
                    PerfStatistics::get_dtlb_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_stores",
                    PerfStatistics::has_dtlb_stores,
                    PerfStatistics::get_dtlb_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_store_misses",
                    PerfStatistics::has_dtlb_store_misses,
                    PerfStatistics::get_dtlb_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_prefetches",
                    PerfStatistics::has_dtlb_prefetches,
                    PerfStatistics::get_dtlb_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dtlb_prefetch_misses",
                    PerfStatistics::has_dtlb_prefetch_misses,
                    PerfStatistics::get_dtlb_prefetch_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "itlb_loads",
                    PerfStatistics::has_itlb_loads,
                    PerfStatistics::get_itlb_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "itlb_load_misses",
                    PerfStatistics::has_itlb_load_misses,
                    PerfStatistics::get_itlb_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_loads",
                    PerfStatistics::has_branch_loads,
                    PerfStatistics::get_branch_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "branch_load_misses",
                    PerfStatistics::has_branch_load_misses,
                    PerfStatistics::get_branch_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_loads",
                    PerfStatistics::has_node_loads,
                    PerfStatistics::get_node_loads,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_load_misses",
                    PerfStatistics::has_node_load_misses,
                    PerfStatistics::get_node_load_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_stores",
                    PerfStatistics::has_node_stores,
                    PerfStatistics::get_node_stores,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_store_misses",
                    PerfStatistics::has_node_store_misses,
                    PerfStatistics::get_node_store_misses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_prefetches",
                    PerfStatistics::has_node_prefetches,
                    PerfStatistics::get_node_prefetches,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "node_prefetch_misses",
                    PerfStatistics::has_node_prefetch_misses,
                    PerfStatistics::get_node_prefetch_misses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PerfStatistics>(
                    "PerfStatistics",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for PerfStatistics {
    fn clear(&mut self) {
        self.clear_timestamp();
        self.clear_duration();
        self.clear_cycles();
        self.clear_stalled_cycles_frontend();
        self.clear_stalled_cycles_backend();
        self.clear_instructions();
        self.clear_cache_references();
        self.clear_cache_misses();
        self.clear_branches();
        self.clear_branch_misses();
        self.clear_bus_cycles();
        self.clear_ref_cycles();
        self.clear_cpu_clock();
        self.clear_task_clock();
        self.clear_page_faults();
        self.clear_minor_faults();
        self.clear_major_faults();
        self.clear_context_switches();
        self.clear_cpu_migrations();
        self.clear_alignment_faults();
        self.clear_emulation_faults();
        self.clear_l1_dcache_loads();
        self.clear_l1_dcache_load_misses();
        self.clear_l1_dcache_stores();
        self.clear_l1_dcache_store_misses();
        self.clear_l1_dcache_prefetches();
        self.clear_l1_dcache_prefetch_misses();
        self.clear_l1_icache_loads();
        self.clear_l1_icache_load_misses();
        self.clear_l1_icache_prefetches();
        self.clear_l1_icache_prefetch_misses();
        self.clear_llc_loads();
        self.clear_llc_load_misses();
        self.clear_llc_stores();
        self.clear_llc_store_misses();
        self.clear_llc_prefetches();
        self.clear_llc_prefetch_misses();
        self.clear_dtlb_loads();
        self.clear_dtlb_load_misses();
        self.clear_dtlb_stores();
        self.clear_dtlb_store_misses();
        self.clear_dtlb_prefetches();
        self.clear_dtlb_prefetch_misses();
        self.clear_itlb_loads();
        self.clear_itlb_load_misses();
        self.clear_branch_loads();
        self.clear_branch_load_misses();
        self.clear_node_loads();
        self.clear_node_load_misses();
        self.clear_node_stores();
        self.clear_node_store_misses();
        self.clear_node_prefetches();
        self.clear_node_prefetch_misses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for PerfStatistics {
    fn eq(&self, other: &PerfStatistics) -> bool {
        self.timestamp == other.timestamp &&
        self.duration == other.duration &&
        self.cycles == other.cycles &&
        self.stalled_cycles_frontend == other.stalled_cycles_frontend &&
        self.stalled_cycles_backend == other.stalled_cycles_backend &&
        self.instructions == other.instructions &&
        self.cache_references == other.cache_references &&
        self.cache_misses == other.cache_misses &&
        self.branches == other.branches &&
        self.branch_misses == other.branch_misses &&
        self.bus_cycles == other.bus_cycles &&
        self.ref_cycles == other.ref_cycles &&
        self.cpu_clock == other.cpu_clock &&
        self.task_clock == other.task_clock &&
        self.page_faults == other.page_faults &&
        self.minor_faults == other.minor_faults &&
        self.major_faults == other.major_faults &&
        self.context_switches == other.context_switches &&
        self.cpu_migrations == other.cpu_migrations &&
        self.alignment_faults == other.alignment_faults &&
        self.emulation_faults == other.emulation_faults &&
        self.l1_dcache_loads == other.l1_dcache_loads &&
        self.l1_dcache_load_misses == other.l1_dcache_load_misses &&
        self.l1_dcache_stores == other.l1_dcache_stores &&
        self.l1_dcache_store_misses == other.l1_dcache_store_misses &&
        self.l1_dcache_prefetches == other.l1_dcache_prefetches &&
        self.l1_dcache_prefetch_misses == other.l1_dcache_prefetch_misses &&
        self.l1_icache_loads == other.l1_icache_loads &&
        self.l1_icache_load_misses == other.l1_icache_load_misses &&
        self.l1_icache_prefetches == other.l1_icache_prefetches &&
        self.l1_icache_prefetch_misses == other.l1_icache_prefetch_misses &&
        self.llc_loads == other.llc_loads &&
        self.llc_load_misses == other.llc_load_misses &&
        self.llc_stores == other.llc_stores &&
        self.llc_store_misses == other.llc_store_misses &&
        self.llc_prefetches == other.llc_prefetches &&
        self.llc_prefetch_misses == other.llc_prefetch_misses &&
        self.dtlb_loads == other.dtlb_loads &&
        self.dtlb_load_misses == other.dtlb_load_misses &&
        self.dtlb_stores == other.dtlb_stores &&
        self.dtlb_store_misses == other.dtlb_store_misses &&
        self.dtlb_prefetches == other.dtlb_prefetches &&
        self.dtlb_prefetch_misses == other.dtlb_prefetch_misses &&
        self.itlb_loads == other.itlb_loads &&
        self.itlb_load_misses == other.itlb_load_misses &&
        self.branch_loads == other.branch_loads &&
        self.branch_load_misses == other.branch_load_misses &&
        self.node_loads == other.node_loads &&
        self.node_load_misses == other.node_load_misses &&
        self.node_stores == other.node_stores &&
        self.node_store_misses == other.node_store_misses &&
        self.node_prefetches == other.node_prefetches &&
        self.node_prefetch_misses == other.node_prefetch_misses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for PerfStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Request {
    // message fields
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Request {}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Request {
        static mut instance: ::protobuf::lazy::Lazy<Request> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Request,
        };
        unsafe {
            instance.get(|| {
                Request {
                    agent_id: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.AgentID agent_id = 1;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // repeated .mesos.v1.Resource resources = 2;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Request>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Request {
    fn new() -> Request {
        Request::new()
    }

    fn descriptor_static(_: ::std::option::Option<Request>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Request::has_agent_id,
                    Request::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Request::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Request>(
                    "Request",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.clear_agent_id();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Request {
    fn eq(&self, other: &Request) -> bool {
        self.agent_id == other.agent_id &&
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer {
    // message fields
    id: ::protobuf::SingularPtrField<OfferID>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    url: ::protobuf::SingularPtrField<URL>,
    resources: ::protobuf::RepeatedField<Resource>,
    attributes: ::protobuf::RepeatedField<Attribute>,
    executor_ids: ::protobuf::RepeatedField<ExecutorID>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer {}

impl Offer {
    pub fn new() -> Offer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer {
        static mut instance: ::protobuf::lazy::Lazy<Offer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer,
        };
        unsafe {
            instance.get(|| {
                Offer {
                    id: ::protobuf::SingularPtrField::none(),
                    framework_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    hostname: ::protobuf::SingularField::none(),
                    url: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    attributes: ::protobuf::RepeatedField::new(),
                    executor_ids: ::protobuf::RepeatedField::new(),
                    unavailability: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.OfferID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OfferID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut OfferID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OfferID {
        self.id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a OfferID {
        self.id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }

    // required .mesos.v1.FrameworkID framework_id = 2;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // required .mesos.v1.AgentID agent_id = 3;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // required string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.URL url = 8;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: URL) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url<'a>(&'a mut self) -> &'a mut URL {
        if self.url.is_none() {
            self.url.set_default();
        };
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> URL {
        self.url.take().unwrap_or_else(|| URL::new())
    }

    pub fn get_url<'a>(&'a self) -> &'a URL {
        self.url.as_ref().unwrap_or_else(|| URL::default_instance())
    }

    // repeated .mesos.v1.Resource resources = 5;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // repeated .mesos.v1.Attribute attributes = 7;

    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::protobuf::RepeatedField<Attribute>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Attribute> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::protobuf::RepeatedField<Attribute> {
        ::std::mem::replace(&mut self.attributes, ::protobuf::RepeatedField::new())
    }

    pub fn get_attributes<'a>(&'a self) -> &'a [Attribute] {
        &self.attributes
    }

    // repeated .mesos.v1.ExecutorID executor_ids = 6;

    pub fn clear_executor_ids(&mut self) {
        self.executor_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_executor_ids(&mut self, v: ::protobuf::RepeatedField<ExecutorID>) {
        self.executor_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_executor_ids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ExecutorID> {
        &mut self.executor_ids
    }

    // Take field
    pub fn take_executor_ids(&mut self) -> ::protobuf::RepeatedField<ExecutorID> {
        ::std::mem::replace(&mut self.executor_ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_executor_ids<'a>(&'a self) -> &'a [ExecutorID] {
        &self.executor_ids
    }

    // optional .mesos.v1.Unavailability unavailability = 9;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability<'a>(&'a mut self) -> &'a mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        };
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability<'a>(&'a self) -> &'a Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }
}

impl ::protobuf::Message for Offer {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.framework_id.is_none() {
            return false;
        };
        if self.agent_id.is_none() {
            return false;
        };
        if self.hostname.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attributes));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.executor_ids));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.url.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.attributes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_ids.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unavailability.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.url.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.attributes.iter() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.executor_ids.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.unavailability.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer {
    fn new() -> Offer {
        Offer::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    Offer::has_id,
                    Offer::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    Offer::has_framework_id,
                    Offer::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    Offer::has_agent_id,
                    Offer::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    Offer::has_hostname,
                    Offer::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "url",
                    Offer::has_url,
                    Offer::get_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "attributes",
                    Offer::get_attributes,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "executor_ids",
                    Offer::get_executor_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "unavailability",
                    Offer::has_unavailability,
                    Offer::get_unavailability,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer>(
                    "Offer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_framework_id();
        self.clear_agent_id();
        self.clear_hostname();
        self.clear_url();
        self.clear_resources();
        self.clear_attributes();
        self.clear_executor_ids();
        self.clear_unavailability();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer {
    fn eq(&self, other: &Offer) -> bool {
        self.id == other.id &&
        self.framework_id == other.framework_id &&
        self.agent_id == other.agent_id &&
        self.hostname == other.hostname &&
        self.url == other.url &&
        self.resources == other.resources &&
        self.attributes == other.attributes &&
        self.executor_ids == other.executor_ids &&
        self.unavailability == other.unavailability &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation {
    // message fields
    field_type: ::std::option::Option<Offer_Operation_Type>,
    launch: ::protobuf::SingularPtrField<Offer_Operation_Launch>,
    reserve: ::protobuf::SingularPtrField<Offer_Operation_Reserve>,
    unreserve: ::protobuf::SingularPtrField<Offer_Operation_Unreserve>,
    create: ::protobuf::SingularPtrField<Offer_Operation_Create>,
    destroy: ::protobuf::SingularPtrField<Offer_Operation_Destroy>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation {}

impl Offer_Operation {
    pub fn new() -> Offer_Operation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation {
                    field_type: ::std::option::Option::None,
                    launch: ::protobuf::SingularPtrField::none(),
                    reserve: ::protobuf::SingularPtrField::none(),
                    unreserve: ::protobuf::SingularPtrField::none(),
                    create: ::protobuf::SingularPtrField::none(),
                    destroy: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.Offer.Operation.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Offer_Operation_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Offer_Operation_Type {
        self.field_type.unwrap_or(Offer_Operation_Type::LAUNCH)
    }

    // optional .mesos.v1.Offer.Operation.Launch launch = 2;

    pub fn clear_launch(&mut self) {
        self.launch.clear();
    }

    pub fn has_launch(&self) -> bool {
        self.launch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launch(&mut self, v: Offer_Operation_Launch) {
        self.launch = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_launch<'a>(&'a mut self) -> &'a mut Offer_Operation_Launch {
        if self.launch.is_none() {
            self.launch.set_default();
        };
        self.launch.as_mut().unwrap()
    }

    // Take field
    pub fn take_launch(&mut self) -> Offer_Operation_Launch {
        self.launch.take().unwrap_or_else(|| Offer_Operation_Launch::new())
    }

    pub fn get_launch<'a>(&'a self) -> &'a Offer_Operation_Launch {
        self.launch.as_ref().unwrap_or_else(|| Offer_Operation_Launch::default_instance())
    }

    // optional .mesos.v1.Offer.Operation.Reserve reserve = 3;

    pub fn clear_reserve(&mut self) {
        self.reserve.clear();
    }

    pub fn has_reserve(&self) -> bool {
        self.reserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reserve(&mut self, v: Offer_Operation_Reserve) {
        self.reserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reserve<'a>(&'a mut self) -> &'a mut Offer_Operation_Reserve {
        if self.reserve.is_none() {
            self.reserve.set_default();
        };
        self.reserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_reserve(&mut self) -> Offer_Operation_Reserve {
        self.reserve.take().unwrap_or_else(|| Offer_Operation_Reserve::new())
    }

    pub fn get_reserve<'a>(&'a self) -> &'a Offer_Operation_Reserve {
        self.reserve.as_ref().unwrap_or_else(|| Offer_Operation_Reserve::default_instance())
    }

    // optional .mesos.v1.Offer.Operation.Unreserve unreserve = 4;

    pub fn clear_unreserve(&mut self) {
        self.unreserve.clear();
    }

    pub fn has_unreserve(&self) -> bool {
        self.unreserve.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unreserve(&mut self, v: Offer_Operation_Unreserve) {
        self.unreserve = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unreserve<'a>(&'a mut self) -> &'a mut Offer_Operation_Unreserve {
        if self.unreserve.is_none() {
            self.unreserve.set_default();
        };
        self.unreserve.as_mut().unwrap()
    }

    // Take field
    pub fn take_unreserve(&mut self) -> Offer_Operation_Unreserve {
        self.unreserve.take().unwrap_or_else(|| Offer_Operation_Unreserve::new())
    }

    pub fn get_unreserve<'a>(&'a self) -> &'a Offer_Operation_Unreserve {
        self.unreserve.as_ref().unwrap_or_else(|| Offer_Operation_Unreserve::default_instance())
    }

    // optional .mesos.v1.Offer.Operation.Create create = 5;

    pub fn clear_create(&mut self) {
        self.create.clear();
    }

    pub fn has_create(&self) -> bool {
        self.create.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create(&mut self, v: Offer_Operation_Create) {
        self.create = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create<'a>(&'a mut self) -> &'a mut Offer_Operation_Create {
        if self.create.is_none() {
            self.create.set_default();
        };
        self.create.as_mut().unwrap()
    }

    // Take field
    pub fn take_create(&mut self) -> Offer_Operation_Create {
        self.create.take().unwrap_or_else(|| Offer_Operation_Create::new())
    }

    pub fn get_create<'a>(&'a self) -> &'a Offer_Operation_Create {
        self.create.as_ref().unwrap_or_else(|| Offer_Operation_Create::default_instance())
    }

    // optional .mesos.v1.Offer.Operation.Destroy destroy = 6;

    pub fn clear_destroy(&mut self) {
        self.destroy.clear();
    }

    pub fn has_destroy(&self) -> bool {
        self.destroy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destroy(&mut self, v: Offer_Operation_Destroy) {
        self.destroy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destroy<'a>(&'a mut self) -> &'a mut Offer_Operation_Destroy {
        if self.destroy.is_none() {
            self.destroy.set_default();
        };
        self.destroy.as_mut().unwrap()
    }

    // Take field
    pub fn take_destroy(&mut self) -> Offer_Operation_Destroy {
        self.destroy.take().unwrap_or_else(|| Offer_Operation_Destroy::new())
    }

    pub fn get_destroy<'a>(&'a self) -> &'a Offer_Operation_Destroy {
        self.destroy.as_ref().unwrap_or_else(|| Offer_Operation_Destroy::default_instance())
    }
}

impl ::protobuf::Message for Offer_Operation {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.launch));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reserve));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unreserve));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.create));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destroy));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.launch.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.reserve.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unreserve.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.create.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.destroy.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.launch.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.reserve.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.unreserve.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.create.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.destroy.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation {
    fn new() -> Offer_Operation {
        Offer_Operation::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Offer_Operation::has_field_type,
                    Offer_Operation::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "launch",
                    Offer_Operation::has_launch,
                    Offer_Operation::get_launch,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "reserve",
                    Offer_Operation::has_reserve,
                    Offer_Operation::get_reserve,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "unreserve",
                    Offer_Operation::has_unreserve,
                    Offer_Operation::get_unreserve,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "create",
                    Offer_Operation::has_create,
                    Offer_Operation::get_create,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "destroy",
                    Offer_Operation::has_destroy,
                    Offer_Operation::get_destroy,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation>(
                    "Offer_Operation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_launch();
        self.clear_reserve();
        self.clear_unreserve();
        self.clear_create();
        self.clear_destroy();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation {
    fn eq(&self, other: &Offer_Operation) -> bool {
        self.field_type == other.field_type &&
        self.launch == other.launch &&
        self.reserve == other.reserve &&
        self.unreserve == other.unreserve &&
        self.create == other.create &&
        self.destroy == other.destroy &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Launch {
    // message fields
    task_infos: ::protobuf::RepeatedField<TaskInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Launch {}

impl Offer_Operation_Launch {
    pub fn new() -> Offer_Operation_Launch {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Launch {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Launch> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Launch,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Launch {
                    task_infos: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.TaskInfo task_infos = 1;

    pub fn clear_task_infos(&mut self) {
        self.task_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_infos(&mut self, v: ::protobuf::RepeatedField<TaskInfo>) {
        self.task_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_task_infos<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<TaskInfo> {
        &mut self.task_infos
    }

    // Take field
    pub fn take_task_infos(&mut self) -> ::protobuf::RepeatedField<TaskInfo> {
        ::std::mem::replace(&mut self.task_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_task_infos<'a>(&'a self) -> &'a [TaskInfo] {
        &self.task_infos
    }
}

impl ::protobuf::Message for Offer_Operation_Launch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.task_infos));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_infos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.task_infos.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Launch>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Launch {
    fn new() -> Offer_Operation_Launch {
        Offer_Operation_Launch::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Launch>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "task_infos",
                    Offer_Operation_Launch::get_task_infos,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Launch>(
                    "Offer_Operation_Launch",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Launch {
    fn clear(&mut self) {
        self.clear_task_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Launch {
    fn eq(&self, other: &Offer_Operation_Launch) -> bool {
        self.task_infos == other.task_infos &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Launch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Reserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Reserve {}

impl Offer_Operation_Reserve {
    pub fn new() -> Offer_Operation_Reserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Reserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Reserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Reserve,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Reserve {
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Reserve {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.resources.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Reserve>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Reserve {
    fn new() -> Offer_Operation_Reserve {
        Offer_Operation_Reserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Reserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer_Operation_Reserve::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Reserve>(
                    "Offer_Operation_Reserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Reserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Reserve {
    fn eq(&self, other: &Offer_Operation_Reserve) -> bool {
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Reserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Unreserve {
    // message fields
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Unreserve {}

impl Offer_Operation_Unreserve {
    pub fn new() -> Offer_Operation_Unreserve {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Unreserve {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Unreserve> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Unreserve,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Unreserve {
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Resource resources = 1;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for Offer_Operation_Unreserve {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.resources.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Unreserve>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Unreserve {
    fn new() -> Offer_Operation_Unreserve {
        Offer_Operation_Unreserve::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Unreserve>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    Offer_Operation_Unreserve::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Unreserve>(
                    "Offer_Operation_Unreserve",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Unreserve {
    fn clear(&mut self) {
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Unreserve {
    fn eq(&self, other: &Offer_Operation_Unreserve) -> bool {
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Unreserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Create {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Create {}

impl Offer_Operation_Create {
    pub fn new() -> Offer_Operation_Create {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Create {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Create> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Create,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Create {
                    volumes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Resource] {
        &self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Create {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.volumes.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Create>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Create {
    fn new() -> Offer_Operation_Create {
        Offer_Operation_Create::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Create>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    Offer_Operation_Create::get_volumes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Create>(
                    "Offer_Operation_Create",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Create {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Create {
    fn eq(&self, other: &Offer_Operation_Create) -> bool {
        self.volumes == other.volumes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Create {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Offer_Operation_Destroy {
    // message fields
    volumes: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Offer_Operation_Destroy {}

impl Offer_Operation_Destroy {
    pub fn new() -> Offer_Operation_Destroy {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Offer_Operation_Destroy {
        static mut instance: ::protobuf::lazy::Lazy<Offer_Operation_Destroy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Offer_Operation_Destroy,
        };
        unsafe {
            instance.get(|| {
                Offer_Operation_Destroy {
                    volumes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Resource volumes = 1;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Resource] {
        &self.volumes
    }
}

impl ::protobuf::Message for Offer_Operation_Destroy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.volumes.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Offer_Operation_Destroy>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Offer_Operation_Destroy {
    fn new() -> Offer_Operation_Destroy {
        Offer_Operation_Destroy::new()
    }

    fn descriptor_static(_: ::std::option::Option<Offer_Operation_Destroy>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    Offer_Operation_Destroy::get_volumes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Offer_Operation_Destroy>(
                    "Offer_Operation_Destroy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Offer_Operation_Destroy {
    fn clear(&mut self) {
        self.clear_volumes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Offer_Operation_Destroy {
    fn eq(&self, other: &Offer_Operation_Destroy) -> bool {
        self.volumes == other.volumes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Offer_Operation_Destroy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Offer_Operation_Type {
    LAUNCH = 1,
    RESERVE = 2,
    UNRESERVE = 3,
    CREATE = 4,
    DESTROY = 5,
}

impl ::protobuf::ProtobufEnum for Offer_Operation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Offer_Operation_Type> {
        match value {
            1 => ::std::option::Option::Some(Offer_Operation_Type::LAUNCH),
            2 => ::std::option::Option::Some(Offer_Operation_Type::RESERVE),
            3 => ::std::option::Option::Some(Offer_Operation_Type::UNRESERVE),
            4 => ::std::option::Option::Some(Offer_Operation_Type::CREATE),
            5 => ::std::option::Option::Some(Offer_Operation_Type::DESTROY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Offer_Operation_Type] = &[
            Offer_Operation_Type::LAUNCH,
            Offer_Operation_Type::RESERVE,
            Offer_Operation_Type::UNRESERVE,
            Offer_Operation_Type::CREATE,
            Offer_Operation_Type::DESTROY,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Offer_Operation_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Offer_Operation_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Offer_Operation_Type {
}

#[derive(Clone,Default)]
pub struct InverseOffer {
    // message fields
    id: ::protobuf::SingularPtrField<OfferID>,
    url: ::protobuf::SingularPtrField<URL>,
    framework_id: ::protobuf::SingularPtrField<FrameworkID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    unavailability: ::protobuf::SingularPtrField<Unavailability>,
    resources: ::protobuf::RepeatedField<Resource>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for InverseOffer {}

impl InverseOffer {
    pub fn new() -> InverseOffer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static InverseOffer {
        static mut instance: ::protobuf::lazy::Lazy<InverseOffer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InverseOffer,
        };
        unsafe {
            instance.get(|| {
                InverseOffer {
                    id: ::protobuf::SingularPtrField::none(),
                    url: ::protobuf::SingularPtrField::none(),
                    framework_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    unavailability: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.OfferID id = 1;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: OfferID) {
        self.id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut OfferID {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> OfferID {
        self.id.take().unwrap_or_else(|| OfferID::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a OfferID {
        self.id.as_ref().unwrap_or_else(|| OfferID::default_instance())
    }

    // optional .mesos.v1.URL url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: URL) {
        self.url = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url<'a>(&'a mut self) -> &'a mut URL {
        if self.url.is_none() {
            self.url.set_default();
        };
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> URL {
        self.url.take().unwrap_or_else(|| URL::new())
    }

    pub fn get_url<'a>(&'a self) -> &'a URL {
        self.url.as_ref().unwrap_or_else(|| URL::default_instance())
    }

    // required .mesos.v1.FrameworkID framework_id = 3;

    pub fn clear_framework_id(&mut self) {
        self.framework_id.clear();
    }

    pub fn has_framework_id(&self) -> bool {
        self.framework_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framework_id(&mut self, v: FrameworkID) {
        self.framework_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_framework_id<'a>(&'a mut self) -> &'a mut FrameworkID {
        if self.framework_id.is_none() {
            self.framework_id.set_default();
        };
        self.framework_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_framework_id(&mut self) -> FrameworkID {
        self.framework_id.take().unwrap_or_else(|| FrameworkID::new())
    }

    pub fn get_framework_id<'a>(&'a self) -> &'a FrameworkID {
        self.framework_id.as_ref().unwrap_or_else(|| FrameworkID::default_instance())
    }

    // optional .mesos.v1.AgentID agent_id = 4;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // required .mesos.v1.Unavailability unavailability = 5;

    pub fn clear_unavailability(&mut self) {
        self.unavailability.clear();
    }

    pub fn has_unavailability(&self) -> bool {
        self.unavailability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unavailability(&mut self, v: Unavailability) {
        self.unavailability = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unavailability<'a>(&'a mut self) -> &'a mut Unavailability {
        if self.unavailability.is_none() {
            self.unavailability.set_default();
        };
        self.unavailability.as_mut().unwrap()
    }

    // Take field
    pub fn take_unavailability(&mut self) -> Unavailability {
        self.unavailability.take().unwrap_or_else(|| Unavailability::new())
    }

    pub fn get_unavailability<'a>(&'a self) -> &'a Unavailability {
        self.unavailability.as_ref().unwrap_or_else(|| Unavailability::default_instance())
    }

    // repeated .mesos.v1.Resource resources = 6;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }
}

impl ::protobuf::Message for InverseOffer {
    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        };
        if self.framework_id.is_none() {
            return false;
        };
        if self.unavailability.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.id));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.url));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.framework_id));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unavailability));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.url.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.framework_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unavailability.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.url.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.framework_id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.unavailability.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<InverseOffer>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for InverseOffer {
    fn new() -> InverseOffer {
        InverseOffer::new()
    }

    fn descriptor_static(_: ::std::option::Option<InverseOffer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "id",
                    InverseOffer::has_id,
                    InverseOffer::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "url",
                    InverseOffer::has_url,
                    InverseOffer::get_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "framework_id",
                    InverseOffer::has_framework_id,
                    InverseOffer::get_framework_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    InverseOffer::has_agent_id,
                    InverseOffer::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "unavailability",
                    InverseOffer::has_unavailability,
                    InverseOffer::get_unavailability,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    InverseOffer::get_resources,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InverseOffer>(
                    "InverseOffer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for InverseOffer {
    fn clear(&mut self) {
        self.clear_id();
        self.clear_url();
        self.clear_framework_id();
        self.clear_agent_id();
        self.clear_unavailability();
        self.clear_resources();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for InverseOffer {
    fn eq(&self, other: &InverseOffer) -> bool {
        self.id == other.id &&
        self.url == other.url &&
        self.framework_id == other.framework_id &&
        self.agent_id == other.agent_id &&
        self.unavailability == other.unavailability &&
        self.resources == other.resources &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for InverseOffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TaskInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    task_id: ::protobuf::SingularPtrField<TaskID>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    resources: ::protobuf::RepeatedField<Resource>,
    executor: ::protobuf::SingularPtrField<ExecutorInfo>,
    command: ::protobuf::SingularPtrField<CommandInfo>,
    container: ::protobuf::SingularPtrField<ContainerInfo>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    health_check: ::protobuf::SingularPtrField<HealthCheck>,
    labels: ::protobuf::SingularPtrField<Labels>,
    discovery: ::protobuf::SingularPtrField<DiscoveryInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskInfo {}

impl TaskInfo {
    pub fn new() -> TaskInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskInfo {
        static mut instance: ::protobuf::lazy::Lazy<TaskInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskInfo,
        };
        unsafe {
            instance.get(|| {
                TaskInfo {
                    name: ::protobuf::SingularField::none(),
                    task_id: ::protobuf::SingularPtrField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    resources: ::protobuf::RepeatedField::new(),
                    executor: ::protobuf::SingularPtrField::none(),
                    command: ::protobuf::SingularPtrField::none(),
                    container: ::protobuf::SingularPtrField::none(),
                    data: ::protobuf::SingularField::none(),
                    health_check: ::protobuf::SingularPtrField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    discovery: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required .mesos.v1.TaskID task_id = 2;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // required .mesos.v1.AgentID agent_id = 3;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // repeated .mesos.v1.Resource resources = 4;

    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<Resource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Resource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<Resource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }

    pub fn get_resources<'a>(&'a self) -> &'a [Resource] {
        &self.resources
    }

    // optional .mesos.v1.ExecutorInfo executor = 5;

    pub fn clear_executor(&mut self) {
        self.executor.clear();
    }

    pub fn has_executor(&self) -> bool {
        self.executor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor(&mut self, v: ExecutorInfo) {
        self.executor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor<'a>(&'a mut self) -> &'a mut ExecutorInfo {
        if self.executor.is_none() {
            self.executor.set_default();
        };
        self.executor.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor(&mut self) -> ExecutorInfo {
        self.executor.take().unwrap_or_else(|| ExecutorInfo::new())
    }

    pub fn get_executor<'a>(&'a self) -> &'a ExecutorInfo {
        self.executor.as_ref().unwrap_or_else(|| ExecutorInfo::default_instance())
    }

    // optional .mesos.v1.CommandInfo command = 7;

    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: CommandInfo) {
        self.command = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command<'a>(&'a mut self) -> &'a mut CommandInfo {
        if self.command.is_none() {
            self.command.set_default();
        };
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> CommandInfo {
        self.command.take().unwrap_or_else(|| CommandInfo::new())
    }

    pub fn get_command<'a>(&'a self) -> &'a CommandInfo {
        self.command.as_ref().unwrap_or_else(|| CommandInfo::default_instance())
    }

    // optional .mesos.v1.ContainerInfo container = 9;

    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ContainerInfo) {
        self.container = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container<'a>(&'a mut self) -> &'a mut ContainerInfo {
        if self.container.is_none() {
            self.container.set_default();
        };
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ContainerInfo {
        self.container.take().unwrap_or_else(|| ContainerInfo::new())
    }

    pub fn get_container<'a>(&'a self) -> &'a ContainerInfo {
        self.container.as_ref().unwrap_or_else(|| ContainerInfo::default_instance())
    }

    // optional bytes data = 6;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.v1.HealthCheck health_check = 8;

    pub fn clear_health_check(&mut self) {
        self.health_check.clear();
    }

    pub fn has_health_check(&self) -> bool {
        self.health_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_check(&mut self, v: HealthCheck) {
        self.health_check = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health_check<'a>(&'a mut self) -> &'a mut HealthCheck {
        if self.health_check.is_none() {
            self.health_check.set_default();
        };
        self.health_check.as_mut().unwrap()
    }

    // Take field
    pub fn take_health_check(&mut self) -> HealthCheck {
        self.health_check.take().unwrap_or_else(|| HealthCheck::new())
    }

    pub fn get_health_check<'a>(&'a self) -> &'a HealthCheck {
        self.health_check.as_ref().unwrap_or_else(|| HealthCheck::default_instance())
    }

    // optional .mesos.v1.Labels labels = 10;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    // optional .mesos.v1.DiscoveryInfo discovery = 11;

    pub fn clear_discovery(&mut self) {
        self.discovery.clear();
    }

    pub fn has_discovery(&self) -> bool {
        self.discovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discovery(&mut self, v: DiscoveryInfo) {
        self.discovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discovery<'a>(&'a mut self) -> &'a mut DiscoveryInfo {
        if self.discovery.is_none() {
            self.discovery.set_default();
        };
        self.discovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_discovery(&mut self) -> DiscoveryInfo {
        self.discovery.take().unwrap_or_else(|| DiscoveryInfo::new())
    }

    pub fn get_discovery<'a>(&'a self) -> &'a DiscoveryInfo {
        self.discovery.as_ref().unwrap_or_else(|| DiscoveryInfo::default_instance())
    }
}

impl ::protobuf::Message for TaskInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.task_id.is_none() {
            return false;
        };
        if self.agent_id.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_id));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.command));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.health_check));
                },
                10 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.discovery));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.resources.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.command.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in self.health_check.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.discovery.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.resources.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.command.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container.as_ref() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(6, &v));
        };
        if let Some(v) = self.health_check.as_ref() {
            try!(os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.discovery.as_ref() {
            try!(os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskInfo {
    fn new() -> TaskInfo {
        TaskInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    TaskInfo::has_name,
                    TaskInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    TaskInfo::has_task_id,
                    TaskInfo::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    TaskInfo::has_agent_id,
                    TaskInfo::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "resources",
                    TaskInfo::get_resources,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor",
                    TaskInfo::has_executor,
                    TaskInfo::get_executor,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "command",
                    TaskInfo::has_command,
                    TaskInfo::get_command,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container",
                    TaskInfo::has_container,
                    TaskInfo::get_container,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    TaskInfo::has_data,
                    TaskInfo::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "health_check",
                    TaskInfo::has_health_check,
                    TaskInfo::get_health_check,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    TaskInfo::has_labels,
                    TaskInfo::get_labels,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "discovery",
                    TaskInfo::has_discovery,
                    TaskInfo::get_discovery,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskInfo>(
                    "TaskInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskInfo {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_task_id();
        self.clear_agent_id();
        self.clear_resources();
        self.clear_executor();
        self.clear_command();
        self.clear_container();
        self.clear_data();
        self.clear_health_check();
        self.clear_labels();
        self.clear_discovery();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskInfo {
    fn eq(&self, other: &TaskInfo) -> bool {
        self.name == other.name &&
        self.task_id == other.task_id &&
        self.agent_id == other.agent_id &&
        self.resources == other.resources &&
        self.executor == other.executor &&
        self.command == other.command &&
        self.container == other.container &&
        self.data == other.data &&
        self.health_check == other.health_check &&
        self.labels == other.labels &&
        self.discovery == other.discovery &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct TaskStatus {
    // message fields
    task_id: ::protobuf::SingularPtrField<TaskID>,
    state: ::std::option::Option<TaskState>,
    message: ::protobuf::SingularField<::std::string::String>,
    source: ::std::option::Option<TaskStatus_Source>,
    reason: ::std::option::Option<TaskStatus_Reason>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    agent_id: ::protobuf::SingularPtrField<AgentID>,
    executor_id: ::protobuf::SingularPtrField<ExecutorID>,
    timestamp: ::std::option::Option<f64>,
    uuid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    healthy: ::std::option::Option<bool>,
    labels: ::protobuf::SingularPtrField<Labels>,
    container_status: ::protobuf::SingularPtrField<ContainerStatus>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for TaskStatus {}

impl TaskStatus {
    pub fn new() -> TaskStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static TaskStatus {
        static mut instance: ::protobuf::lazy::Lazy<TaskStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TaskStatus,
        };
        unsafe {
            instance.get(|| {
                TaskStatus {
                    task_id: ::protobuf::SingularPtrField::none(),
                    state: ::std::option::Option::None,
                    message: ::protobuf::SingularField::none(),
                    source: ::std::option::Option::None,
                    reason: ::std::option::Option::None,
                    data: ::protobuf::SingularField::none(),
                    agent_id: ::protobuf::SingularPtrField::none(),
                    executor_id: ::protobuf::SingularPtrField::none(),
                    timestamp: ::std::option::Option::None,
                    uuid: ::protobuf::SingularField::none(),
                    healthy: ::std::option::Option::None,
                    labels: ::protobuf::SingularPtrField::none(),
                    container_status: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.TaskID task_id = 1;

    pub fn clear_task_id(&mut self) {
        self.task_id.clear();
    }

    pub fn has_task_id(&self) -> bool {
        self.task_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_task_id(&mut self, v: TaskID) {
        self.task_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_task_id<'a>(&'a mut self) -> &'a mut TaskID {
        if self.task_id.is_none() {
            self.task_id.set_default();
        };
        self.task_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_task_id(&mut self) -> TaskID {
        self.task_id.take().unwrap_or_else(|| TaskID::new())
    }

    pub fn get_task_id<'a>(&'a self) -> &'a TaskID {
        self.task_id.as_ref().unwrap_or_else(|| TaskID::default_instance())
    }

    // required .mesos.v1.TaskState state = 2;

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: TaskState) {
        self.state = ::std::option::Option::Some(v);
    }

    pub fn get_state<'a>(&self) -> TaskState {
        self.state.unwrap_or(TaskState::TASK_STAGING)
    }

    // optional string message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.TaskStatus.Source source = 9;

    pub fn clear_source(&mut self) {
        self.source = ::std::option::Option::None;
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: TaskStatus_Source) {
        self.source = ::std::option::Option::Some(v);
    }

    pub fn get_source<'a>(&self) -> TaskStatus_Source {
        self.source.unwrap_or(TaskStatus_Source::SOURCE_MASTER)
    }

    // optional .mesos.v1.TaskStatus.Reason reason = 10;

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TaskStatus_Reason) {
        self.reason = ::std::option::Option::Some(v);
    }

    pub fn get_reason<'a>(&self) -> TaskStatus_Reason {
        self.reason.unwrap_or(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED)
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional .mesos.v1.AgentID agent_id = 5;

    pub fn clear_agent_id(&mut self) {
        self.agent_id.clear();
    }

    pub fn has_agent_id(&self) -> bool {
        self.agent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agent_id(&mut self, v: AgentID) {
        self.agent_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agent_id<'a>(&'a mut self) -> &'a mut AgentID {
        if self.agent_id.is_none() {
            self.agent_id.set_default();
        };
        self.agent_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_agent_id(&mut self) -> AgentID {
        self.agent_id.take().unwrap_or_else(|| AgentID::new())
    }

    pub fn get_agent_id<'a>(&'a self) -> &'a AgentID {
        self.agent_id.as_ref().unwrap_or_else(|| AgentID::default_instance())
    }

    // optional .mesos.v1.ExecutorID executor_id = 7;

    pub fn clear_executor_id(&mut self) {
        self.executor_id.clear();
    }

    pub fn has_executor_id(&self) -> bool {
        self.executor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executor_id(&mut self, v: ExecutorID) {
        self.executor_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_executor_id<'a>(&'a mut self) -> &'a mut ExecutorID {
        if self.executor_id.is_none() {
            self.executor_id.set_default();
        };
        self.executor_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_executor_id(&mut self) -> ExecutorID {
        self.executor_id.take().unwrap_or_else(|| ExecutorID::new())
    }

    pub fn get_executor_id<'a>(&'a self) -> &'a ExecutorID {
        self.executor_id.as_ref().unwrap_or_else(|| ExecutorID::default_instance())
    }

    // optional double timestamp = 6;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_timestamp<'a>(&self) -> f64 {
        self.timestamp.unwrap_or(0.)
    }

    // optional bytes uuid = 11;

    pub fn clear_uuid(&mut self) {
        self.uuid.clear();
    }

    pub fn has_uuid(&self) -> bool {
        self.uuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uuid(&mut self, v: ::std::vec::Vec<u8>) {
        self.uuid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uuid<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.uuid.is_none() {
            self.uuid.set_default();
        };
        self.uuid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uuid(&mut self) -> ::std::vec::Vec<u8> {
        self.uuid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_uuid<'a>(&'a self) -> &'a [u8] {
        match self.uuid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool healthy = 8;

    pub fn clear_healthy(&mut self) {
        self.healthy = ::std::option::Option::None;
    }

    pub fn has_healthy(&self) -> bool {
        self.healthy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthy(&mut self, v: bool) {
        self.healthy = ::std::option::Option::Some(v);
    }

    pub fn get_healthy<'a>(&self) -> bool {
        self.healthy.unwrap_or(false)
    }

    // optional .mesos.v1.Labels labels = 12;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }

    // optional .mesos.v1.ContainerStatus container_status = 13;

    pub fn clear_container_status(&mut self) {
        self.container_status.clear();
    }

    pub fn has_container_status(&self) -> bool {
        self.container_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_status(&mut self, v: ContainerStatus) {
        self.container_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_status<'a>(&'a mut self) -> &'a mut ContainerStatus {
        if self.container_status.is_none() {
            self.container_status.set_default();
        };
        self.container_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_status(&mut self) -> ContainerStatus {
        self.container_status.take().unwrap_or_else(|| ContainerStatus::new())
    }

    pub fn get_container_status<'a>(&'a self) -> &'a ContainerStatus {
        self.container_status.as_ref().unwrap_or_else(|| ContainerStatus::default_instance())
    }
}

impl ::protobuf::Message for TaskStatus {
    fn is_initialized(&self) -> bool {
        if self.task_id.is_none() {
            return false;
        };
        if self.state.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.task_id));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.state = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.source = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.agent_id));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.executor_id));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.timestamp = ::std::option::Option::Some(tmp);
                },
                11 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.uuid));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.healthy = ::std::option::Option::Some(tmp);
                },
                12 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                13 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.container_status));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.task_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.state.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.source.iter() {
            my_size += ::protobuf::rt::enum_size(9, *value);
        };
        for value in self.reason.iter() {
            my_size += ::protobuf::rt::enum_size(10, *value);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.agent_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.executor_id.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp.is_some() {
            my_size += 9;
        };
        for value in self.uuid.iter() {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        if self.healthy.is_some() {
            my_size += 2;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.container_status.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.task_id.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.state {
            try!(os.write_enum(2, v.value()));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.source {
            try!(os.write_enum(9, v.value()));
        };
        if let Some(v) = self.reason {
            try!(os.write_enum(10, v.value()));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.agent_id.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.executor_id.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.timestamp {
            try!(os.write_double(6, v));
        };
        if let Some(v) = self.uuid.as_ref() {
            try!(os.write_bytes(11, &v));
        };
        if let Some(v) = self.healthy {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.container_status.as_ref() {
            try!(os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<TaskStatus>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for TaskStatus {
    fn new() -> TaskStatus {
        TaskStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<TaskStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "task_id",
                    TaskStatus::has_task_id,
                    TaskStatus::get_task_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "state",
                    TaskStatus::has_state,
                    TaskStatus::get_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "message",
                    TaskStatus::has_message,
                    TaskStatus::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "source",
                    TaskStatus::has_source,
                    TaskStatus::get_source,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "reason",
                    TaskStatus::has_reason,
                    TaskStatus::get_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    TaskStatus::has_data,
                    TaskStatus::get_data,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "agent_id",
                    TaskStatus::has_agent_id,
                    TaskStatus::get_agent_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "executor_id",
                    TaskStatus::has_executor_id,
                    TaskStatus::get_executor_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "timestamp",
                    TaskStatus::has_timestamp,
                    TaskStatus::get_timestamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "uuid",
                    TaskStatus::has_uuid,
                    TaskStatus::get_uuid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "healthy",
                    TaskStatus::has_healthy,
                    TaskStatus::get_healthy,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    TaskStatus::has_labels,
                    TaskStatus::get_labels,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "container_status",
                    TaskStatus::has_container_status,
                    TaskStatus::get_container_status,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TaskStatus>(
                    "TaskStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for TaskStatus {
    fn clear(&mut self) {
        self.clear_task_id();
        self.clear_state();
        self.clear_message();
        self.clear_source();
        self.clear_reason();
        self.clear_data();
        self.clear_agent_id();
        self.clear_executor_id();
        self.clear_timestamp();
        self.clear_uuid();
        self.clear_healthy();
        self.clear_labels();
        self.clear_container_status();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for TaskStatus {
    fn eq(&self, other: &TaskStatus) -> bool {
        self.task_id == other.task_id &&
        self.state == other.state &&
        self.message == other.message &&
        self.source == other.source &&
        self.reason == other.reason &&
        self.data == other.data &&
        self.agent_id == other.agent_id &&
        self.executor_id == other.executor_id &&
        self.timestamp == other.timestamp &&
        self.uuid == other.uuid &&
        self.healthy == other.healthy &&
        self.labels == other.labels &&
        self.container_status == other.container_status &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for TaskStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Source {
    SOURCE_MASTER = 0,
    SOURCE_AGENT = 1,
    SOURCE_EXECUTOR = 2,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Source {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Source> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_MASTER),
            1 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_AGENT),
            2 => ::std::option::Option::Some(TaskStatus_Source::SOURCE_EXECUTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatus_Source] = &[
            TaskStatus_Source::SOURCE_MASTER,
            TaskStatus_Source::SOURCE_AGENT,
            TaskStatus_Source::SOURCE_EXECUTOR,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<TaskStatus_Source>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Source", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Source {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskStatus_Reason {
    REASON_COMMAND_EXECUTOR_FAILED = 0,
    REASON_CONTAINER_LAUNCH_FAILED = 21,
    REASON_CONTAINER_LIMITATION = 19,
    REASON_CONTAINER_LIMITATION_DISK = 20,
    REASON_CONTAINER_LIMITATION_MEMORY = 8,
    REASON_CONTAINER_PREEMPTED = 17,
    REASON_CONTAINER_UPDATE_FAILED = 22,
    REASON_EXECUTOR_REGISTRATION_TIMEOUT = 23,
    REASON_EXECUTOR_REREGISTRATION_TIMEOUT = 24,
    REASON_EXECUTOR_TERMINATED = 1,
    REASON_EXECUTOR_UNREGISTERED = 2,
    REASON_FRAMEWORK_REMOVED = 3,
    REASON_GC_ERROR = 4,
    REASON_INVALID_FRAMEWORKID = 5,
    REASON_INVALID_OFFERS = 6,
    REASON_MASTER_DISCONNECTED = 7,
    REASON_RECONCILIATION = 9,
    REASON_RESOURCES_UNKNOWN = 18,
    REASON_AGENT_DISCONNECTED = 10,
    REASON_AGENT_REMOVED = 11,
    REASON_AGENT_RESTARTED = 12,
    REASON_AGENT_UNKNOWN = 13,
    REASON_TASK_INVALID = 14,
    REASON_TASK_UNAUTHORIZED = 15,
    REASON_TASK_UNKNOWN = 16,
}

impl ::protobuf::ProtobufEnum for TaskStatus_Reason {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskStatus_Reason> {
        match value {
            0 => ::std::option::Option::Some(TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED),
            21 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LAUNCH_FAILED),
            19 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION),
            20 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION_DISK),
            8 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_LIMITATION_MEMORY),
            17 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_PREEMPTED),
            22 => ::std::option::Option::Some(TaskStatus_Reason::REASON_CONTAINER_UPDATE_FAILED),
            23 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_REGISTRATION_TIMEOUT),
            24 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_REREGISTRATION_TIMEOUT),
            1 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_TERMINATED),
            2 => ::std::option::Option::Some(TaskStatus_Reason::REASON_EXECUTOR_UNREGISTERED),
            3 => ::std::option::Option::Some(TaskStatus_Reason::REASON_FRAMEWORK_REMOVED),
            4 => ::std::option::Option::Some(TaskStatus_Reason::REASON_GC_ERROR),
            5 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_FRAMEWORKID),
            6 => ::std::option::Option::Some(TaskStatus_Reason::REASON_INVALID_OFFERS),
            7 => ::std::option::Option::Some(TaskStatus_Reason::REASON_MASTER_DISCONNECTED),
            9 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RECONCILIATION),
            18 => ::std::option::Option::Some(TaskStatus_Reason::REASON_RESOURCES_UNKNOWN),
            10 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_DISCONNECTED),
            11 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_REMOVED),
            12 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_RESTARTED),
            13 => ::std::option::Option::Some(TaskStatus_Reason::REASON_AGENT_UNKNOWN),
            14 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_INVALID),
            15 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNAUTHORIZED),
            16 => ::std::option::Option::Some(TaskStatus_Reason::REASON_TASK_UNKNOWN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskStatus_Reason] = &[
            TaskStatus_Reason::REASON_COMMAND_EXECUTOR_FAILED,
            TaskStatus_Reason::REASON_CONTAINER_LAUNCH_FAILED,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION_DISK,
            TaskStatus_Reason::REASON_CONTAINER_LIMITATION_MEMORY,
            TaskStatus_Reason::REASON_CONTAINER_PREEMPTED,
            TaskStatus_Reason::REASON_CONTAINER_UPDATE_FAILED,
            TaskStatus_Reason::REASON_EXECUTOR_REGISTRATION_TIMEOUT,
            TaskStatus_Reason::REASON_EXECUTOR_REREGISTRATION_TIMEOUT,
            TaskStatus_Reason::REASON_EXECUTOR_TERMINATED,
            TaskStatus_Reason::REASON_EXECUTOR_UNREGISTERED,
            TaskStatus_Reason::REASON_FRAMEWORK_REMOVED,
            TaskStatus_Reason::REASON_GC_ERROR,
            TaskStatus_Reason::REASON_INVALID_FRAMEWORKID,
            TaskStatus_Reason::REASON_INVALID_OFFERS,
            TaskStatus_Reason::REASON_MASTER_DISCONNECTED,
            TaskStatus_Reason::REASON_RECONCILIATION,
            TaskStatus_Reason::REASON_RESOURCES_UNKNOWN,
            TaskStatus_Reason::REASON_AGENT_DISCONNECTED,
            TaskStatus_Reason::REASON_AGENT_REMOVED,
            TaskStatus_Reason::REASON_AGENT_RESTARTED,
            TaskStatus_Reason::REASON_AGENT_UNKNOWN,
            TaskStatus_Reason::REASON_TASK_INVALID,
            TaskStatus_Reason::REASON_TASK_UNAUTHORIZED,
            TaskStatus_Reason::REASON_TASK_UNKNOWN,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<TaskStatus_Reason>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskStatus_Reason", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskStatus_Reason {
}

#[derive(Clone,Default)]
pub struct Filters {
    // message fields
    refuse_seconds: ::std::option::Option<f64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Filters {}

impl Filters {
    pub fn new() -> Filters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Filters {
        static mut instance: ::protobuf::lazy::Lazy<Filters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Filters,
        };
        unsafe {
            instance.get(|| {
                Filters {
                    refuse_seconds: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional double refuse_seconds = 1;

    pub fn clear_refuse_seconds(&mut self) {
        self.refuse_seconds = ::std::option::Option::None;
    }

    pub fn has_refuse_seconds(&self) -> bool {
        self.refuse_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refuse_seconds(&mut self, v: f64) {
        self.refuse_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_refuse_seconds<'a>(&self) -> f64 {
        self.refuse_seconds.unwrap_or(5f64)
    }
}

impl ::protobuf::Message for Filters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.refuse_seconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.refuse_seconds.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.refuse_seconds {
            try!(os.write_double(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Filters>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Filters {
    fn new() -> Filters {
        Filters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Filters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "refuse_seconds",
                    Filters::has_refuse_seconds,
                    Filters::get_refuse_seconds,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Filters>(
                    "Filters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Filters {
    fn clear(&mut self) {
        self.clear_refuse_seconds();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Filters {
    fn eq(&self, other: &Filters) -> bool {
        self.refuse_seconds == other.refuse_seconds &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Filters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Environment {
    // message fields
    variables: ::protobuf::RepeatedField<Environment_Variable>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Environment {}

impl Environment {
    pub fn new() -> Environment {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment {
        static mut instance: ::protobuf::lazy::Lazy<Environment> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment,
        };
        unsafe {
            instance.get(|| {
                Environment {
                    variables: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Environment.Variable variables = 1;

    pub fn clear_variables(&mut self) {
        self.variables.clear();
    }

    // Param is passed by value, moved
    pub fn set_variables(&mut self, v: ::protobuf::RepeatedField<Environment_Variable>) {
        self.variables = v;
    }

    // Mutable pointer to the field.
    pub fn mut_variables<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Environment_Variable> {
        &mut self.variables
    }

    // Take field
    pub fn take_variables(&mut self) -> ::protobuf::RepeatedField<Environment_Variable> {
        ::std::mem::replace(&mut self.variables, ::protobuf::RepeatedField::new())
    }

    pub fn get_variables<'a>(&'a self) -> &'a [Environment_Variable] {
        &self.variables
    }
}

impl ::protobuf::Message for Environment {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.variables));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.variables.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.variables.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Environment>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment {
    fn new() -> Environment {
        Environment::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "variables",
                    Environment::get_variables,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment>(
                    "Environment",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment {
    fn clear(&mut self) {
        self.clear_variables();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Environment {
    fn eq(&self, other: &Environment) -> bool {
        self.variables == other.variables &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Environment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Environment_Variable {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Environment_Variable {}

impl Environment_Variable {
    pub fn new() -> Environment_Variable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Environment_Variable {
        static mut instance: ::protobuf::lazy::Lazy<Environment_Variable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Environment_Variable,
        };
        unsafe {
            instance.get(|| {
                Environment_Variable {
                    name: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Environment_Variable {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Environment_Variable>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Environment_Variable {
    fn new() -> Environment_Variable {
        Environment_Variable::new()
    }

    fn descriptor_static(_: ::std::option::Option<Environment_Variable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Environment_Variable::has_name,
                    Environment_Variable::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Environment_Variable::has_value,
                    Environment_Variable::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Environment_Variable>(
                    "Environment_Variable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Environment_Variable {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Environment_Variable {
    fn eq(&self, other: &Environment_Variable) -> bool {
        self.name == other.name &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Environment_Variable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Parameter {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Parameter {}

impl Parameter {
    pub fn new() -> Parameter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameter {
        static mut instance: ::protobuf::lazy::Lazy<Parameter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameter,
        };
        unsafe {
            instance.get(|| {
                Parameter {
                    key: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // required string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Parameter {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        };
        if self.value.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Parameter>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameter {
    fn new() -> Parameter {
        Parameter::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "key",
                    Parameter::has_key,
                    Parameter::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Parameter::has_value,
                    Parameter::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameter>(
                    "Parameter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameter {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Parameter {
    fn eq(&self, other: &Parameter) -> bool {
        self.key == other.key &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Parameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Parameters {
    // message fields
    parameter: ::protobuf::RepeatedField<Parameter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Parameters {}

impl Parameters {
    pub fn new() -> Parameters {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Parameters {
        static mut instance: ::protobuf::lazy::Lazy<Parameters> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Parameters,
        };
        unsafe {
            instance.get(|| {
                Parameters {
                    parameter: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Parameter parameter = 1;

    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameter = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameter
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameter, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameter<'a>(&'a self) -> &'a [Parameter] {
        &self.parameter
    }
}

impl ::protobuf::Message for Parameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameter));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.parameter.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.parameter.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Parameters>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Parameters {
    fn new() -> Parameters {
        Parameters::new()
    }

    fn descriptor_static(_: ::std::option::Option<Parameters>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "parameter",
                    Parameters::get_parameter,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Parameters>(
                    "Parameters",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Parameters {
    fn clear(&mut self) {
        self.clear_parameter();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Parameters {
    fn eq(&self, other: &Parameters) -> bool {
        self.parameter == other.parameter &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Parameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Credential {
    // message fields
    principal: ::protobuf::SingularField<::std::string::String>,
    secret: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Credential {}

impl Credential {
    pub fn new() -> Credential {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credential {
        static mut instance: ::protobuf::lazy::Lazy<Credential> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credential,
        };
        unsafe {
            instance.get(|| {
                Credential {
                    principal: ::protobuf::SingularField::none(),
                    secret: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string principal = 1;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string secret = 2;

    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::std::string::String) {
        self.secret = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.secret.is_none() {
            self.secret.set_default();
        };
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::std::string::String {
        self.secret.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_secret<'a>(&'a self) -> &'a str {
        match self.secret.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Credential {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secret));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.secret.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.secret.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Credential>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credential {
    fn new() -> Credential {
        Credential::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credential>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    Credential::has_principal,
                    Credential::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "secret",
                    Credential::has_secret,
                    Credential::get_secret,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credential>(
                    "Credential",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credential {
    fn clear(&mut self) {
        self.clear_principal();
        self.clear_secret();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Credential {
    fn eq(&self, other: &Credential) -> bool {
        self.principal == other.principal &&
        self.secret == other.secret &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Credential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Credentials {
    // message fields
    credentials: ::protobuf::RepeatedField<Credential>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Credentials {}

impl Credentials {
    pub fn new() -> Credentials {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Credentials {
        static mut instance: ::protobuf::lazy::Lazy<Credentials> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Credentials,
        };
        unsafe {
            instance.get(|| {
                Credentials {
                    credentials: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Credential credentials = 1;

    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: ::protobuf::RepeatedField<Credential>) {
        self.credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Credential> {
        &mut self.credentials
    }

    // Take field
    pub fn take_credentials(&mut self) -> ::protobuf::RepeatedField<Credential> {
        ::std::mem::replace(&mut self.credentials, ::protobuf::RepeatedField::new())
    }

    pub fn get_credentials<'a>(&'a self) -> &'a [Credential] {
        &self.credentials
    }
}

impl ::protobuf::Message for Credentials {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.credentials));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.credentials.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.credentials.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Credentials>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Credentials {
    fn new() -> Credentials {
        Credentials::new()
    }

    fn descriptor_static(_: ::std::option::Option<Credentials>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "credentials",
                    Credentials::get_credentials,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Credentials>(
                    "Credentials",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Credentials {
    fn clear(&mut self) {
        self.clear_credentials();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Credentials {
    fn eq(&self, other: &Credentials) -> bool {
        self.credentials == other.credentials &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Credentials {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RateLimit {
    // message fields
    qps: ::std::option::Option<f64>,
    principal: ::protobuf::SingularField<::std::string::String>,
    capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RateLimit {}

impl RateLimit {
    pub fn new() -> RateLimit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimit {
        static mut instance: ::protobuf::lazy::Lazy<RateLimit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimit,
        };
        unsafe {
            instance.get(|| {
                RateLimit {
                    qps: ::std::option::Option::None,
                    principal: ::protobuf::SingularField::none(),
                    capacity: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional double qps = 1;

    pub fn clear_qps(&mut self) {
        self.qps = ::std::option::Option::None;
    }

    pub fn has_qps(&self) -> bool {
        self.qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qps(&mut self, v: f64) {
        self.qps = ::std::option::Option::Some(v);
    }

    pub fn get_qps<'a>(&self) -> f64 {
        self.qps.unwrap_or(0.)
    }

    // required string principal = 2;

    pub fn clear_principal(&mut self) {
        self.principal.clear();
    }

    pub fn has_principal(&self) -> bool {
        self.principal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal(&mut self, v: ::std::string::String) {
        self.principal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.principal.is_none() {
            self.principal.set_default();
        };
        self.principal.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal(&mut self) -> ::std::string::String {
        self.principal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_principal<'a>(&'a self) -> &'a str {
        match self.principal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 capacity = 3;

    pub fn clear_capacity(&mut self) {
        self.capacity = ::std::option::Option::None;
    }

    pub fn has_capacity(&self) -> bool {
        self.capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: u64) {
        self.capacity = ::std::option::Option::Some(v);
    }

    pub fn get_capacity<'a>(&self) -> u64 {
        self.capacity.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateLimit {
    fn is_initialized(&self) -> bool {
        if self.principal.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.qps = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.principal));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.qps.is_some() {
            my_size += 9;
        };
        for value in self.principal.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.capacity.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.qps {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.principal.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.capacity {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RateLimit>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimit {
    fn new() -> RateLimit {
        RateLimit::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "qps",
                    RateLimit::has_qps,
                    RateLimit::get_qps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "principal",
                    RateLimit::has_principal,
                    RateLimit::get_principal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "capacity",
                    RateLimit::has_capacity,
                    RateLimit::get_capacity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimit>(
                    "RateLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimit {
    fn clear(&mut self) {
        self.clear_qps();
        self.clear_principal();
        self.clear_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RateLimit {
    fn eq(&self, other: &RateLimit) -> bool {
        self.qps == other.qps &&
        self.principal == other.principal &&
        self.capacity == other.capacity &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RateLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct RateLimits {
    // message fields
    limits: ::protobuf::RepeatedField<RateLimit>,
    aggregate_default_qps: ::std::option::Option<f64>,
    aggregate_default_capacity: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for RateLimits {}

impl RateLimits {
    pub fn new() -> RateLimits {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static RateLimits {
        static mut instance: ::protobuf::lazy::Lazy<RateLimits> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RateLimits,
        };
        unsafe {
            instance.get(|| {
                RateLimits {
                    limits: ::protobuf::RepeatedField::new(),
                    aggregate_default_qps: ::std::option::Option::None,
                    aggregate_default_capacity: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.RateLimit limits = 1;

    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }

    pub fn get_limits<'a>(&'a self) -> &'a [RateLimit] {
        &self.limits
    }

    // optional double aggregate_default_qps = 2;

    pub fn clear_aggregate_default_qps(&mut self) {
        self.aggregate_default_qps = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_qps(&self) -> bool {
        self.aggregate_default_qps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_qps(&mut self, v: f64) {
        self.aggregate_default_qps = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_qps<'a>(&self) -> f64 {
        self.aggregate_default_qps.unwrap_or(0.)
    }

    // optional uint64 aggregate_default_capacity = 3;

    pub fn clear_aggregate_default_capacity(&mut self) {
        self.aggregate_default_capacity = ::std::option::Option::None;
    }

    pub fn has_aggregate_default_capacity(&self) -> bool {
        self.aggregate_default_capacity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_default_capacity(&mut self, v: u64) {
        self.aggregate_default_capacity = ::std::option::Option::Some(v);
    }

    pub fn get_aggregate_default_capacity<'a>(&self) -> u64 {
        self.aggregate_default_capacity.unwrap_or(0)
    }
}

impl ::protobuf::Message for RateLimits {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.aggregate_default_qps = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.aggregate_default_capacity = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.limits.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.aggregate_default_qps.is_some() {
            my_size += 9;
        };
        for value in self.aggregate_default_capacity.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.limits.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.aggregate_default_qps {
            try!(os.write_double(2, v));
        };
        if let Some(v) = self.aggregate_default_capacity {
            try!(os.write_uint64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<RateLimits>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for RateLimits {
    fn new() -> RateLimits {
        RateLimits::new()
    }

    fn descriptor_static(_: ::std::option::Option<RateLimits>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "limits",
                    RateLimits::get_limits,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "aggregate_default_qps",
                    RateLimits::has_aggregate_default_qps,
                    RateLimits::get_aggregate_default_qps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "aggregate_default_capacity",
                    RateLimits::has_aggregate_default_capacity,
                    RateLimits::get_aggregate_default_capacity,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RateLimits>(
                    "RateLimits",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for RateLimits {
    fn clear(&mut self) {
        self.clear_limits();
        self.clear_aggregate_default_qps();
        self.clear_aggregate_default_capacity();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for RateLimits {
    fn eq(&self, other: &RateLimits) -> bool {
        self.limits == other.limits &&
        self.aggregate_default_qps == other.aggregate_default_qps &&
        self.aggregate_default_capacity == other.aggregate_default_capacity &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for RateLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Image {
    // message fields
    field_type: ::std::option::Option<Image_Type>,
    appc: ::protobuf::SingularPtrField<Image_Appc>,
    docker: ::protobuf::SingularPtrField<Image_Docker>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image {}

impl Image {
    pub fn new() -> Image {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image {
        static mut instance: ::protobuf::lazy::Lazy<Image> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image,
        };
        unsafe {
            instance.get(|| {
                Image {
                    field_type: ::std::option::Option::None,
                    appc: ::protobuf::SingularPtrField::none(),
                    docker: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.Image.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Image_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> Image_Type {
        self.field_type.unwrap_or(Image_Type::APPC)
    }

    // optional .mesos.v1.Image.Appc appc = 2;

    pub fn clear_appc(&mut self) {
        self.appc.clear();
    }

    pub fn has_appc(&self) -> bool {
        self.appc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appc(&mut self, v: Image_Appc) {
        self.appc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appc<'a>(&'a mut self) -> &'a mut Image_Appc {
        if self.appc.is_none() {
            self.appc.set_default();
        };
        self.appc.as_mut().unwrap()
    }

    // Take field
    pub fn take_appc(&mut self) -> Image_Appc {
        self.appc.take().unwrap_or_else(|| Image_Appc::new())
    }

    pub fn get_appc<'a>(&'a self) -> &'a Image_Appc {
        self.appc.as_ref().unwrap_or_else(|| Image_Appc::default_instance())
    }

    // optional .mesos.v1.Image.Docker docker = 3;

    pub fn clear_docker(&mut self) {
        self.docker.clear();
    }

    pub fn has_docker(&self) -> bool {
        self.docker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker(&mut self, v: Image_Docker) {
        self.docker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker<'a>(&'a mut self) -> &'a mut Image_Docker {
        if self.docker.is_none() {
            self.docker.set_default();
        };
        self.docker.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker(&mut self) -> Image_Docker {
        self.docker.take().unwrap_or_else(|| Image_Docker::new())
    }

    pub fn get_docker<'a>(&'a self) -> &'a Image_Docker {
        self.docker.as_ref().unwrap_or_else(|| Image_Docker::default_instance())
    }
}

impl ::protobuf::Message for Image {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.appc));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docker));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.appc.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.docker.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.appc.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.docker.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Image>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image {
    fn new() -> Image {
        Image::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    Image::has_field_type,
                    Image::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "appc",
                    Image::has_appc,
                    Image::get_appc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "docker",
                    Image::has_docker,
                    Image::get_docker,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image>(
                    "Image",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_appc();
        self.clear_docker();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Image {
    fn eq(&self, other: &Image) -> bool {
        self.field_type == other.field_type &&
        self.appc == other.appc &&
        self.docker == other.docker &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Image_Appc {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    id: ::protobuf::SingularField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image_Appc {}

impl Image_Appc {
    pub fn new() -> Image_Appc {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image_Appc {
        static mut instance: ::protobuf::lazy::Lazy<Image_Appc> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image_Appc,
        };
        unsafe {
            instance.get(|| {
                Image_Appc {
                    name: ::protobuf::SingularField::none(),
                    id: ::protobuf::SingularField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string id = 2;

    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.id.is_none() {
            self.id.set_default();
        };
        self.id.as_mut().unwrap()
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        self.id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_id<'a>(&'a self) -> &'a str {
        match self.id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Labels labels = 3;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for Image_Appc {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.id));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.id.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.id.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Image_Appc>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image_Appc {
    fn new() -> Image_Appc {
        Image_Appc::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image_Appc>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Image_Appc::has_name,
                    Image_Appc::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "id",
                    Image_Appc::has_id,
                    Image_Appc::get_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    Image_Appc::has_labels,
                    Image_Appc::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image_Appc>(
                    "Image_Appc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image_Appc {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_id();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Image_Appc {
    fn eq(&self, other: &Image_Appc) -> bool {
        self.name == other.name &&
        self.id == other.id &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Image_Appc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Image_Docker {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    credential: ::protobuf::SingularPtrField<Credential>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Image_Docker {}

impl Image_Docker {
    pub fn new() -> Image_Docker {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Image_Docker {
        static mut instance: ::protobuf::lazy::Lazy<Image_Docker> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Image_Docker,
        };
        unsafe {
            instance.get(|| {
                Image_Docker {
                    name: ::protobuf::SingularField::none(),
                    credential: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string name = 1;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Credential credential = 2;

    pub fn clear_credential(&mut self) {
        self.credential.clear();
    }

    pub fn has_credential(&self) -> bool {
        self.credential.is_some()
    }

    // Param is passed by value, moved
    pub fn set_credential(&mut self, v: Credential) {
        self.credential = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential<'a>(&'a mut self) -> &'a mut Credential {
        if self.credential.is_none() {
            self.credential.set_default();
        };
        self.credential.as_mut().unwrap()
    }

    // Take field
    pub fn take_credential(&mut self) -> Credential {
        self.credential.take().unwrap_or_else(|| Credential::new())
    }

    pub fn get_credential<'a>(&'a self) -> &'a Credential {
        self.credential.as_ref().unwrap_or_else(|| Credential::default_instance())
    }
}

impl ::protobuf::Message for Image_Docker {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.credential));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.credential.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.credential.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Image_Docker>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Image_Docker {
    fn new() -> Image_Docker {
        Image_Docker::new()
    }

    fn descriptor_static(_: ::std::option::Option<Image_Docker>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Image_Docker::has_name,
                    Image_Docker::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "credential",
                    Image_Docker::has_credential,
                    Image_Docker::get_credential,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Image_Docker>(
                    "Image_Docker",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Image_Docker {
    fn clear(&mut self) {
        self.clear_name();
        self.clear_credential();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Image_Docker {
    fn eq(&self, other: &Image_Docker) -> bool {
        self.name == other.name &&
        self.credential == other.credential &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Image_Docker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Image_Type {
    APPC = 1,
    DOCKER = 2,
}

impl ::protobuf::ProtobufEnum for Image_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Image_Type> {
        match value {
            1 => ::std::option::Option::Some(Image_Type::APPC),
            2 => ::std::option::Option::Some(Image_Type::DOCKER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Image_Type] = &[
            Image_Type::APPC,
            Image_Type::DOCKER,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Image_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Image_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Image_Type {
}

#[derive(Clone,Default)]
pub struct Volume {
    // message fields
    mode: ::std::option::Option<Volume_Mode>,
    container_path: ::protobuf::SingularField<::std::string::String>,
    host_path: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularPtrField<Image>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Volume {}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Volume {
        static mut instance: ::protobuf::lazy::Lazy<Volume> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Volume,
        };
        unsafe {
            instance.get(|| {
                Volume {
                    mode: ::std::option::Option::None,
                    container_path: ::protobuf::SingularField::none(),
                    host_path: ::protobuf::SingularField::none(),
                    image: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.Volume.Mode mode = 3;

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: Volume_Mode) {
        self.mode = ::std::option::Option::Some(v);
    }

    pub fn get_mode<'a>(&self) -> Volume_Mode {
        self.mode.unwrap_or(Volume_Mode::RW)
    }

    // required string container_path = 1;

    pub fn clear_container_path(&mut self) {
        self.container_path.clear();
    }

    pub fn has_container_path(&self) -> bool {
        self.container_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_path(&mut self, v: ::std::string::String) {
        self.container_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.container_path.is_none() {
            self.container_path.set_default();
        };
        self.container_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_container_path(&mut self) -> ::std::string::String {
        self.container_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_container_path<'a>(&'a self) -> &'a str {
        match self.container_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string host_path = 2;

    pub fn clear_host_path(&mut self) {
        self.host_path.clear();
    }

    pub fn has_host_path(&self) -> bool {
        self.host_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_path(&mut self, v: ::std::string::String) {
        self.host_path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_path<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.host_path.is_none() {
            self.host_path.set_default();
        };
        self.host_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_path(&mut self) -> ::std::string::String {
        self.host_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_host_path<'a>(&'a self) -> &'a str {
        match self.host_path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Image image = 4;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut Image {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }
}

impl ::protobuf::Message for Volume {
    fn is_initialized(&self) -> bool {
        if self.mode.is_none() {
            return false;
        };
        if self.container_path.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.mode = ::std::option::Option::Some(tmp);
                },
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container_path));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host_path));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.mode.iter() {
            my_size += ::protobuf::rt::enum_size(3, *value);
        };
        for value in self.container_path.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.host_path.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.image.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mode {
            try!(os.write_enum(3, v.value()));
        };
        if let Some(v) = self.container_path.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.host_path.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.image.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Volume>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Volume {
    fn new() -> Volume {
        Volume::new()
    }

    fn descriptor_static(_: ::std::option::Option<Volume>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "mode",
                    Volume::has_mode,
                    Volume::get_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "container_path",
                    Volume::has_container_path,
                    Volume::get_container_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "host_path",
                    Volume::has_host_path,
                    Volume::get_host_path,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "image",
                    Volume::has_image,
                    Volume::get_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Volume>(
                    "Volume",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Volume {
    fn clear(&mut self) {
        self.clear_mode();
        self.clear_container_path();
        self.clear_host_path();
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Volume {
    fn eq(&self, other: &Volume) -> bool {
        self.mode == other.mode &&
        self.container_path == other.container_path &&
        self.host_path == other.host_path &&
        self.image == other.image &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Volume_Mode {
    RW = 1,
    RO = 2,
}

impl ::protobuf::ProtobufEnum for Volume_Mode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Volume_Mode> {
        match value {
            1 => ::std::option::Option::Some(Volume_Mode::RW),
            2 => ::std::option::Option::Some(Volume_Mode::RO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Volume_Mode] = &[
            Volume_Mode::RW,
            Volume_Mode::RO,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Volume_Mode>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Volume_Mode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Volume_Mode {
}

#[derive(Clone,Default)]
pub struct NetworkInfo {
    // message fields
    ip_addresses: ::protobuf::RepeatedField<NetworkInfo_IPAddress>,
    protocol: ::std::option::Option<NetworkInfo_Protocol>,
    ip_address: ::protobuf::SingularField<::std::string::String>,
    groups: ::protobuf::RepeatedField<::std::string::String>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NetworkInfo {}

impl NetworkInfo {
    pub fn new() -> NetworkInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NetworkInfo {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo,
        };
        unsafe {
            instance.get(|| {
                NetworkInfo {
                    ip_addresses: ::protobuf::RepeatedField::new(),
                    protocol: ::std::option::Option::None,
                    ip_address: ::protobuf::SingularField::none(),
                    groups: ::protobuf::RepeatedField::new(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.NetworkInfo.IPAddress ip_addresses = 5;

    pub fn clear_ip_addresses(&mut self) {
        self.ip_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_addresses(&mut self, v: ::protobuf::RepeatedField<NetworkInfo_IPAddress>) {
        self.ip_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_addresses<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        &mut self.ip_addresses
    }

    // Take field
    pub fn take_ip_addresses(&mut self) -> ::protobuf::RepeatedField<NetworkInfo_IPAddress> {
        ::std::mem::replace(&mut self.ip_addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_ip_addresses<'a>(&'a self) -> &'a [NetworkInfo_IPAddress] {
        &self.ip_addresses
    }

    // optional .mesos.v1.NetworkInfo.Protocol protocol = 1;

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: NetworkInfo_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    pub fn get_protocol<'a>(&self) -> NetworkInfo_Protocol {
        self.protocol.unwrap_or(NetworkInfo_Protocol::IPv4)
    }

    // optional string ip_address = 2;

    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    pub fn has_ip_address(&self) -> bool {
        self.ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_address.is_none() {
            self.ip_address.set_default();
        };
        self.ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        self.ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_address<'a>(&'a self) -> &'a str {
        match self.ip_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // repeated string groups = 3;

    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }

    pub fn get_groups<'a>(&'a self) -> &'a [::std::string::String] {
        &self.groups
    }

    // optional .mesos.v1.Labels labels = 4;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for NetworkInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ip_addresses));
                },
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.protocol = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_address));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.groups));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ip_addresses.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.ip_address.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.groups.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.ip_addresses.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.protocol {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.ip_address.as_ref() {
            try!(os.write_string(2, &v));
        };
        for v in self.groups.iter() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<NetworkInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NetworkInfo {
    fn new() -> NetworkInfo {
        NetworkInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<NetworkInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "ip_addresses",
                    NetworkInfo::get_ip_addresses,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "protocol",
                    NetworkInfo::has_protocol,
                    NetworkInfo::get_protocol,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_address",
                    NetworkInfo::has_ip_address,
                    NetworkInfo::get_ip_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "groups",
                    NetworkInfo::get_groups,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    NetworkInfo::has_labels,
                    NetworkInfo::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo>(
                    "NetworkInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NetworkInfo {
    fn clear(&mut self) {
        self.clear_ip_addresses();
        self.clear_protocol();
        self.clear_ip_address();
        self.clear_groups();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for NetworkInfo {
    fn eq(&self, other: &NetworkInfo) -> bool {
        self.ip_addresses == other.ip_addresses &&
        self.protocol == other.protocol &&
        self.ip_address == other.ip_address &&
        self.groups == other.groups &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for NetworkInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct NetworkInfo_IPAddress {
    // message fields
    protocol: ::std::option::Option<NetworkInfo_Protocol>,
    ip_address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for NetworkInfo_IPAddress {}

impl NetworkInfo_IPAddress {
    pub fn new() -> NetworkInfo_IPAddress {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static NetworkInfo_IPAddress {
        static mut instance: ::protobuf::lazy::Lazy<NetworkInfo_IPAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NetworkInfo_IPAddress,
        };
        unsafe {
            instance.get(|| {
                NetworkInfo_IPAddress {
                    protocol: ::std::option::Option::None,
                    ip_address: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.NetworkInfo.Protocol protocol = 1;

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: NetworkInfo_Protocol) {
        self.protocol = ::std::option::Option::Some(v);
    }

    pub fn get_protocol<'a>(&self) -> NetworkInfo_Protocol {
        self.protocol.unwrap_or(NetworkInfo_Protocol::IPv4)
    }

    // optional string ip_address = 2;

    pub fn clear_ip_address(&mut self) {
        self.ip_address.clear();
    }

    pub fn has_ip_address(&self) -> bool {
        self.ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_address.is_none() {
            self.ip_address.set_default();
        };
        self.ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        self.ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_address<'a>(&'a self) -> &'a str {
        match self.ip_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for NetworkInfo_IPAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.protocol = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_address));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.ip_address.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.ip_address.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<NetworkInfo_IPAddress>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for NetworkInfo_IPAddress {
    fn new() -> NetworkInfo_IPAddress {
        NetworkInfo_IPAddress::new()
    }

    fn descriptor_static(_: ::std::option::Option<NetworkInfo_IPAddress>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "protocol",
                    NetworkInfo_IPAddress::has_protocol,
                    NetworkInfo_IPAddress::get_protocol,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_address",
                    NetworkInfo_IPAddress::has_ip_address,
                    NetworkInfo_IPAddress::get_ip_address,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NetworkInfo_IPAddress>(
                    "NetworkInfo_IPAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for NetworkInfo_IPAddress {
    fn clear(&mut self) {
        self.clear_protocol();
        self.clear_ip_address();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for NetworkInfo_IPAddress {
    fn eq(&self, other: &NetworkInfo_IPAddress) -> bool {
        self.protocol == other.protocol &&
        self.ip_address == other.ip_address &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for NetworkInfo_IPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NetworkInfo_Protocol {
    IPv4 = 1,
    IPv6 = 2,
}

impl ::protobuf::ProtobufEnum for NetworkInfo_Protocol {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NetworkInfo_Protocol> {
        match value {
            1 => ::std::option::Option::Some(NetworkInfo_Protocol::IPv4),
            2 => ::std::option::Option::Some(NetworkInfo_Protocol::IPv6),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NetworkInfo_Protocol] = &[
            NetworkInfo_Protocol::IPv4,
            NetworkInfo_Protocol::IPv6,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<NetworkInfo_Protocol>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("NetworkInfo_Protocol", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for NetworkInfo_Protocol {
}

#[derive(Clone,Default)]
pub struct ContainerInfo {
    // message fields
    field_type: ::std::option::Option<ContainerInfo_Type>,
    volumes: ::protobuf::RepeatedField<Volume>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    docker: ::protobuf::SingularPtrField<ContainerInfo_DockerInfo>,
    mesos: ::protobuf::SingularPtrField<ContainerInfo_MesosInfo>,
    network_infos: ::protobuf::RepeatedField<NetworkInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo {}

impl ContainerInfo {
    pub fn new() -> ContainerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo {
                    field_type: ::std::option::Option::None,
                    volumes: ::protobuf::RepeatedField::new(),
                    hostname: ::protobuf::SingularField::none(),
                    docker: ::protobuf::SingularPtrField::none(),
                    mesos: ::protobuf::SingularPtrField::none(),
                    network_infos: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.ContainerInfo.Type type = 1;

    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ContainerInfo_Type) {
        self.field_type = ::std::option::Option::Some(v);
    }

    pub fn get_field_type<'a>(&self) -> ContainerInfo_Type {
        self.field_type.unwrap_or(ContainerInfo_Type::DOCKER)
    }

    // repeated .mesos.v1.Volume volumes = 2;

    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Volume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    pub fn get_volumes<'a>(&'a self) -> &'a [Volume] {
        &self.volumes
    }

    // optional string hostname = 4;

    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        };
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_hostname<'a>(&'a self) -> &'a str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.ContainerInfo.DockerInfo docker = 3;

    pub fn clear_docker(&mut self) {
        self.docker.clear();
    }

    pub fn has_docker(&self) -> bool {
        self.docker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_docker(&mut self, v: ContainerInfo_DockerInfo) {
        self.docker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_docker<'a>(&'a mut self) -> &'a mut ContainerInfo_DockerInfo {
        if self.docker.is_none() {
            self.docker.set_default();
        };
        self.docker.as_mut().unwrap()
    }

    // Take field
    pub fn take_docker(&mut self) -> ContainerInfo_DockerInfo {
        self.docker.take().unwrap_or_else(|| ContainerInfo_DockerInfo::new())
    }

    pub fn get_docker<'a>(&'a self) -> &'a ContainerInfo_DockerInfo {
        self.docker.as_ref().unwrap_or_else(|| ContainerInfo_DockerInfo::default_instance())
    }

    // optional .mesos.v1.ContainerInfo.MesosInfo mesos = 5;

    pub fn clear_mesos(&mut self) {
        self.mesos.clear();
    }

    pub fn has_mesos(&self) -> bool {
        self.mesos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mesos(&mut self, v: ContainerInfo_MesosInfo) {
        self.mesos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mesos<'a>(&'a mut self) -> &'a mut ContainerInfo_MesosInfo {
        if self.mesos.is_none() {
            self.mesos.set_default();
        };
        self.mesos.as_mut().unwrap()
    }

    // Take field
    pub fn take_mesos(&mut self) -> ContainerInfo_MesosInfo {
        self.mesos.take().unwrap_or_else(|| ContainerInfo_MesosInfo::new())
    }

    pub fn get_mesos<'a>(&'a self) -> &'a ContainerInfo_MesosInfo {
        self.mesos.as_ref().unwrap_or_else(|| ContainerInfo_MesosInfo::default_instance())
    }

    // repeated .mesos.v1.NetworkInfo network_infos = 7;

    pub fn clear_network_infos(&mut self) {
        self.network_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_infos(&mut self, v: ::protobuf::RepeatedField<NetworkInfo>) {
        self.network_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_infos<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // Take field
    pub fn take_network_infos(&mut self) -> ::protobuf::RepeatedField<NetworkInfo> {
        ::std::mem::replace(&mut self.network_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_network_infos<'a>(&'a self) -> &'a [NetworkInfo] {
        &self.network_infos
    }
}

impl ::protobuf::Message for ContainerInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.field_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.docker));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mesos));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_infos));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.field_type.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.volumes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.hostname.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.docker.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.mesos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.network_infos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            try!(os.write_enum(1, v.value()));
        };
        for v in self.volumes.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.hostname.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.docker.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.mesos.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.network_infos.iter() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo {
    fn new() -> ContainerInfo {
        ContainerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "type",
                    ContainerInfo::has_field_type,
                    ContainerInfo::get_field_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "volumes",
                    ContainerInfo::get_volumes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "hostname",
                    ContainerInfo::has_hostname,
                    ContainerInfo::get_hostname,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "docker",
                    ContainerInfo::has_docker,
                    ContainerInfo::get_docker,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "mesos",
                    ContainerInfo::has_mesos,
                    ContainerInfo::get_mesos,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "network_infos",
                    ContainerInfo::get_network_infos,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo>(
                    "ContainerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo {
    fn clear(&mut self) {
        self.clear_field_type();
        self.clear_volumes();
        self.clear_hostname();
        self.clear_docker();
        self.clear_mesos();
        self.clear_network_infos();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo {
    fn eq(&self, other: &ContainerInfo) -> bool {
        self.field_type == other.field_type &&
        self.volumes == other.volumes &&
        self.hostname == other.hostname &&
        self.docker == other.docker &&
        self.mesos == other.mesos &&
        self.network_infos == other.network_infos &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerInfo_DockerInfo {
    // message fields
    image: ::protobuf::SingularField<::std::string::String>,
    network: ::std::option::Option<ContainerInfo_DockerInfo_Network>,
    port_mappings: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>,
    privileged: ::std::option::Option<bool>,
    parameters: ::protobuf::RepeatedField<Parameter>,
    force_pull_image: ::std::option::Option<bool>,
    volume_driver: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_DockerInfo {}

impl ContainerInfo_DockerInfo {
    pub fn new() -> ContainerInfo_DockerInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_DockerInfo {
                    image: ::protobuf::SingularField::none(),
                    network: ::std::option::Option::None,
                    port_mappings: ::protobuf::RepeatedField::new(),
                    privileged: ::std::option::Option::None,
                    parameters: ::protobuf::RepeatedField::new(),
                    force_pull_image: ::std::option::Option::None,
                    volume_driver: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.ContainerInfo.DockerInfo.Network network = 2;

    pub fn clear_network(&mut self) {
        self.network = ::std::option::Option::None;
    }

    pub fn has_network(&self) -> bool {
        self.network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ContainerInfo_DockerInfo_Network) {
        self.network = ::std::option::Option::Some(v);
    }

    pub fn get_network<'a>(&self) -> ContainerInfo_DockerInfo_Network {
        self.network.unwrap_or(ContainerInfo_DockerInfo_Network::HOST)
    }

    // repeated .mesos.v1.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;

    pub fn clear_port_mappings(&mut self) {
        self.port_mappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_mappings(&mut self, v: ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping>) {
        self.port_mappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_port_mappings<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        &mut self.port_mappings
    }

    // Take field
    pub fn take_port_mappings(&mut self) -> ::protobuf::RepeatedField<ContainerInfo_DockerInfo_PortMapping> {
        ::std::mem::replace(&mut self.port_mappings, ::protobuf::RepeatedField::new())
    }

    pub fn get_port_mappings<'a>(&'a self) -> &'a [ContainerInfo_DockerInfo_PortMapping] {
        &self.port_mappings
    }

    // optional bool privileged = 4;

    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    pub fn get_privileged<'a>(&self) -> bool {
        self.privileged.unwrap_or(false)
    }

    // repeated .mesos.v1.Parameter parameters = 5;

    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<Parameter>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Parameter> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<Parameter> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    pub fn get_parameters<'a>(&'a self) -> &'a [Parameter] {
        &self.parameters
    }

    // optional bool force_pull_image = 6;

    pub fn clear_force_pull_image(&mut self) {
        self.force_pull_image = ::std::option::Option::None;
    }

    pub fn has_force_pull_image(&self) -> bool {
        self.force_pull_image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_pull_image(&mut self, v: bool) {
        self.force_pull_image = ::std::option::Option::Some(v);
    }

    pub fn get_force_pull_image<'a>(&self) -> bool {
        self.force_pull_image.unwrap_or(false)
    }

    // optional string volume_driver = 7;

    pub fn clear_volume_driver(&mut self) {
        self.volume_driver.clear();
    }

    pub fn has_volume_driver(&self) -> bool {
        self.volume_driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume_driver(&mut self, v: ::std::string::String) {
        self.volume_driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume_driver<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.volume_driver.is_none() {
            self.volume_driver.set_default();
        };
        self.volume_driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume_driver(&mut self) -> ::std::string::String {
        self.volume_driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_volume_driver<'a>(&'a self) -> &'a str {
        match self.volume_driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo {
    fn is_initialized(&self) -> bool {
        if self.image.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.network = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.port_mappings));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.privileged = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_pull_image = ::std::option::Option::Some(tmp);
                },
                7 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume_driver));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.image.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.network.iter() {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        for value in self.port_mappings.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.privileged.is_some() {
            my_size += 2;
        };
        for value in self.parameters.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.force_pull_image.is_some() {
            my_size += 2;
        };
        for value in self.volume_driver.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.network {
            try!(os.write_enum(2, v.value()));
        };
        for v in self.port_mappings.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.privileged {
            try!(os.write_bool(4, v));
        };
        for v in self.parameters.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.force_pull_image {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.volume_driver.as_ref() {
            try!(os.write_string(7, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_DockerInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo {
    fn new() -> ContainerInfo_DockerInfo {
        ContainerInfo_DockerInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "image",
                    ContainerInfo_DockerInfo::has_image,
                    ContainerInfo_DockerInfo::get_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "network",
                    ContainerInfo_DockerInfo::has_network,
                    ContainerInfo_DockerInfo::get_network,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "port_mappings",
                    ContainerInfo_DockerInfo::get_port_mappings,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "privileged",
                    ContainerInfo_DockerInfo::has_privileged,
                    ContainerInfo_DockerInfo::get_privileged,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "parameters",
                    ContainerInfo_DockerInfo::get_parameters,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_pull_image",
                    ContainerInfo_DockerInfo::has_force_pull_image,
                    ContainerInfo_DockerInfo::get_force_pull_image,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "volume_driver",
                    ContainerInfo_DockerInfo::has_volume_driver,
                    ContainerInfo_DockerInfo::get_volume_driver,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo>(
                    "ContainerInfo_DockerInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.clear_network();
        self.clear_port_mappings();
        self.clear_privileged();
        self.clear_parameters();
        self.clear_force_pull_image();
        self.clear_volume_driver();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_DockerInfo {
    fn eq(&self, other: &ContainerInfo_DockerInfo) -> bool {
        self.image == other.image &&
        self.network == other.network &&
        self.port_mappings == other.port_mappings &&
        self.privileged == other.privileged &&
        self.parameters == other.parameters &&
        self.force_pull_image == other.force_pull_image &&
        self.volume_driver == other.volume_driver &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct ContainerInfo_DockerInfo_PortMapping {
    // message fields
    host_port: ::std::option::Option<u32>,
    container_port: ::std::option::Option<u32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_DockerInfo_PortMapping {}

impl ContainerInfo_DockerInfo_PortMapping {
    pub fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_DockerInfo_PortMapping {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_DockerInfo_PortMapping> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_DockerInfo_PortMapping,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_DockerInfo_PortMapping {
                    host_port: ::std::option::Option::None,
                    container_port: ::std::option::Option::None,
                    protocol: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 host_port = 1;

    pub fn clear_host_port(&mut self) {
        self.host_port = ::std::option::Option::None;
    }

    pub fn has_host_port(&self) -> bool {
        self.host_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_port(&mut self, v: u32) {
        self.host_port = ::std::option::Option::Some(v);
    }

    pub fn get_host_port<'a>(&self) -> u32 {
        self.host_port.unwrap_or(0)
    }

    // required uint32 container_port = 2;

    pub fn clear_container_port(&mut self) {
        self.container_port = ::std::option::Option::None;
    }

    pub fn has_container_port(&self) -> bool {
        self.container_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container_port(&mut self, v: u32) {
        self.container_port = ::std::option::Option::Some(v);
    }

    pub fn get_container_port<'a>(&self) -> u32 {
        self.container_port.unwrap_or(0)
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        };
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol<'a>(&'a self) -> &'a str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for ContainerInfo_DockerInfo_PortMapping {
    fn is_initialized(&self) -> bool {
        if self.host_port.is_none() {
            return false;
        };
        if self.container_port.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.host_port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.container_port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.host_port.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.container_port.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.host_port {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.container_port {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.protocol.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_DockerInfo_PortMapping>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_DockerInfo_PortMapping {
    fn new() -> ContainerInfo_DockerInfo_PortMapping {
        ContainerInfo_DockerInfo_PortMapping::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_DockerInfo_PortMapping>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "host_port",
                    ContainerInfo_DockerInfo_PortMapping::has_host_port,
                    ContainerInfo_DockerInfo_PortMapping::get_host_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "container_port",
                    ContainerInfo_DockerInfo_PortMapping::has_container_port,
                    ContainerInfo_DockerInfo_PortMapping::get_container_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "protocol",
                    ContainerInfo_DockerInfo_PortMapping::has_protocol,
                    ContainerInfo_DockerInfo_PortMapping::get_protocol,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_DockerInfo_PortMapping>(
                    "ContainerInfo_DockerInfo_PortMapping",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_DockerInfo_PortMapping {
    fn clear(&mut self) {
        self.clear_host_port();
        self.clear_container_port();
        self.clear_protocol();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_DockerInfo_PortMapping {
    fn eq(&self, other: &ContainerInfo_DockerInfo_PortMapping) -> bool {
        self.host_port == other.host_port &&
        self.container_port == other.container_port &&
        self.protocol == other.protocol &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_DockerInfo_PortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_DockerInfo_Network {
    HOST = 1,
    BRIDGE = 2,
    NONE = 3,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_DockerInfo_Network {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_DockerInfo_Network> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::HOST),
            2 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::BRIDGE),
            3 => ::std::option::Option::Some(ContainerInfo_DockerInfo_Network::NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContainerInfo_DockerInfo_Network] = &[
            ContainerInfo_DockerInfo_Network::HOST,
            ContainerInfo_DockerInfo_Network::BRIDGE,
            ContainerInfo_DockerInfo_Network::NONE,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ContainerInfo_DockerInfo_Network>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_DockerInfo_Network", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_DockerInfo_Network {
}

#[derive(Clone,Default)]
pub struct ContainerInfo_MesosInfo {
    // message fields
    image: ::protobuf::SingularPtrField<Image>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerInfo_MesosInfo {}

impl ContainerInfo_MesosInfo {
    pub fn new() -> ContainerInfo_MesosInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerInfo_MesosInfo {
        static mut instance: ::protobuf::lazy::Lazy<ContainerInfo_MesosInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerInfo_MesosInfo,
        };
        unsafe {
            instance.get(|| {
                ContainerInfo_MesosInfo {
                    image: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.Image image = 1;

    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Image) {
        self.image = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image<'a>(&'a mut self) -> &'a mut Image {
        if self.image.is_none() {
            self.image.set_default();
        };
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> Image {
        self.image.take().unwrap_or_else(|| Image::new())
    }

    pub fn get_image<'a>(&'a self) -> &'a Image {
        self.image.as_ref().unwrap_or_else(|| Image::default_instance())
    }
}

impl ::protobuf::Message for ContainerInfo_MesosInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.image));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.image.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.image.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerInfo_MesosInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerInfo_MesosInfo {
    fn new() -> ContainerInfo_MesosInfo {
        ContainerInfo_MesosInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerInfo_MesosInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "image",
                    ContainerInfo_MesosInfo::has_image,
                    ContainerInfo_MesosInfo::get_image,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerInfo_MesosInfo>(
                    "ContainerInfo_MesosInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerInfo_MesosInfo {
    fn clear(&mut self) {
        self.clear_image();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerInfo_MesosInfo {
    fn eq(&self, other: &ContainerInfo_MesosInfo) -> bool {
        self.image == other.image &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerInfo_MesosInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ContainerInfo_Type {
    DOCKER = 1,
    MESOS = 2,
}

impl ::protobuf::ProtobufEnum for ContainerInfo_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ContainerInfo_Type> {
        match value {
            1 => ::std::option::Option::Some(ContainerInfo_Type::DOCKER),
            2 => ::std::option::Option::Some(ContainerInfo_Type::MESOS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ContainerInfo_Type] = &[
            ContainerInfo_Type::DOCKER,
            ContainerInfo_Type::MESOS,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<ContainerInfo_Type>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ContainerInfo_Type", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ContainerInfo_Type {
}

#[derive(Clone,Default)]
pub struct ContainerStatus {
    // message fields
    network_infos: ::protobuf::RepeatedField<NetworkInfo>,
    cgroup_info: ::protobuf::SingularPtrField<CgroupInfo>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for ContainerStatus {}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static ContainerStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContainerStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContainerStatus,
        };
        unsafe {
            instance.get(|| {
                ContainerStatus {
                    network_infos: ::protobuf::RepeatedField::new(),
                    cgroup_info: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.NetworkInfo network_infos = 1;

    pub fn clear_network_infos(&mut self) {
        self.network_infos.clear();
    }

    // Param is passed by value, moved
    pub fn set_network_infos(&mut self, v: ::protobuf::RepeatedField<NetworkInfo>) {
        self.network_infos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network_infos<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<NetworkInfo> {
        &mut self.network_infos
    }

    // Take field
    pub fn take_network_infos(&mut self) -> ::protobuf::RepeatedField<NetworkInfo> {
        ::std::mem::replace(&mut self.network_infos, ::protobuf::RepeatedField::new())
    }

    pub fn get_network_infos<'a>(&'a self) -> &'a [NetworkInfo] {
        &self.network_infos
    }

    // optional .mesos.v1.CgroupInfo cgroup_info = 2;

    pub fn clear_cgroup_info(&mut self) {
        self.cgroup_info.clear();
    }

    pub fn has_cgroup_info(&self) -> bool {
        self.cgroup_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cgroup_info(&mut self, v: CgroupInfo) {
        self.cgroup_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cgroup_info<'a>(&'a mut self) -> &'a mut CgroupInfo {
        if self.cgroup_info.is_none() {
            self.cgroup_info.set_default();
        };
        self.cgroup_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_cgroup_info(&mut self) -> CgroupInfo {
        self.cgroup_info.take().unwrap_or_else(|| CgroupInfo::new())
    }

    pub fn get_cgroup_info<'a>(&'a self) -> &'a CgroupInfo {
        self.cgroup_info.as_ref().unwrap_or_else(|| CgroupInfo::default_instance())
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network_infos));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cgroup_info));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.network_infos.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.cgroup_info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.network_infos.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.cgroup_info.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<ContainerStatus>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for ContainerStatus {
    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<ContainerStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "network_infos",
                    ContainerStatus::get_network_infos,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "cgroup_info",
                    ContainerStatus::has_cgroup_info,
                    ContainerStatus::get_cgroup_info,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContainerStatus>(
                    "ContainerStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.clear_network_infos();
        self.clear_cgroup_info();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for ContainerStatus {
    fn eq(&self, other: &ContainerStatus) -> bool {
        self.network_infos == other.network_infos &&
        self.cgroup_info == other.cgroup_info &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CgroupInfo {
    // message fields
    net_cls: ::protobuf::SingularPtrField<CgroupInfo_NetCls>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo {}

impl CgroupInfo {
    pub fn new() -> CgroupInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo,
        };
        unsafe {
            instance.get(|| {
                CgroupInfo {
                    net_cls: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .mesos.v1.CgroupInfo.NetCls net_cls = 1;

    pub fn clear_net_cls(&mut self) {
        self.net_cls.clear();
    }

    pub fn has_net_cls(&self) -> bool {
        self.net_cls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_cls(&mut self, v: CgroupInfo_NetCls) {
        self.net_cls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_cls<'a>(&'a mut self) -> &'a mut CgroupInfo_NetCls {
        if self.net_cls.is_none() {
            self.net_cls.set_default();
        };
        self.net_cls.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_cls(&mut self) -> CgroupInfo_NetCls {
        self.net_cls.take().unwrap_or_else(|| CgroupInfo_NetCls::new())
    }

    pub fn get_net_cls<'a>(&'a self) -> &'a CgroupInfo_NetCls {
        self.net_cls.as_ref().unwrap_or_else(|| CgroupInfo_NetCls::default_instance())
    }
}

impl ::protobuf::Message for CgroupInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.net_cls));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.net_cls.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.net_cls.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CgroupInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo {
    fn new() -> CgroupInfo {
        CgroupInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "net_cls",
                    CgroupInfo::has_net_cls,
                    CgroupInfo::get_net_cls,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo>(
                    "CgroupInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo {
    fn clear(&mut self) {
        self.clear_net_cls();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CgroupInfo {
    fn eq(&self, other: &CgroupInfo) -> bool {
        self.net_cls == other.net_cls &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CgroupInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CgroupInfo_NetCls {
    // message fields
    classid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CgroupInfo_NetCls {}

impl CgroupInfo_NetCls {
    pub fn new() -> CgroupInfo_NetCls {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CgroupInfo_NetCls {
        static mut instance: ::protobuf::lazy::Lazy<CgroupInfo_NetCls> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CgroupInfo_NetCls,
        };
        unsafe {
            instance.get(|| {
                CgroupInfo_NetCls {
                    classid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 classid = 1;

    pub fn clear_classid(&mut self) {
        self.classid = ::std::option::Option::None;
    }

    pub fn has_classid(&self) -> bool {
        self.classid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classid(&mut self, v: u32) {
        self.classid = ::std::option::Option::Some(v);
    }

    pub fn get_classid<'a>(&self) -> u32 {
        self.classid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CgroupInfo_NetCls {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.classid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.classid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.classid {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CgroupInfo_NetCls>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CgroupInfo_NetCls {
    fn new() -> CgroupInfo_NetCls {
        CgroupInfo_NetCls::new()
    }

    fn descriptor_static(_: ::std::option::Option<CgroupInfo_NetCls>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "classid",
                    CgroupInfo_NetCls::has_classid,
                    CgroupInfo_NetCls::get_classid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CgroupInfo_NetCls>(
                    "CgroupInfo_NetCls",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CgroupInfo_NetCls {
    fn clear(&mut self) {
        self.clear_classid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CgroupInfo_NetCls {
    fn eq(&self, other: &CgroupInfo_NetCls) -> bool {
        self.classid == other.classid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CgroupInfo_NetCls {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Labels {
    // message fields
    labels: ::protobuf::RepeatedField<Label>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Labels {}

impl Labels {
    pub fn new() -> Labels {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Labels {
        static mut instance: ::protobuf::lazy::Lazy<Labels> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Labels,
        };
        unsafe {
            instance.get(|| {
                Labels {
                    labels: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Label labels = 1;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::protobuf::RepeatedField<Label>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Label> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::protobuf::RepeatedField<Label> {
        ::std::mem::replace(&mut self.labels, ::protobuf::RepeatedField::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a [Label] {
        &self.labels
    }
}

impl ::protobuf::Message for Labels {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.labels.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Labels>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Labels {
    fn new() -> Labels {
        Labels::new()
    }

    fn descriptor_static(_: ::std::option::Option<Labels>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "labels",
                    Labels::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Labels>(
                    "Labels",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Labels {
    fn clear(&mut self) {
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Labels {
    fn eq(&self, other: &Labels) -> bool {
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Labels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Label {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Label {}

impl Label {
    pub fn new() -> Label {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Label {
        static mut instance: ::protobuf::lazy::Lazy<Label> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Label,
        };
        unsafe {
            instance.get(|| {
                Label {
                    key: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for Label {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Label>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Label {
    fn new() -> Label {
        Label::new()
    }

    fn descriptor_static(_: ::std::option::Option<Label>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "key",
                    Label::has_key,
                    Label::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    Label::has_value,
                    Label::get_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Label>(
                    "Label",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Label {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Label {
    fn eq(&self, other: &Label) -> bool {
        self.key == other.key &&
        self.value == other.value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Label {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Port {
    // message fields
    number: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    visibility: ::std::option::Option<DiscoveryInfo_Visibility>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Port {}

impl Port {
    pub fn new() -> Port {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Port {
        static mut instance: ::protobuf::lazy::Lazy<Port> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Port,
        };
        unsafe {
            instance.get(|| {
                Port {
                    number: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    protocol: ::protobuf::SingularField::none(),
                    visibility: ::std::option::Option::None,
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required uint32 number = 1;

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: u32) {
        self.number = ::std::option::Option::Some(v);
    }

    pub fn get_number<'a>(&self) -> u32 {
        self.number.unwrap_or(0)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string protocol = 3;

    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        };
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_protocol<'a>(&'a self) -> &'a str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.DiscoveryInfo.Visibility visibility = 4;

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: DiscoveryInfo_Visibility) {
        self.visibility = ::std::option::Option::Some(v);
    }

    pub fn get_visibility<'a>(&self) -> DiscoveryInfo_Visibility {
        self.visibility.unwrap_or(DiscoveryInfo_Visibility::FRAMEWORK)
    }

    // optional .mesos.v1.Labels labels = 5;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for Port {
    fn is_initialized(&self) -> bool {
        if self.number.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.protocol.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.visibility.iter() {
            my_size += ::protobuf::rt::enum_size(4, *value);
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.number {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.protocol.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.visibility {
            try!(os.write_enum(4, v.value()));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Port>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Port {
    fn new() -> Port {
        Port::new()
    }

    fn descriptor_static(_: ::std::option::Option<Port>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "number",
                    Port::has_number,
                    Port::get_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    Port::has_name,
                    Port::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "protocol",
                    Port::has_protocol,
                    Port::get_protocol,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "visibility",
                    Port::has_visibility,
                    Port::get_visibility,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    Port::has_labels,
                    Port::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Port>(
                    "Port",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Port {
    fn clear(&mut self) {
        self.clear_number();
        self.clear_name();
        self.clear_protocol();
        self.clear_visibility();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Port {
    fn eq(&self, other: &Port) -> bool {
        self.number == other.number &&
        self.name == other.name &&
        self.protocol == other.protocol &&
        self.visibility == other.visibility &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Port {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct Ports {
    // message fields
    ports: ::protobuf::RepeatedField<Port>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for Ports {}

impl Ports {
    pub fn new() -> Ports {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static Ports {
        static mut instance: ::protobuf::lazy::Lazy<Ports> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Ports,
        };
        unsafe {
            instance.get(|| {
                Ports {
                    ports: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .mesos.v1.Port ports = 1;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<Port>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<Port> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<Port> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    pub fn get_ports<'a>(&'a self) -> &'a [Port] {
        &self.ports
    }
}

impl ::protobuf::Message for Ports {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.ports.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<Ports>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for Ports {
    fn new() -> Ports {
        Ports::new()
    }

    fn descriptor_static(_: ::std::option::Option<Ports>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "ports",
                    Ports::get_ports,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Ports>(
                    "Ports",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for Ports {
    fn clear(&mut self) {
        self.clear_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for Ports {
    fn eq(&self, other: &Ports) -> bool {
        self.ports == other.ports &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for Ports {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct DiscoveryInfo {
    // message fields
    visibility: ::std::option::Option<DiscoveryInfo_Visibility>,
    name: ::protobuf::SingularField<::std::string::String>,
    environment: ::protobuf::SingularField<::std::string::String>,
    location: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    ports: ::protobuf::SingularPtrField<Ports>,
    labels: ::protobuf::SingularPtrField<Labels>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for DiscoveryInfo {}

impl DiscoveryInfo {
    pub fn new() -> DiscoveryInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static DiscoveryInfo {
        static mut instance: ::protobuf::lazy::Lazy<DiscoveryInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DiscoveryInfo,
        };
        unsafe {
            instance.get(|| {
                DiscoveryInfo {
                    visibility: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    environment: ::protobuf::SingularField::none(),
                    location: ::protobuf::SingularField::none(),
                    version: ::protobuf::SingularField::none(),
                    ports: ::protobuf::SingularPtrField::none(),
                    labels: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required .mesos.v1.DiscoveryInfo.Visibility visibility = 1;

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: DiscoveryInfo_Visibility) {
        self.visibility = ::std::option::Option::Some(v);
    }

    pub fn get_visibility<'a>(&self) -> DiscoveryInfo_Visibility {
        self.visibility.unwrap_or(DiscoveryInfo_Visibility::FRAMEWORK)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string environment = 3;

    pub fn clear_environment(&mut self) {
        self.environment.clear();
    }

    pub fn has_environment(&self) -> bool {
        self.environment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_environment(&mut self, v: ::std::string::String) {
        self.environment = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_environment<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.environment.is_none() {
            self.environment.set_default();
        };
        self.environment.as_mut().unwrap()
    }

    // Take field
    pub fn take_environment(&mut self) -> ::std::string::String {
        self.environment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_environment<'a>(&'a self) -> &'a str {
        match self.environment.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string location = 4;

    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.location.is_none() {
            self.location.set_default();
        };
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        self.location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_location<'a>(&'a self) -> &'a str {
        match self.location.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string version = 5;

    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        };
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_version<'a>(&'a self) -> &'a str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional .mesos.v1.Ports ports = 6;

    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    pub fn has_ports(&self) -> bool {
        self.ports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: Ports) {
        self.ports = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ports<'a>(&'a mut self) -> &'a mut Ports {
        if self.ports.is_none() {
            self.ports.set_default();
        };
        self.ports.as_mut().unwrap()
    }

    // Take field
    pub fn take_ports(&mut self) -> Ports {
        self.ports.take().unwrap_or_else(|| Ports::new())
    }

    pub fn get_ports<'a>(&'a self) -> &'a Ports {
        self.ports.as_ref().unwrap_or_else(|| Ports::default_instance())
    }

    // optional .mesos.v1.Labels labels = 7;

    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    pub fn has_labels(&self) -> bool {
        self.labels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: Labels) {
        self.labels = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labels<'a>(&'a mut self) -> &'a mut Labels {
        if self.labels.is_none() {
            self.labels.set_default();
        };
        self.labels.as_mut().unwrap()
    }

    // Take field
    pub fn take_labels(&mut self) -> Labels {
        self.labels.take().unwrap_or_else(|| Labels::new())
    }

    pub fn get_labels<'a>(&'a self) -> &'a Labels {
        self.labels.as_ref().unwrap_or_else(|| Labels::default_instance())
    }
}

impl ::protobuf::Message for DiscoveryInfo {
    fn is_initialized(&self) -> bool {
        if self.visibility.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_enum());
                    self.visibility = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.environment));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.location));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ports));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labels));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.visibility.iter() {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.environment.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.location.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.version.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.ports.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.labels.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.visibility {
            try!(os.write_enum(1, v.value()));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.environment.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.location.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.version.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.ports.as_ref() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.labels.as_ref() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<DiscoveryInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for DiscoveryInfo {
    fn new() -> DiscoveryInfo {
        DiscoveryInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<DiscoveryInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor(
                    "visibility",
                    DiscoveryInfo::has_visibility,
                    DiscoveryInfo::get_visibility,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    DiscoveryInfo::has_name,
                    DiscoveryInfo::get_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "environment",
                    DiscoveryInfo::has_environment,
                    DiscoveryInfo::get_environment,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "location",
                    DiscoveryInfo::has_location,
                    DiscoveryInfo::get_location,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "version",
                    DiscoveryInfo::has_version,
                    DiscoveryInfo::get_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "ports",
                    DiscoveryInfo::has_ports,
                    DiscoveryInfo::get_ports,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "labels",
                    DiscoveryInfo::has_labels,
                    DiscoveryInfo::get_labels,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DiscoveryInfo>(
                    "DiscoveryInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for DiscoveryInfo {
    fn clear(&mut self) {
        self.clear_visibility();
        self.clear_name();
        self.clear_environment();
        self.clear_location();
        self.clear_version();
        self.clear_ports();
        self.clear_labels();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for DiscoveryInfo {
    fn eq(&self, other: &DiscoveryInfo) -> bool {
        self.visibility == other.visibility &&
        self.name == other.name &&
        self.environment == other.environment &&
        self.location == other.location &&
        self.version == other.version &&
        self.ports == other.ports &&
        self.labels == other.labels &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for DiscoveryInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DiscoveryInfo_Visibility {
    FRAMEWORK = 0,
    CLUSTER = 1,
    EXTERNAL = 2,
}

impl ::protobuf::ProtobufEnum for DiscoveryInfo_Visibility {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DiscoveryInfo_Visibility> {
        match value {
            0 => ::std::option::Option::Some(DiscoveryInfo_Visibility::FRAMEWORK),
            1 => ::std::option::Option::Some(DiscoveryInfo_Visibility::CLUSTER),
            2 => ::std::option::Option::Some(DiscoveryInfo_Visibility::EXTERNAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DiscoveryInfo_Visibility] = &[
            DiscoveryInfo_Visibility::FRAMEWORK,
            DiscoveryInfo_Visibility::CLUSTER,
            DiscoveryInfo_Visibility::EXTERNAL,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<DiscoveryInfo_Visibility>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("DiscoveryInfo_Visibility", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for DiscoveryInfo_Visibility {
}

#[derive(Clone,Default)]
pub struct WeightInfo {
    // message fields
    weight: ::std::option::Option<f64>,
    role: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for WeightInfo {}

impl WeightInfo {
    pub fn new() -> WeightInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static WeightInfo {
        static mut instance: ::protobuf::lazy::Lazy<WeightInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const WeightInfo,
        };
        unsafe {
            instance.get(|| {
                WeightInfo {
                    weight: ::std::option::Option::None,
                    role: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // required double weight = 1;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: f64) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight<'a>(&self) -> f64 {
        self.weight.unwrap_or(0.)
    }

    // optional string role = 2;

    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        };
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_role<'a>(&'a self) -> &'a str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for WeightInfo {
    fn is_initialized(&self) -> bool {
        if self.weight.is_none() {
            return false;
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_double());
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.weight.is_some() {
            my_size += 9;
        };
        for value in self.role.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            try!(os.write_double(1, v));
        };
        if let Some(v) = self.role.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<WeightInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for WeightInfo {
    fn new() -> WeightInfo {
        WeightInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<WeightInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor(
                    "weight",
                    WeightInfo::has_weight,
                    WeightInfo::get_weight,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "role",
                    WeightInfo::has_role,
                    WeightInfo::get_role,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<WeightInfo>(
                    "WeightInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for WeightInfo {
    fn clear(&mut self) {
        self.clear_weight();
        self.clear_role();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for WeightInfo {
    fn eq(&self, other: &WeightInfo) -> bool {
        self.weight == other.weight &&
        self.role == other.role &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for WeightInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Status {
    DRIVER_NOT_STARTED = 1,
    DRIVER_RUNNING = 2,
    DRIVER_ABORTED = 3,
    DRIVER_STOPPED = 4,
}

impl ::protobuf::ProtobufEnum for Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Status> {
        match value {
            1 => ::std::option::Option::Some(Status::DRIVER_NOT_STARTED),
            2 => ::std::option::Option::Some(Status::DRIVER_RUNNING),
            3 => ::std::option::Option::Some(Status::DRIVER_ABORTED),
            4 => ::std::option::Option::Some(Status::DRIVER_STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Status] = &[
            Status::DRIVER_NOT_STARTED,
            Status::DRIVER_RUNNING,
            Status::DRIVER_ABORTED,
            Status::DRIVER_STOPPED,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<Status>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Status", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Status {
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TaskState {
    TASK_STAGING = 6,
    TASK_STARTING = 0,
    TASK_RUNNING = 1,
    TASK_KILLING = 8,
    TASK_FINISHED = 2,
    TASK_FAILED = 3,
    TASK_KILLED = 4,
    TASK_LOST = 5,
    TASK_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for TaskState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TaskState> {
        match value {
            6 => ::std::option::Option::Some(TaskState::TASK_STAGING),
            0 => ::std::option::Option::Some(TaskState::TASK_STARTING),
            1 => ::std::option::Option::Some(TaskState::TASK_RUNNING),
            8 => ::std::option::Option::Some(TaskState::TASK_KILLING),
            2 => ::std::option::Option::Some(TaskState::TASK_FINISHED),
            3 => ::std::option::Option::Some(TaskState::TASK_FAILED),
            4 => ::std::option::Option::Some(TaskState::TASK_KILLED),
            5 => ::std::option::Option::Some(TaskState::TASK_LOST),
            7 => ::std::option::Option::Some(TaskState::TASK_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TaskState] = &[
            TaskState::TASK_STAGING,
            TaskState::TASK_STARTING,
            TaskState::TASK_RUNNING,
            TaskState::TASK_KILLING,
            TaskState::TASK_FINISHED,
            TaskState::TASK_FAILED,
            TaskState::TASK_KILLED,
            TaskState::TASK_LOST,
            TaskState::TASK_ERROR,
        ];
        values
    }

    fn enum_descriptor_static(_: Option<TaskState>) -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("TaskState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TaskState {
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x1a, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2f, 0x76, 0x31,
    0x2f, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x08, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x22, 0x1c, 0x0a, 0x0b, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x09, 0x22, 0x18, 0x0a, 0x07, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12,
    0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x18,
    0x0a, 0x07, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x17, 0x0a, 0x06, 0x54, 0x61, 0x73, 0x6b,
    0x49, 0x44, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28,
    0x09, 0x22, 0x1b, 0x0a, 0x0a, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12,
    0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1c,
    0x0a, 0x0b, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x44, 0x12, 0x0d, 0x0a,
    0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1f, 0x0a, 0x08,
    0x54, 0x69, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x61, 0x6e, 0x6f,
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x03, 0x22, 0x23, 0x0a,
    0x0c, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x13, 0x0a,
    0x0b, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x03, 0x22, 0x35, 0x0a, 0x07, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x10, 0x0a,
    0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x70,
    0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28, 0x05, 0x22, 0x7d, 0x0a, 0x03, 0x55, 0x52, 0x4c,
    0x12, 0x0e, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x22, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x02, 0x28,
    0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x22, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x72,
    0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x72, 0x61, 0x67, 0x6d, 0x65,
    0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x22, 0x5d, 0x0a, 0x0e, 0x55, 0x6e, 0x61, 0x76,
    0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x21, 0x0a, 0x05, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x28, 0x0a,
    0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x29, 0x0a, 0x09, 0x4d, 0x61, 0x63, 0x68, 0x69,
    0x6e, 0x65, 0x49, 0x44, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x09, 0x22, 0xb2, 0x01, 0x0a, 0x0b, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x6e,
    0x66, 0x6f, 0x12, 0x1f, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x13,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e,
    0x65, 0x49, 0x44, 0x12, 0x28, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0e, 0x32, 0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63,
    0x68, 0x69, 0x6e, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x30, 0x0a,
    0x0e, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x22,
    0x26, 0x0a, 0x04, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x06, 0x0a, 0x02, 0x55, 0x50, 0x10, 0x01, 0x12,
    0x0c, 0x0a, 0x08, 0x44, 0x52, 0x41, 0x49, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x08, 0x0a,
    0x04, 0x44, 0x4f, 0x57, 0x4e, 0x10, 0x03, 0x22, 0xb7, 0x03, 0x0a, 0x0d, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x75, 0x73, 0x65,
    0x72, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x21, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x1b, 0x0a, 0x10, 0x66, 0x61, 0x69, 0x6c,
    0x6f, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x01, 0x3a, 0x01, 0x30, 0x12, 0x19, 0x0a, 0x0a, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f,
    0x69, 0x6e, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65,
    0x12, 0x0f, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x3a, 0x01,
    0x2a, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x77, 0x65, 0x62, 0x75, 0x69, 0x5f,
    0x75, 0x72, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x38, 0x0a, 0x0c, 0x63, 0x61, 0x70,
    0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x0b, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
    0x61, 0x62, 0x65, 0x6c, 0x73, 0x1a, 0x89, 0x01, 0x0a, 0x0a, 0x43, 0x61, 0x70, 0x61, 0x62, 0x69,
    0x6c, 0x69, 0x74, 0x79, 0x12, 0x35, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0e, 0x32, 0x27, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x43, 0x61, 0x70, 0x61,
    0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x22, 0x44, 0x0a, 0x04, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x00,
    0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x56, 0x4f, 0x43, 0x41, 0x42, 0x4c, 0x45, 0x5f, 0x52, 0x45,
    0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x53, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x54, 0x41, 0x53,
    0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x49, 0x4e, 0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x10,
    0x02, 0x22, 0xb1, 0x02, 0x0a, 0x0b, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63,
    0x6b, 0x12, 0x28, 0x0a, 0x04, 0x68, 0x74, 0x74, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x1a, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x65, 0x61, 0x6c, 0x74,
    0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x48, 0x54, 0x54, 0x50, 0x12, 0x19, 0x0a, 0x0d, 0x64,
    0x65, 0x6c, 0x61, 0x79, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x01, 0x3a, 0x02, 0x31, 0x35, 0x12, 0x1c, 0x0a, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76,
    0x61, 0x6c, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01,
    0x3a, 0x02, 0x31, 0x30, 0x12, 0x1b, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x5f,
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x02, 0x32,
    0x30, 0x12, 0x1f, 0x0a, 0x14, 0x63, 0x6f, 0x6e, 0x73, 0x65, 0x63, 0x75, 0x74, 0x69, 0x76, 0x65,
    0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x3a,
    0x01, 0x33, 0x12, 0x20, 0x0a, 0x14, 0x67, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x70, 0x65, 0x72, 0x69,
    0x6f, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01,
    0x3a, 0x02, 0x31, 0x30, 0x12, 0x26, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x1a, 0x37, 0x0a, 0x04,
    0x48, 0x54, 0x54, 0x50, 0x12, 0x0c, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
    0x3a, 0x01, 0x2f, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x18,
    0x04, 0x20, 0x03, 0x28, 0x0d, 0x22, 0xf7, 0x01, 0x0a, 0x0b, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x27, 0x0a, 0x04, 0x75, 0x72, 0x69, 0x73, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x55, 0x52, 0x49, 0x12, 0x2a,
    0x0a, 0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45,
    0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x13, 0x0a, 0x05, 0x73, 0x68,
    0x65, 0x6c, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65, 0x12,
    0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11,
    0x0a, 0x09, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28,
    0x09, 0x12, 0x0c, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x1a,
    0x4e, 0x0a, 0x03, 0x55, 0x52, 0x49, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61,
    0x62, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x15, 0x0a, 0x07, 0x65, 0x78, 0x74,
    0x72, 0x61, 0x63, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x04, 0x74, 0x72, 0x75, 0x65,
    0x12, 0x0d, 0x0a, 0x05, 0x63, 0x61, 0x63, 0x68, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x22,
    0xb9, 0x02, 0x0a, 0x0c, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x29, 0x0a, 0x0b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x2b, 0x0a, 0x0c, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x26, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x2a, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x18, 0x0b, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x25, 0x0a, 0x09,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x2a, 0x0a, 0x09, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x18, 0x0c, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69,
    0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x8c, 0x01, 0x0a, 0x0a,
    0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x70, 0x18, 0x02, 0x20, 0x02,
    0x28, 0x0d, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0d,
    0x3a, 0x04, 0x35, 0x30, 0x35, 0x30, 0x12, 0x0b, 0x0a, 0x03, 0x70, 0x69, 0x64, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x22, 0x0a, 0x07, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x22, 0xa0, 0x01, 0x0a, 0x09, 0x41,
    0x67, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74,
    0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f,
    0x72, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x04, 0x35, 0x30, 0x35, 0x31, 0x12, 0x25,
    0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x27, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75,
    0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x12, 0x1d,
    0x0a, 0x02, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x22, 0x8e, 0x03,
    0x0a, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x22, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x26, 0x0a, 0x06, 0x73,
    0x63, 0x61, 0x6c, 0x61, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x63, 0x61,
    0x6c, 0x61, 0x72, 0x12, 0x26, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56,
    0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x03, 0x73,
    0x65, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x65, 0x74, 0x12, 0x22, 0x0a,
    0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x65, 0x78,
    0x74, 0x1a, 0x17, 0x0a, 0x06, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x0d, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x01, 0x1a, 0x23, 0x0a, 0x05, 0x52, 0x61,
    0x6e, 0x67, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x62, 0x65, 0x67, 0x69, 0x6e, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x04, 0x12, 0x0b, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x04, 0x1a,
    0x2e, 0x0a, 0x06, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x24, 0x0a, 0x05, 0x72, 0x61, 0x6e,
    0x67, 0x65, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x1a,
    0x13, 0x0a, 0x03, 0x53, 0x65, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x69, 0x74, 0x65, 0x6d, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x09, 0x1a, 0x15, 0x0a, 0x04, 0x54, 0x65, 0x78, 0x74, 0x12, 0x0d, 0x0a, 0x05,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x31, 0x0a, 0x04, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x43, 0x41, 0x4c, 0x41, 0x52, 0x10, 0x00, 0x12,
    0x0a, 0x0a, 0x06, 0x52, 0x41, 0x4e, 0x47, 0x45, 0x53, 0x10, 0x01, 0x12, 0x07, 0x0a, 0x03, 0x53,
    0x45, 0x54, 0x10, 0x02, 0x12, 0x08, 0x0a, 0x04, 0x54, 0x45, 0x58, 0x54, 0x10, 0x03, 0x22, 0xd3,
    0x01, 0x0a, 0x09, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x12, 0x0c, 0x0a, 0x04,
    0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x22, 0x0a, 0x04, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x26,
    0x0a, 0x06, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e,
    0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x26, 0x0a, 0x06, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x20,
    0x0a, 0x03, 0x73, 0x65, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x65, 0x74,
    0x12, 0x22, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e,
    0x54, 0x65, 0x78, 0x74, 0x22, 0xfc, 0x06, 0x0a, 0x08, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x22, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x26, 0x0a, 0x06, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56,
    0x61, 0x6c, 0x75, 0x65, 0x2e, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x12, 0x26, 0x0a, 0x06, 0x72,
    0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x52, 0x61, 0x6e,
    0x67, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x03, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x61, 0x6c, 0x75,
    0x65, 0x2e, 0x53, 0x65, 0x74, 0x12, 0x0f, 0x0a, 0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x09, 0x3a, 0x01, 0x2a, 0x12, 0x37, 0x0a, 0x0b, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e,
    0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x29, 0x0a, 0x04, 0x64, 0x69, 0x73, 0x6b, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x33, 0x0a, 0x09, 0x72, 0x65,
    0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x2e, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x1a,
    0x46, 0x0a, 0x0f, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e,
    0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x1a, 0xc8, 0x03, 0x0a, 0x08, 0x44, 0x69, 0x73, 0x6b,
    0x49, 0x6e, 0x66, 0x6f, 0x12, 0x3c, 0x0a, 0x0b, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65,
    0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x44, 0x69,
    0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x50, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e,
    0x63, 0x65, 0x12, 0x20, 0x0a, 0x06, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x6f,
    0x6c, 0x75, 0x6d, 0x65, 0x12, 0x32, 0x0a, 0x06, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49, 0x6e, 0x66,
    0x6f, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0x2c, 0x0a, 0x0b, 0x50, 0x65, 0x72, 0x73,
    0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x1a, 0xf9, 0x01, 0x0a, 0x06, 0x53, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x12, 0x35, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32,
    0x27, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x53, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x35, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x50, 0x61, 0x74, 0x68, 0x12,
    0x37, 0x0a, 0x05, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x28,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x2e, 0x44, 0x69, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x53, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x2e, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x1a, 0x14, 0x0a, 0x04, 0x50, 0x61, 0x74, 0x68,
    0x12, 0x0c, 0x0a, 0x04, 0x72, 0x6f, 0x6f, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x1a, 0x15,
    0x0a, 0x05, 0x4d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x0c, 0x0a, 0x04, 0x72, 0x6f, 0x6f, 0x74, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x22, 0x1b, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a,
    0x04, 0x50, 0x41, 0x54, 0x48, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x4d, 0x4f, 0x55, 0x4e, 0x54,
    0x10, 0x02, 0x1a, 0x0f, 0x0a, 0x0d, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x49,
    0x6e, 0x66, 0x6f, 0x22, 0xbc, 0x01, 0x0a, 0x18, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x43,
    0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07,
    0x62, 0x61, 0x63, 0x6b, 0x6c, 0x6f, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0d, 0x0a,
    0x05, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0d, 0x0a, 0x05,
    0x64, 0x72, 0x6f, 0x70, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6f,
    0x76, 0x65, 0x72, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x0f, 0x0a, 0x07, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x0c, 0x0a, 0x04, 0x71, 0x6c, 0x65, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0f,
    0x0a, 0x07, 0x72, 0x61, 0x74, 0x65, 0x62, 0x70, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x0f, 0x0a, 0x07, 0x72, 0x61, 0x74, 0x65, 0x70, 0x70, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x10, 0x0a, 0x08, 0x72, 0x65, 0x71, 0x75, 0x65, 0x75, 0x65, 0x73, 0x18, 0x0a, 0x20, 0x01,
    0x28, 0x04, 0x22, 0x95, 0x03, 0x0a, 0x0c, 0x49, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74,
    0x69, 0x63, 0x73, 0x12, 0x12, 0x0a, 0x0a, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x69, 0x6e,
    0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a, 0x44, 0x65, 0x66, 0x61, 0x75,
    0x6c, 0x74, 0x54, 0x54, 0x4c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a, 0x49,
    0x6e, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x12,
    0x13, 0x0a, 0x0b, 0x49, 0x6e, 0x48, 0x64, 0x72, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49, 0x6e, 0x41, 0x64, 0x64, 0x72, 0x45, 0x72,
    0x72, 0x6f, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x12, 0x15, 0x0a, 0x0d, 0x46, 0x6f,
    0x72, 0x77, 0x44, 0x61, 0x74, 0x61, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x17, 0x0a, 0x0f, 0x49, 0x6e, 0x55, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x50, 0x72,
    0x6f, 0x74, 0x6f, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a, 0x49, 0x6e,
    0x44, 0x69, 0x73, 0x63, 0x61, 0x72, 0x64, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12,
    0x0a, 0x0a, 0x49, 0x6e, 0x44, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x73, 0x18, 0x09, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x4f, 0x75, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x4f, 0x75, 0x74, 0x44, 0x69,
    0x73, 0x63, 0x61, 0x72, 0x64, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b,
    0x4f, 0x75, 0x74, 0x4e, 0x6f, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x14, 0x0a, 0x0c, 0x52, 0x65, 0x61, 0x73, 0x6d, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75,
    0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a, 0x52, 0x65, 0x61, 0x73, 0x6d,
    0x52, 0x65, 0x71, 0x64, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x08, 0x52,
    0x65, 0x61, 0x73, 0x6d, 0x4f, 0x4b, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x03, 0x12, 0x12, 0x0a,
    0x0a, 0x52, 0x65, 0x61, 0x73, 0x6d, 0x46, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x0f, 0x0a, 0x07, 0x46, 0x72, 0x61, 0x67, 0x4f, 0x4b, 0x73, 0x18, 0x11, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x11, 0x0a, 0x09, 0x46, 0x72, 0x61, 0x67, 0x46, 0x61, 0x69, 0x6c, 0x73, 0x18,
    0x12, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x46, 0x72, 0x61, 0x67, 0x43, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x03, 0x22, 0xd3, 0x04, 0x0a, 0x0e, 0x49,
    0x63, 0x6d, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x0e, 0x0a,
    0x06, 0x49, 0x6e, 0x4d, 0x73, 0x67, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x10, 0x0a,
    0x08, 0x49, 0x6e, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x12,
    0x14, 0x0a, 0x0c, 0x49, 0x6e, 0x43, 0x73, 0x75, 0x6d, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x03, 0x12, 0x16, 0x0a, 0x0e, 0x49, 0x6e, 0x44, 0x65, 0x73, 0x74, 0x55,
    0x6e, 0x72, 0x65, 0x61, 0x63, 0x68, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a,
    0x0b, 0x49, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x45, 0x78, 0x63, 0x64, 0x73, 0x18, 0x05, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x49, 0x6e, 0x50, 0x61, 0x72, 0x6d, 0x50, 0x72, 0x6f, 0x62,
    0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49, 0x6e, 0x53, 0x72, 0x63,
    0x51, 0x75, 0x65, 0x6e, 0x63, 0x68, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a,
    0x0b, 0x49, 0x6e, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x73, 0x18, 0x08, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x49, 0x6e, 0x45, 0x63, 0x68, 0x6f, 0x73, 0x18, 0x09, 0x20,
    0x01, 0x28, 0x03, 0x12, 0x12, 0x0a, 0x0a, 0x49, 0x6e, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x70,
    0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49, 0x6e, 0x54, 0x69, 0x6d,
    0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x03, 0x12, 0x17, 0x0a,
    0x0f, 0x49, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x65, 0x70, 0x73,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x49, 0x6e, 0x41, 0x64, 0x64, 0x72,
    0x4d, 0x61, 0x73, 0x6b, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x12, 0x16, 0x0a, 0x0e, 0x49,
    0x6e, 0x41, 0x64, 0x64, 0x72, 0x4d, 0x61, 0x73, 0x6b, 0x52, 0x65, 0x70, 0x73, 0x18, 0x0e, 0x20,
    0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x4f, 0x75, 0x74, 0x4d, 0x73, 0x67, 0x73, 0x18, 0x0f,
    0x20, 0x01, 0x28, 0x03, 0x12, 0x11, 0x0a, 0x09, 0x4f, 0x75, 0x74, 0x45, 0x72, 0x72, 0x6f, 0x72,
    0x73, 0x18, 0x10, 0x20, 0x01, 0x28, 0x03, 0x12, 0x17, 0x0a, 0x0f, 0x4f, 0x75, 0x74, 0x44, 0x65,
    0x73, 0x74, 0x55, 0x6e, 0x72, 0x65, 0x61, 0x63, 0x68, 0x73, 0x18, 0x11, 0x20, 0x01, 0x28, 0x03,
    0x12, 0x14, 0x0a, 0x0c, 0x4f, 0x75, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x45, 0x78, 0x63, 0x64, 0x73,
    0x18, 0x12, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x4f, 0x75, 0x74, 0x50, 0x61, 0x72,
    0x6d, 0x50, 0x72, 0x6f, 0x62, 0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x03, 0x12, 0x15, 0x0a, 0x0d,
    0x4f, 0x75, 0x74, 0x53, 0x72, 0x63, 0x51, 0x75, 0x65, 0x6e, 0x63, 0x68, 0x73, 0x18, 0x14, 0x20,
    0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x4f, 0x75, 0x74, 0x52, 0x65, 0x64, 0x69, 0x72, 0x65,
    0x63, 0x74, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x08, 0x4f, 0x75, 0x74,
    0x45, 0x63, 0x68, 0x6f, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x4f,
    0x75, 0x74, 0x45, 0x63, 0x68, 0x6f, 0x52, 0x65, 0x70, 0x73, 0x18, 0x17, 0x20, 0x01, 0x28, 0x03,
    0x12, 0x15, 0x0a, 0x0d, 0x4f, 0x75, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
    0x73, 0x18, 0x18, 0x20, 0x01, 0x28, 0x03, 0x12, 0x18, 0x0a, 0x10, 0x4f, 0x75, 0x74, 0x54, 0x69,
    0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x65, 0x70, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x14, 0x0a, 0x0c, 0x4f, 0x75, 0x74, 0x41, 0x64, 0x64, 0x72, 0x4d, 0x61, 0x73, 0x6b,
    0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x03, 0x12, 0x17, 0x0a, 0x0f, 0x4f, 0x75, 0x74, 0x41, 0x64,
    0x64, 0x72, 0x4d, 0x61, 0x73, 0x6b, 0x52, 0x65, 0x70, 0x73, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x03,
    0x22, 0xac, 0x02, 0x0a, 0x0d, 0x54, 0x63, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69,
    0x63, 0x73, 0x12, 0x14, 0x0a, 0x0c, 0x52, 0x74, 0x6f, 0x41, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74,
    0x68, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0e, 0x0a, 0x06, 0x52, 0x74, 0x6f, 0x4d,
    0x69, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0e, 0x0a, 0x06, 0x52, 0x74, 0x6f, 0x4d,
    0x61, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x4d, 0x61, 0x78, 0x43,
    0x6f, 0x6e, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x41, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x4f, 0x70, 0x65, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14,
    0x0a, 0x0c, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x4f, 0x70, 0x65, 0x6e, 0x73, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x41, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x46,
    0x61, 0x69, 0x6c, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x45, 0x73,
    0x74, 0x61, 0x62, 0x52, 0x65, 0x73, 0x65, 0x74, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x12,
    0x11, 0x0a, 0x09, 0x43, 0x75, 0x72, 0x72, 0x45, 0x73, 0x74, 0x61, 0x62, 0x18, 0x09, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x0e, 0x0a, 0x06, 0x49, 0x6e, 0x53, 0x65, 0x67, 0x73, 0x18, 0x0a, 0x20, 0x01,
    0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x4f, 0x75, 0x74, 0x53, 0x65, 0x67, 0x73, 0x18, 0x0b, 0x20,
    0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x52, 0x65, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x53, 0x65,
    0x67, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0e, 0x0a, 0x06, 0x49, 0x6e, 0x45, 0x72,
    0x72, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x4f, 0x75, 0x74, 0x52,
    0x73, 0x74, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49, 0x6e, 0x43,
    0x73, 0x75, 0x6d, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x03, 0x22,
    0xb5, 0x01, 0x0a, 0x0d, 0x55, 0x64, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63,
    0x73, 0x12, 0x13, 0x0a, 0x0b, 0x49, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x67, 0x72, 0x61, 0x6d, 0x73,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x03, 0x12, 0x0f, 0x0a, 0x07, 0x4e, 0x6f, 0x50, 0x6f, 0x72, 0x74,
    0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x12, 0x10, 0x0a, 0x08, 0x49, 0x6e, 0x45, 0x72, 0x72,
    0x6f, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x4f, 0x75, 0x74,
    0x44, 0x61, 0x74, 0x61, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x12,
    0x14, 0x0a, 0x0c, 0x52, 0x63, 0x76, 0x62, 0x75, 0x66, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x53, 0x6e, 0x64, 0x62, 0x75, 0x66, 0x45,
    0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49,
    0x6e, 0x43, 0x73, 0x75, 0x6d, 0x45, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x03, 0x12, 0x14, 0x0a, 0x0c, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x4d, 0x75, 0x6c, 0x74,
    0x69, 0x18, 0x08, 0x20, 0x01, 0x28, 0x03, 0x22, 0xc0, 0x01, 0x0a, 0x0e, 0x53, 0x4e, 0x4d, 0x50,
    0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x28, 0x0a, 0x08, 0x69, 0x70,
    0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73,
    0x74, 0x69, 0x63, 0x73, 0x12, 0x2c, 0x0a, 0x0a, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x73, 0x74, 0x61,
    0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x49, 0x63, 0x6d, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69,
    0x63, 0x73, 0x12, 0x2a, 0x0a, 0x09, 0x74, 0x63, 0x70, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x54, 0x63, 0x70, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x2a,
    0x0a, 0x09, 0x75, 0x64, 0x70, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x64, 0x70,
    0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x22, 0xf3, 0x09, 0x0a, 0x12, 0x52,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63,
    0x73, 0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01,
    0x20, 0x02, 0x28, 0x01, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65,
    0x73, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x74, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x73, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x63, 0x70, 0x75, 0x73,
    0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x01, 0x12, 0x1d, 0x0a, 0x15, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x73, 0x79,
    0x73, 0x74, 0x65, 0x6d, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x01, 0x12, 0x12, 0x0a, 0x0a, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x6c, 0x69, 0x6d,
    0x69, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x12, 0x17, 0x0a, 0x0f, 0x63, 0x70, 0x75, 0x73,
    0x5f, 0x6e, 0x72, 0x5f, 0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x19, 0x0a, 0x11, 0x63, 0x70, 0x75, 0x73, 0x5f, 0x6e, 0x72, 0x5f, 0x74, 0x68, 0x72,
    0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x20, 0x0a, 0x18,
    0x63, 0x70, 0x75, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x5f, 0x74,
    0x69, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x01, 0x12, 0x17,
    0x0a, 0x0f, 0x6d, 0x65, 0x6d, 0x5f, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x18, 0x24, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6d, 0x65, 0x6d, 0x5f, 0x74,
    0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x6d, 0x65, 0x6d, 0x73, 0x77, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73,
    0x18, 0x25, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6d, 0x65, 0x6d, 0x5f, 0x6c, 0x69,
    0x6d, 0x69, 0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x1c, 0x0a, 0x14, 0x6d, 0x65, 0x6d, 0x5f, 0x73, 0x6f, 0x66, 0x74, 0x5f, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x26, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a,
    0x0e, 0x6d, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18,
    0x0a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x65, 0x6d, 0x5f, 0x61, 0x6e, 0x6f,
    0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a,
    0x0f, 0x6d, 0x65, 0x6d, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73,
    0x18, 0x27, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x65, 0x6d, 0x5f, 0x72, 0x73,
    0x73, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a,
    0x15, 0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x61, 0x70, 0x70, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65,
    0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e,
    0x6d, 0x65, 0x6d, 0x5f, 0x73, 0x77, 0x61, 0x70, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x28,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6d, 0x65, 0x6d, 0x5f, 0x75, 0x6e, 0x65, 0x76,
    0x69, 0x63, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x29, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x20, 0x0a, 0x18, 0x6d, 0x65, 0x6d, 0x5f, 0x6c, 0x6f, 0x77, 0x5f, 0x70,
    0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x18,
    0x20, 0x20, 0x01, 0x28, 0x04, 0x12, 0x23, 0x0a, 0x1b, 0x6d, 0x65, 0x6d, 0x5f, 0x6d, 0x65, 0x64,
    0x69, 0x75, 0x6d, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75,
    0x6e, 0x74, 0x65, 0x72, 0x18, 0x21, 0x20, 0x01, 0x28, 0x04, 0x12, 0x25, 0x0a, 0x1d, 0x6d, 0x65,
    0x6d, 0x5f, 0x63, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x5f, 0x70, 0x72, 0x65, 0x73, 0x73,
    0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x72, 0x18, 0x22, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x18, 0x0a, 0x10, 0x64, 0x69, 0x73, 0x6b, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x5f,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x64,
    0x69, 0x73, 0x6b, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x18, 0x1b,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x26, 0x0a, 0x04, 0x70, 0x65, 0x72, 0x66, 0x18, 0x0d, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x65,
    0x72, 0x66, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x16, 0x0a, 0x0e,
    0x6e, 0x65, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x0e,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x62,
    0x79, 0x74, 0x65, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6e, 0x65,
    0x74, 0x5f, 0x72, 0x78, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x72, 0x78, 0x5f, 0x64, 0x72, 0x6f, 0x70,
    0x70, 0x65, 0x64, 0x18, 0x11, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x6e, 0x65, 0x74,
    0x5f, 0x74, 0x78, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x18, 0x12, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x14, 0x0a, 0x0c, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x6e, 0x65, 0x74, 0x5f, 0x74,
    0x78, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x73, 0x18, 0x14, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16,
    0x0a, 0x0e, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x78, 0x5f, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64,
    0x18, 0x15, 0x20, 0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63,
    0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f,
    0x70, 0x35, 0x30, 0x18, 0x16, 0x20, 0x01, 0x28, 0x01, 0x12, 0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74,
    0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x65,
    0x63, 0x73, 0x5f, 0x70, 0x39, 0x30, 0x18, 0x17, 0x20, 0x01, 0x28, 0x01, 0x12, 0x21, 0x0a, 0x19,
    0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d, 0x69, 0x63, 0x72,
    0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f, 0x70, 0x39, 0x35, 0x18, 0x18, 0x20, 0x01, 0x28, 0x01, 0x12,
    0x21, 0x0a, 0x19, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x72, 0x74, 0x74, 0x5f, 0x6d,
    0x69, 0x63, 0x72, 0x6f, 0x73, 0x65, 0x63, 0x73, 0x5f, 0x70, 0x39, 0x39, 0x18, 0x19, 0x20, 0x01,
    0x28, 0x01, 0x12, 0x22, 0x0a, 0x1a, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63, 0x70, 0x5f, 0x61, 0x63,
    0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x18, 0x1c, 0x20, 0x01, 0x28, 0x01, 0x12, 0x25, 0x0a, 0x1d, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x63,
    0x70, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x77, 0x61, 0x69, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x6e,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x01, 0x12, 0x4a, 0x0a,
    0x1e, 0x6e, 0x65, 0x74, 0x5f, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x5f, 0x63, 0x6f, 0x6e,
    0x74, 0x72, 0x6f, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x18,
    0x23, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x53,
    0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12, 0x35, 0x0a, 0x13, 0x6e, 0x65, 0x74,
    0x5f, 0x73, 0x6e, 0x6d, 0x70, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x18, 0x2a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x53, 0x4e, 0x4d, 0x50, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73,
    0x22, 0xa9, 0x02, 0x0a, 0x0d, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 0x73, 0x61,
    0x67, 0x65, 0x12, 0x33, 0x0a, 0x09, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x55, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x12, 0x21, 0x0a, 0x05, 0x74, 0x6f, 0x74, 0x61, 0x6c,
    0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0xbf, 0x01, 0x0a, 0x08, 0x45,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x12, 0x2d, 0x0a, 0x0d, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x16,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x25, 0x0a, 0x09, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x30, 0x0a,
    0x0a, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x1c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12,
    0x2b, 0x0a, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18,
    0x04, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x44, 0x22, 0xb0, 0x0a, 0x0a,
    0x0e, 0x50, 0x65, 0x72, 0x66, 0x53, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x12,
    0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x02,
    0x28, 0x01, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
    0x20, 0x02, 0x28, 0x01, 0x12, 0x0e, 0x0a, 0x06, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x1f, 0x0a, 0x17, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x5f,
    0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x5f, 0x66, 0x72, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x64, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1e, 0x0a, 0x16, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64,
    0x5f, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x65, 0x6e, 0x64, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x69, 0x6e, 0x73, 0x74, 0x72, 0x75, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x63,
    0x61, 0x63, 0x68, 0x65, 0x5f, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6d,
    0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x12, 0x10, 0x0a, 0x08, 0x62,
    0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a,
    0x0d, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x0a,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x62, 0x75, 0x73, 0x5f, 0x63, 0x79, 0x63, 0x6c,
    0x65, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x72, 0x65, 0x66, 0x5f,
    0x63, 0x79, 0x63, 0x6c, 0x65, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11, 0x0a, 0x09,
    0x63, 0x70, 0x75, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x01, 0x12,
    0x12, 0x0a, 0x0a, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x63, 0x6c, 0x6f, 0x63, 0x6b, 0x18, 0x0e, 0x20,
    0x01, 0x28, 0x01, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x61, 0x67, 0x65, 0x5f, 0x66, 0x61, 0x75, 0x6c,
    0x74, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x69, 0x6e, 0x6f,
    0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14,
    0x0a, 0x0c, 0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x11,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x5f,
    0x73, 0x77, 0x69, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x12, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16,
    0x0a, 0x0e, 0x63, 0x70, 0x75, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x18, 0x13, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x61, 0x6c, 0x69, 0x67, 0x6e, 0x6d,
    0x65, 0x6e, 0x74, 0x5f, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x14, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x18, 0x0a, 0x10, 0x65, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x61,
    0x75, 0x6c, 0x74, 0x73, 0x18, 0x15, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6c, 0x31,
    0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x16, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x17, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f,
    0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x18, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1e, 0x0a, 0x16,
    0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f,
    0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x19, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14,
    0x6c, 0x31, 0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x65, 0x73, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x6c, 0x31,
    0x5f, 0x64, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68,
    0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a,
    0x0f, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73,
    0x18, 0x1c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61,
    0x63, 0x68, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18,
    0x1d, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63,
    0x68, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x1e, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x6c, 0x31, 0x5f, 0x69, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73,
    0x18, 0x1f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11, 0x0a, 0x09, 0x6c, 0x6c, 0x63, 0x5f, 0x6c, 0x6f,
    0x61, 0x64, 0x73, 0x18, 0x20, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6c, 0x6c, 0x63,
    0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x21, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6c, 0x63, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73,
    0x18, 0x22, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6c, 0x6c, 0x63, 0x5f, 0x73, 0x74,
    0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x23, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x6c, 0x63, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68,
    0x65, 0x73, 0x18, 0x24, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1b, 0x0a, 0x13, 0x6c, 0x6c, 0x63, 0x5f,
    0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18,
    0x25, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f,
    0x61, 0x64, 0x73, 0x18, 0x26, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x64, 0x74, 0x6c,
    0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x27, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x73, 0x74, 0x6f, 0x72,
    0x65, 0x73, 0x18, 0x28, 0x20, 0x01, 0x28, 0x04, 0x12, 0x19, 0x0a, 0x11, 0x64, 0x74, 0x6c, 0x62,
    0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x29, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x74, 0x6c, 0x62, 0x5f, 0x70, 0x72, 0x65, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x2a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1c, 0x0a, 0x14,
    0x64, 0x74, 0x6c, 0x62, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x5f, 0x6d, 0x69,
    0x73, 0x73, 0x65, 0x73, 0x18, 0x2b, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x69, 0x74,
    0x6c, 0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x2c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18,
    0x0a, 0x10, 0x69, 0x74, 0x6c, 0x62, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73,
    0x65, 0x73, 0x18, 0x2d, 0x20, 0x01, 0x28, 0x04, 0x12, 0x14, 0x0a, 0x0c, 0x62, 0x72, 0x61, 0x6e,
    0x63, 0x68, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x2e, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1a,
    0x0a, 0x12, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69,
    0x73, 0x73, 0x65, 0x73, 0x18, 0x2f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x6e, 0x6f,
    0x64, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x18, 0x30, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18,
    0x0a, 0x10, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x6d, 0x69, 0x73, 0x73,
    0x65, 0x73, 0x18, 0x31, 0x20, 0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x6f, 0x64, 0x65,
    0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x73, 0x18, 0x32, 0x20, 0x01, 0x28, 0x04, 0x12, 0x19, 0x0a,
    0x11, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x69, 0x73, 0x73,
    0x65, 0x73, 0x18, 0x33, 0x20, 0x01, 0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x6e, 0x6f, 0x64, 0x65,
    0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x34, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x1c, 0x0a, 0x14, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x5f, 0x6d, 0x69, 0x73, 0x73, 0x65, 0x73, 0x18, 0x35, 0x20, 0x01, 0x28, 0x04, 0x22,
    0x55, 0x0a, 0x07, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67,
    0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12,
    0x25, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0xd4, 0x07, 0x0a, 0x05, 0x4f, 0x66, 0x66, 0x65, 0x72,
    0x12, 0x1d, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12,
    0x2b, 0x0a, 0x0c, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x18,
    0x02, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x23, 0x0a, 0x08,
    0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49,
    0x44, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20,
    0x02, 0x28, 0x09, 0x12, 0x1a, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x0d, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x52, 0x4c, 0x12,
    0x25, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x27, 0x0a, 0x0a, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62,
    0x75, 0x74, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x12,
    0x2a, 0x0a, 0x0c, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x73, 0x18,
    0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x44, 0x12, 0x30, 0x0a, 0x0e, 0x75,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x09, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x1a, 0xfd, 0x04,
    0x0a, 0x09, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2c, 0x0a, 0x04, 0x74,
    0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x30, 0x0a, 0x06, 0x6c, 0x61, 0x75,
    0x6e, 0x63, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x12, 0x32, 0x0a, 0x07, 0x72,
    0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70,
    0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12,
    0x36, 0x0a, 0x09, 0x75, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x23, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66,
    0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x55, 0x6e,
    0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x30, 0x0a, 0x06, 0x63, 0x72, 0x65, 0x61, 0x74,
    0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x12, 0x32, 0x0a, 0x07, 0x64, 0x65, 0x73,
    0x74, 0x72, 0x6f, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x4f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x1a, 0x30, 0x0a,
    0x06, 0x4c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x12, 0x26, 0x0a, 0x0a, 0x74, 0x61, 0x73, 0x6b, 0x5f,
    0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x1a,
    0x30, 0x0a, 0x07, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x25, 0x0a, 0x09, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x1a, 0x32, 0x0a, 0x09, 0x55, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x12, 0x25,
    0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0x2d, 0x0a, 0x06, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x12,
    0x23, 0x0a, 0x07, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x1a, 0x2e, 0x0a, 0x07, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x12,
    0x23, 0x0a, 0x07, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x22, 0x47, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0a, 0x0a, 0x06,
    0x4c, 0x41, 0x55, 0x4e, 0x43, 0x48, 0x10, 0x01, 0x12, 0x0b, 0x0a, 0x07, 0x52, 0x45, 0x53, 0x45,
    0x52, 0x56, 0x45, 0x10, 0x02, 0x12, 0x0d, 0x0a, 0x09, 0x55, 0x4e, 0x52, 0x45, 0x53, 0x45, 0x52,
    0x56, 0x45, 0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10, 0x04,
    0x12, 0x0b, 0x0a, 0x07, 0x44, 0x45, 0x53, 0x54, 0x52, 0x4f, 0x59, 0x10, 0x05, 0x22, 0xf4, 0x01,
    0x0a, 0x0c, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x12, 0x1d,
    0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x12, 0x1a, 0x0a,
    0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0d, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x52, 0x4c, 0x12, 0x2b, 0x0a, 0x0c, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0b, 0x32,
    0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x49, 0x44, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f,
    0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x2e, 0x76, 0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x30, 0x0a, 0x0e, 0x75,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20,
    0x02, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x55,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x25, 0x0a,
    0x09, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x22, 0x8e, 0x03, 0x0a, 0x08, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12,
    0x21, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0b,
    0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b,
    0x49, 0x44, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03,
    0x20, 0x02, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x25, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x28,
    0x0a, 0x08, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x26, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f,
    0x12, 0x2a, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x18, 0x09, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0c, 0x0a, 0x04,
    0x64, 0x61, 0x74, 0x61, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x2b, 0x0a, 0x0c, 0x68, 0x65,
    0x61, 0x6c, 0x74, 0x68, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b,
    0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x48, 0x65, 0x61, 0x6c,
    0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c,
    0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x2a, 0x0a, 0x09, 0x64, 0x69, 0x73,
    0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72,
    0x79, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x8d, 0x0a, 0x0a, 0x0a, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74,
    0x61, 0x74, 0x75, 0x73, 0x12, 0x21, 0x0a, 0x07, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x54, 0x61, 0x73, 0x6b, 0x49, 0x44, 0x12, 0x22, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x2b, 0x0a, 0x06,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x2b, 0x0a, 0x06, 0x72, 0x65, 0x61,
    0x73, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x6d, 0x65, 0x73, 0x6f,
    0x73, 0x2e, 0x76, 0x31, 0x2e, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e,
    0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x0c, 0x0a, 0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x23, 0x0a, 0x08, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x49, 0x44, 0x12, 0x29, 0x0a, 0x0b, 0x65, 0x78, 0x65,
    0x63, 0x75, 0x74, 0x6f, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x49, 0x44, 0x12, 0x11, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
    0x70, 0x18, 0x06, 0x20, 0x01, 0x28, 0x01, 0x12, 0x0c, 0x0a, 0x04, 0x75, 0x75, 0x69, 0x64, 0x18,
    0x0b, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0f, 0x0a, 0x07, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x33, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x0d, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x42, 0x0a,
    0x06, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x4f, 0x55, 0x52, 0x43,
    0x45, 0x5f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c, 0x53, 0x4f,
    0x55, 0x52, 0x43, 0x45, 0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f,
    0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x10,
    0x02, 0x22, 0xa1, 0x06, 0x0a, 0x06, 0x52, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x12, 0x22, 0x0a, 0x1e,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4d, 0x4d, 0x41, 0x4e, 0x44, 0x5f, 0x45,
    0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x00,
    0x12, 0x22, 0x0a, 0x1e, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x41,
    0x49, 0x4e, 0x45, 0x52, 0x5f, 0x4c, 0x41, 0x55, 0x4e, 0x43, 0x48, 0x5f, 0x46, 0x41, 0x49, 0x4c,
    0x45, 0x44, 0x10, 0x15, 0x12, 0x1f, 0x0a, 0x1b, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43,
    0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x41, 0x54,
    0x49, 0x4f, 0x4e, 0x10, 0x13, 0x12, 0x24, 0x0a, 0x20, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f,
    0x43, 0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x5f, 0x4c, 0x49, 0x4d, 0x49, 0x54, 0x41,
    0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x49, 0x53, 0x4b, 0x10, 0x14, 0x12, 0x26, 0x0a, 0x22, 0x52,
    0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x5f,
    0x4c, 0x49, 0x4d, 0x49, 0x54, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x4d, 0x45, 0x4d, 0x4f, 0x52,
    0x59, 0x10, 0x08, 0x12, 0x1e, 0x0a, 0x1a, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f,
    0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x5f, 0x50, 0x52, 0x45, 0x45, 0x4d, 0x50, 0x54, 0x45,
    0x44, 0x10, 0x11, 0x12, 0x22, 0x0a, 0x1e, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x43, 0x4f,
    0x4e, 0x54, 0x41, 0x49, 0x4e, 0x45, 0x52, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x5f, 0x46,
    0x41, 0x49, 0x4c, 0x45, 0x44, 0x10, 0x16, 0x12, 0x28, 0x0a, 0x24, 0x52, 0x45, 0x41, 0x53, 0x4f,
    0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52, 0x5f, 0x52, 0x45, 0x47, 0x49, 0x53,
    0x54, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10,
    0x17, 0x12, 0x2a, 0x0a, 0x26, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43,
    0x55, 0x54, 0x4f, 0x52, 0x5f, 0x52, 0x45, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54, 0x52, 0x41, 0x54,
    0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x4f, 0x55, 0x54, 0x10, 0x18, 0x12, 0x1e, 0x0a,
    0x1a, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52,
    0x5f, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x20, 0x0a,
    0x1c, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x45, 0x58, 0x45, 0x43, 0x55, 0x54, 0x4f, 0x52,
    0x5f, 0x55, 0x4e, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54, 0x45, 0x52, 0x45, 0x44, 0x10, 0x02, 0x12,
    0x1c, 0x0a, 0x18, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57,
    0x4f, 0x52, 0x4b, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x56, 0x45, 0x44, 0x10, 0x03, 0x12, 0x13, 0x0a,
    0x0f, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x47, 0x43, 0x5f, 0x45, 0x52, 0x52, 0x4f, 0x52,
    0x10, 0x04, 0x12, 0x1e, 0x0a, 0x1a, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x49, 0x4e, 0x56,
    0x41, 0x4c, 0x49, 0x44, 0x5f, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f, 0x52, 0x4b, 0x49, 0x44,
    0x10, 0x05, 0x12, 0x19, 0x0a, 0x15, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x49, 0x4e, 0x56,
    0x41, 0x4c, 0x49, 0x44, 0x5f, 0x4f, 0x46, 0x46, 0x45, 0x52, 0x53, 0x10, 0x06, 0x12, 0x1e, 0x0a,
    0x1a, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x44,
    0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43, 0x54, 0x45, 0x44, 0x10, 0x07, 0x12, 0x19, 0x0a,
    0x15, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x43, 0x4f, 0x4e, 0x43, 0x49, 0x4c,
    0x49, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x09, 0x12, 0x1c, 0x0a, 0x18, 0x52, 0x45, 0x41, 0x53,
    0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x53, 0x5f, 0x55, 0x4e, 0x4b,
    0x4e, 0x4f, 0x57, 0x4e, 0x10, 0x12, 0x12, 0x1d, 0x0a, 0x19, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e,
    0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x5f, 0x44, 0x49, 0x53, 0x43, 0x4f, 0x4e, 0x4e, 0x45, 0x43,
    0x54, 0x45, 0x44, 0x10, 0x0a, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f,
    0x41, 0x47, 0x45, 0x4e, 0x54, 0x5f, 0x52, 0x45, 0x4d, 0x4f, 0x56, 0x45, 0x44, 0x10, 0x0b, 0x12,
    0x1a, 0x0a, 0x16, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x5f,
    0x52, 0x45, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x0c, 0x12, 0x18, 0x0a, 0x14, 0x52,
    0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x41, 0x47, 0x45, 0x4e, 0x54, 0x5f, 0x55, 0x4e, 0x4b, 0x4e,
    0x4f, 0x57, 0x4e, 0x10, 0x0d, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f,
    0x54, 0x41, 0x53, 0x4b, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x0e, 0x12, 0x1c,
    0x0a, 0x18, 0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x55, 0x4e,
    0x41, 0x55, 0x54, 0x48, 0x4f, 0x52, 0x49, 0x5a, 0x45, 0x44, 0x10, 0x0f, 0x12, 0x17, 0x0a, 0x13,
    0x52, 0x45, 0x41, 0x53, 0x4f, 0x4e, 0x5f, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x55, 0x4e, 0x4b, 0x4e,
    0x4f, 0x57, 0x4e, 0x10, 0x10, 0x22, 0x24, 0x0a, 0x07, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73,
    0x12, 0x19, 0x0a, 0x0e, 0x72, 0x65, 0x66, 0x75, 0x73, 0x65, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e,
    0x64, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x3a, 0x01, 0x35, 0x22, 0x69, 0x0a, 0x0b, 0x45,
    0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x31, 0x0a, 0x09, 0x76, 0x61,
    0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e,
    0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x1a, 0x27, 0x0a,
    0x08, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22, 0x27, 0x0a, 0x09, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
    0x74, 0x65, 0x72, 0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09,
    0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x22,
    0x34, 0x0a, 0x0a, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x12, 0x26, 0x0a,
    0x09, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x13, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x72, 0x61,
    0x6d, 0x65, 0x74, 0x65, 0x72, 0x22, 0x2f, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
    0x69, 0x61, 0x6c, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x38, 0x0a, 0x0b, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e,
    0x74, 0x69, 0x61, 0x6c, 0x73, 0x12, 0x29, 0x0a, 0x0b, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74,
    0x69, 0x61, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
    0x22, 0x3d, 0x0a, 0x09, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x12, 0x0b, 0x0a,
    0x03, 0x71, 0x70, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x01, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x72,
    0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x12, 0x10, 0x0a,
    0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x04, 0x22,
    0x74, 0x0a, 0x0a, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x12, 0x23, 0x0a,
    0x06, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d,
    0x69, 0x74, 0x12, 0x1d, 0x0a, 0x15, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f,
    0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x01, 0x12, 0x22, 0x0a, 0x1a, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x64,
    0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x04, 0x22, 0x9b, 0x02, 0x0a, 0x05, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x12,
    0x22, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x14, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x54,
    0x79, 0x70, 0x65, 0x12, 0x22, 0x0a, 0x04, 0x61, 0x70, 0x70, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6d, 0x61,
    0x67, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x63, 0x12, 0x26, 0x0a, 0x06, 0x64, 0x6f, 0x63, 0x6b, 0x65,
    0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x1a,
    0x42, 0x0a, 0x04, 0x41, 0x70, 0x70, 0x63, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0a, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x1a, 0x40, 0x0a, 0x06, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x12, 0x0c, 0x0a,
    0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x28, 0x0a, 0x0a, 0x63,
    0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
    0x14, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x61, 0x6c, 0x22, 0x1c, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x08, 0x0a,
    0x04, 0x41, 0x50, 0x50, 0x43, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x4f, 0x43, 0x4b, 0x45,
    0x52, 0x10, 0x02, 0x22, 0x90, 0x01, 0x0a, 0x06, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x12, 0x23,
    0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x4d,
    0x6f, 0x64, 0x65, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x68,
    0x6f, 0x73, 0x74, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1e,
    0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x16,
    0x0a, 0x04, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x06, 0x0a, 0x02, 0x52, 0x57, 0x10, 0x01, 0x12, 0x06,
    0x0a, 0x02, 0x52, 0x4f, 0x10, 0x02, 0x22, 0xb7, 0x02, 0x0a, 0x0b, 0x4e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x35, 0x0a, 0x0c, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x34, 0x0a,
    0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
    0x1e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x42,
    0x02, 0x18, 0x01, 0x12, 0x16, 0x0a, 0x0a, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x42, 0x02, 0x18, 0x01, 0x12, 0x0e, 0x0a, 0x06, 0x67,
    0x72, 0x6f, 0x75, 0x70, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x12, 0x20, 0x0a, 0x06, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x1a, 0x51, 0x0a,
    0x09, 0x49, 0x50, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x30, 0x0a, 0x08, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1e, 0x2e, 0x6d,
    0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x12, 0x0a, 0x0a,
    0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x1e, 0x0a, 0x08, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x12, 0x08, 0x0a, 0x04,
    0x49, 0x50, 0x76, 0x34, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x49, 0x50, 0x76, 0x36, 0x10, 0x02,
    0x22, 0xe4, 0x05, 0x0a, 0x0d, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e,
    0x66, 0x6f, 0x12, 0x2a, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e,
    0x32, 0x1c, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21,
    0x0a, 0x07, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x56, 0x6f, 0x6c, 0x75, 0x6d,
    0x65, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x32, 0x0a, 0x06, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x44, 0x6f, 0x63,
    0x6b, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x30, 0x0a, 0x05, 0x6d, 0x65, 0x73, 0x6f, 0x73,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e,
    0x4d, 0x65, 0x73, 0x6f, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x2c, 0x0a, 0x0d, 0x6e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x74, 0x77,
    0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x1a, 0x91, 0x03, 0x0a, 0x0a, 0x44, 0x6f, 0x63, 0x6b,
    0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0d, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18,
    0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x41, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2a, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76,
    0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e,
    0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x4e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x3a, 0x04, 0x48, 0x4f, 0x53, 0x54, 0x12, 0x45, 0x0a, 0x0d, 0x70, 0x6f, 0x72, 0x74,
    0x5f, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x2e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x44, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x49,
    0x6e, 0x66, 0x6f, 0x2e, 0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12,
    0x19, 0x0a, 0x0a, 0x70, 0x72, 0x69, 0x76, 0x69, 0x6c, 0x65, 0x67, 0x65, 0x64, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x27, 0x0a, 0x0a, 0x70, 0x61,
    0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13,
    0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
    0x74, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x10, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x5f, 0x70, 0x75, 0x6c,
    0x6c, 0x5f, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x15, 0x0a,
    0x0d, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x5f, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x18, 0x07,
    0x20, 0x01, 0x28, 0x09, 0x1a, 0x4a, 0x0a, 0x0b, 0x50, 0x6f, 0x72, 0x74, 0x4d, 0x61, 0x70, 0x70,
    0x69, 0x6e, 0x67, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x70, 0x6f, 0x72, 0x74,
    0x18, 0x01, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x02, 0x28, 0x0d, 0x12, 0x10,
    0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
    0x22, 0x29, 0x0a, 0x07, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x08, 0x0a, 0x04, 0x48,
    0x4f, 0x53, 0x54, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x42, 0x52, 0x49, 0x44, 0x47, 0x45, 0x10,
    0x02, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x4f, 0x4e, 0x45, 0x10, 0x03, 0x1a, 0x2b, 0x0a, 0x09, 0x4d,
    0x65, 0x73, 0x6f, 0x73, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1e, 0x0a, 0x05, 0x69, 0x6d, 0x61, 0x67,
    0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x49, 0x6d, 0x61, 0x67, 0x65, 0x22, 0x1d, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65,
    0x12, 0x0a, 0x0a, 0x06, 0x44, 0x4f, 0x43, 0x4b, 0x45, 0x52, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05,
    0x4d, 0x45, 0x53, 0x4f, 0x53, 0x10, 0x02, 0x22, 0x6a, 0x0a, 0x0f, 0x43, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x2c, 0x0a, 0x0d, 0x6e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x15, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x29, 0x0a, 0x0b, 0x63, 0x67, 0x72, 0x6f,
    0x75, 0x70, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x14, 0x2e,
    0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x49,
    0x6e, 0x66, 0x6f, 0x22, 0x55, 0x0a, 0x0a, 0x43, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x2c, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x5f, 0x63, 0x6c, 0x73, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x67,
    0x72, 0x6f, 0x75, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x4e, 0x65, 0x74, 0x43, 0x6c, 0x73, 0x1a,
    0x19, 0x0a, 0x06, 0x4e, 0x65, 0x74, 0x43, 0x6c, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x6c, 0x61,
    0x73, 0x73, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x29, 0x0a, 0x06, 0x4c, 0x61,
    0x62, 0x65, 0x6c, 0x73, 0x12, 0x1f, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x4c, 0x61, 0x62, 0x65, 0x6c, 0x22, 0x23, 0x0a, 0x05, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x0b,
    0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x90, 0x01, 0x0a, 0x04, 0x50,
    0x6f, 0x72, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20,
    0x02, 0x28, 0x0d, 0x12, 0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x10, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x36, 0x0a, 0x0a, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74,
    0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x22, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e,
    0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f,
    0x2e, 0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x20, 0x0a, 0x06, 0x6c,
    0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x22, 0x26, 0x0a,
    0x05, 0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x1d, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x50, 0x6f, 0x72, 0x74, 0x22, 0x87, 0x02, 0x0a, 0x0d, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76,
    0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x36, 0x0a, 0x0a, 0x76, 0x69, 0x73, 0x69, 0x62,
    0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x22, 0x2e, 0x6d, 0x65,
    0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79,
    0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12,
    0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a,
    0x0b, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1e, 0x0a, 0x05, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x2e,
    0x50, 0x6f, 0x72, 0x74, 0x73, 0x12, 0x20, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31,
    0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x22, 0x36, 0x0a, 0x0a, 0x56, 0x69, 0x73, 0x69, 0x62,
    0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x0d, 0x0a, 0x09, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f,
    0x52, 0x4b, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x10,
    0x01, 0x12, 0x0c, 0x0a, 0x08, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x10, 0x02, 0x22,
    0x2a, 0x0a, 0x0a, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0e, 0x0a,
    0x06, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x01, 0x12, 0x0c, 0x0a,
    0x04, 0x72, 0x6f, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x2a, 0x5c, 0x0a, 0x06, 0x53,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x16, 0x0a, 0x12, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f,
    0x4e, 0x4f, 0x54, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54, 0x45, 0x44, 0x10, 0x01, 0x12, 0x12, 0x0a,
    0x0e, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10,
    0x02, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f, 0x41, 0x42, 0x4f, 0x52,
    0x54, 0x45, 0x44, 0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x44, 0x52, 0x49, 0x56, 0x45, 0x52, 0x5f,
    0x53, 0x54, 0x4f, 0x50, 0x50, 0x45, 0x44, 0x10, 0x04, 0x2a, 0xa8, 0x01, 0x0a, 0x09, 0x54, 0x61,
    0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x54, 0x41, 0x53, 0x4b, 0x5f,
    0x53, 0x54, 0x41, 0x47, 0x49, 0x4e, 0x47, 0x10, 0x06, 0x12, 0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53,
    0x4b, 0x5f, 0x53, 0x54, 0x41, 0x52, 0x54, 0x49, 0x4e, 0x47, 0x10, 0x00, 0x12, 0x10, 0x0a, 0x0c,
    0x54, 0x41, 0x53, 0x4b, 0x5f, 0x52, 0x55, 0x4e, 0x4e, 0x49, 0x4e, 0x47, 0x10, 0x01, 0x12, 0x10,
    0x0a, 0x0c, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x49, 0x4e, 0x47, 0x10, 0x08,
    0x12, 0x11, 0x0a, 0x0d, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x46, 0x49, 0x4e, 0x49, 0x53, 0x48, 0x45,
    0x44, 0x10, 0x02, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x46, 0x41, 0x49, 0x4c,
    0x45, 0x44, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c,
    0x4c, 0x45, 0x44, 0x10, 0x04, 0x12, 0x0d, 0x0a, 0x09, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f,
    0x53, 0x54, 0x10, 0x05, 0x12, 0x0e, 0x0a, 0x0a, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x45, 0x52, 0x52,
    0x4f, 0x52, 0x10, 0x07, 0x42, 0x1d, 0x0a, 0x13, 0x6f, 0x72, 0x67, 0x2e, 0x61, 0x70, 0x61, 0x63,
    0x68, 0x65, 0x2e, 0x6d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x76, 0x31, 0x42, 0x06, 0x50, 0x72, 0x6f,
    0x74, 0x6f, 0x73, 0x4a, 0xc2, 0xdb, 0x04, 0x0a, 0x07, 0x12, 0x05, 0x10, 0x00, 0x87, 0x0e, 0x01,
    0x0a, 0x08, 0x0a, 0x01, 0x02, 0x12, 0x03, 0x10, 0x08, 0x10, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12,
    0x03, 0x12, 0x00, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x12, 0x00,
    0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x03, 0x12, 0x07, 0x13, 0x0a,
    0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x03, 0x12, 0x07, 0x13, 0x0a, 0x0e,
    0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x12, 0x07, 0x13, 0x0a, 0x0c,
    0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x07, 0x12, 0x03, 0x12, 0x16, 0x2b, 0x0a, 0x08, 0x0a, 0x01,
    0x08, 0x12, 0x03, 0x13, 0x00, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03,
    0x13, 0x00, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x03, 0x13, 0x07,
    0x1b, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x03, 0x13, 0x07, 0x1b,
    0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x13, 0x07, 0x1b,
    0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01, 0x07, 0x12, 0x03, 0x13, 0x1e, 0x26, 0x0a, 0x70,
    0x0a, 0x02, 0x05, 0x00, 0x12, 0x04, 0x1a, 0x00, 0x1f, 0x01, 0x1a, 0x64, 0x2a, 0x0a, 0x20, 0x53,
    0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x0a, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20,
    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x2e, 0x0a,
    0x0a, 0x0a, 0x0a, 0x03, 0x05, 0x00, 0x01, 0x12, 0x03, 0x1a, 0x05, 0x0b, 0x0a, 0x0b, 0x0a, 0x04,
    0x05, 0x00, 0x02, 0x00, 0x12, 0x03, 0x1b, 0x02, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x03, 0x1b, 0x02, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x00, 0x02,
    0x12, 0x03, 0x1b, 0x17, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x01, 0x12, 0x03, 0x1c,
    0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x01, 0x12, 0x03, 0x1c, 0x02, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x01, 0x02, 0x12, 0x03, 0x1c, 0x13, 0x14, 0x0a, 0x0b,
    0x0a, 0x04, 0x05, 0x00, 0x02, 0x02, 0x12, 0x03, 0x1d, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x03, 0x1d, 0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02,
    0x02, 0x02, 0x12, 0x03, 0x1d, 0x13, 0x14, 0x0a, 0x0b, 0x0a, 0x04, 0x05, 0x00, 0x02, 0x03, 0x12,
    0x03, 0x1e, 0x02, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x01, 0x12, 0x03, 0x1e,
    0x02, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x05, 0x00, 0x02, 0x03, 0x02, 0x12, 0x03, 0x1e, 0x13, 0x14,
    0x0a, 0x87, 0x01, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x26, 0x00, 0x28, 0x01, 0x1a, 0x7b, 0x2a,
    0x0a, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x61, 0x73,
    0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x49, 0x44, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74,
    0x6f, 0x20, 0x64, 0x6f, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x28, 0x73,
    0x65, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x29, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00,
    0x01, 0x12, 0x03, 0x26, 0x08, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x00, 0x02, 0x00, 0x12, 0x03,
    0x27, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x04, 0x12, 0x03, 0x27, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x05, 0x12, 0x03, 0x27, 0x0b, 0x11, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x03, 0x27, 0x12, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x00, 0x02, 0x00, 0x03, 0x12, 0x03, 0x27, 0x1a, 0x1b, 0x0a, 0x31, 0x0a, 0x02, 0x04,
    0x01, 0x12, 0x04, 0x2e, 0x00, 0x30, 0x01, 0x1a, 0x25, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x75, 0x6e,
    0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0a,
    0x0a, 0x03, 0x04, 0x01, 0x01, 0x12, 0x03, 0x2e, 0x08, 0x0f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01,
    0x02, 0x00, 0x12, 0x03, 0x2f, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04,
    0x12, 0x03, 0x2f, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x05, 0x12, 0x03,
    0x2f, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x2f, 0x12,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x2f, 0x1a, 0x1b, 0x0a,
    0xd3, 0x01, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x38, 0x00, 0x3a, 0x01, 0x1a, 0xc6, 0x01, 0x2a,
    0x0a, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44, 0x20, 0x61, 0x73,
    0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x2e, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c, 0x20, 0x61,
    0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x67, 0x65, 0x74, 0x73, 0x20, 0x61, 0x20, 0x6e,
    0x65, 0x77, 0x20, 0x49, 0x44, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x65, 0x76, 0x65, 0x72, 0x20,
    0x69, 0x74, 0x20, 0x28, 0x72, 0x65, 0x29, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x73,
    0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x20, 0x46, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x72, 0x73, 0x20, 0x73,
    0x68, 0x6f, 0x75, 0x6c, 0x64, 0x6e, 0x27, 0x74, 0x0a, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65,
    0x20, 0x61, 0x6e, 0x79, 0x20, 0x62, 0x69, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x65, 0x74,
    0x77, 0x65, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x49, 0x44,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e,
    0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x02, 0x01, 0x12, 0x03, 0x38, 0x08,
    0x0f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00, 0x12, 0x03, 0x39, 0x02, 0x1c, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03, 0x39, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x00, 0x05, 0x12, 0x03, 0x39, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x39, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00,
    0x03, 0x12, 0x03, 0x39, 0x1a, 0x1b, 0x0a, 0x99, 0x02, 0x0a, 0x02, 0x04, 0x03, 0x12, 0x04, 0x43,
    0x00, 0x45, 0x01, 0x1a, 0x8c, 0x02, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x49,
    0x44, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68,
    0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20,
    0x6d, 0x75, 0x73, 0x74, 0x20, 0x72, 0x65, 0x6d, 0x61, 0x69, 0x6e, 0x0a, 0x20, 0x75, 0x6e, 0x69,
    0x71, 0x75, 0x65, 0x20, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61,
    0x73, 0x6b, 0x20, 0x69, 0x73, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x2e, 0x20, 0x48, 0x6f,
    0x77, 0x65, 0x76, 0x65, 0x72, 0x2c, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65, 0x20, 0x61, 0x6e, 0x0a,
    0x20, 0x49, 0x44, 0x20, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x20, 0x69, 0x66, 0x20, 0x61, 0x20,
    0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x49, 0x44, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x61, 0x0a, 0x20, 0x74, 0x65,
    0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x20, 0x28, 0x65, 0x2e,
    0x67, 0x2e, 0x2c, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x46, 0x49, 0x4e, 0x49, 0x53, 0x48, 0x45,
    0x44, 0x2c, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4c, 0x4f, 0x53, 0x54, 0x2c, 0x20, 0x54, 0x41,
    0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c, 0x45, 0x44, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x29,
    0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x43, 0x08, 0x0e, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x44, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x44, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x00, 0x05, 0x12, 0x03, 0x44, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x01,
    0x12, 0x03, 0x44, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x03, 0x12, 0x03,
    0x44, 0x1a, 0x1b, 0x0a, 0x95, 0x01, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x4d, 0x00, 0x4f, 0x01,
    0x1a, 0x88, 0x01, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x49, 0x44, 0x20, 0x74,
    0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75, 0x69, 0x73, 0x68, 0x20, 0x61, 0x6e,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20,
    0x6f, 0x6e, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x49, 0x44, 0x20, 0x63,
    0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x61,
    0x74, 0x20, 0x61, 0x0a, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04,
    0x04, 0x01, 0x12, 0x03, 0x4d, 0x08, 0x12, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x00, 0x12,
    0x03, 0x4e, 0x02, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12, 0x03, 0x4e,
    0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x03, 0x4e, 0x0b, 0x11,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03, 0x4e, 0x12, 0x17, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03, 0x4e, 0x1a, 0x1b, 0x0a, 0xf8, 0x01, 0x0a,
    0x02, 0x04, 0x05, 0x12, 0x04, 0x58, 0x00, 0x5a, 0x01, 0x1a, 0xeb, 0x01, 0x2a, 0x0a, 0x20, 0x41,
    0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x49, 0x44, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x75,
    0x69, 0x73, 0x68, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x0a,
    0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20,
    0x61, 0x6e, 0x79, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x63, 0x6f,
    0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e,
    0x20, 0x49, 0x6e, 0x0a, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x2c,
    0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x73, 0x20, 0x6f,
    0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x28, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2c, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x29, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75,
    0x6e, 0x69, 0x71, 0x75, 0x65, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x05, 0x01, 0x12, 0x03,
    0x58, 0x08, 0x13, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x00, 0x12, 0x03, 0x59, 0x02, 0x1c,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12, 0x03, 0x59, 0x02, 0x0a, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x03, 0x59, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x59, 0x12, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x59, 0x1a, 0x1b, 0x0a, 0x40, 0x0a, 0x02, 0x04, 0x06, 0x12, 0x04,
    0x60, 0x00, 0x64, 0x01, 0x1a, 0x34, 0x2a, 0x0a, 0x20, 0x52, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x65, 0x70, 0x6f, 0x63, 0x68, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x6e, 0x61, 0x6e,
    0x6f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x06,
    0x01, 0x12, 0x03, 0x60, 0x08, 0x10, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x03,
    0x61, 0x02, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x03, 0x61, 0x02,
    0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x03, 0x61, 0x0b, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x03, 0x61, 0x11, 0x1c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x00, 0x03, 0x12, 0x03, 0x61, 0x1f, 0x20, 0x0a, 0x33, 0x0a, 0x02, 0x04,
    0x07, 0x12, 0x04, 0x6a, 0x00, 0x6c, 0x01, 0x1a, 0x27, 0x2a, 0x0a, 0x20, 0x52, 0x65, 0x70, 0x72,
    0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x69, 0x6e, 0x20, 0x6e, 0x61, 0x6e, 0x6f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a,
    0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x07, 0x01, 0x12, 0x03, 0x6a, 0x08, 0x14, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x07, 0x02, 0x00, 0x12, 0x03, 0x6b, 0x02, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02,
    0x00, 0x04, 0x12, 0x03, 0x6b, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x05,
    0x12, 0x03, 0x6b, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x01, 0x12, 0x03,
    0x6b, 0x11, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x07, 0x02, 0x00, 0x03, 0x12, 0x03, 0x6b, 0x1f,
    0x20, 0x0a, 0x49, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x04, 0x74, 0x00, 0x7a, 0x01, 0x1a, 0x3d, 0x2a,
    0x0a, 0x20, 0x41, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68,
    0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x55, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d,
    0x6f, 0x72, 0x65, 0x20, 0x77, 0x69, 0x64, 0x65, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0a, 0x0a, 0x03,
    0x04, 0x08, 0x01, 0x12, 0x03, 0x74, 0x08, 0x0f, 0x0a, 0x3b, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x00,
    0x12, 0x03, 0x76, 0x02, 0x1f, 0x1a, 0x2e, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20,
    0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x62,
    0x6f, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x76, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x05, 0x12, 0x03, 0x76, 0x0b,
    0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12, 0x03, 0x76, 0x12, 0x1a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x03, 0x76, 0x1d, 0x1e, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x03, 0x77, 0x02, 0x19, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x01, 0x04, 0x12, 0x03, 0x77, 0x02, 0x0a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01,
    0x05, 0x12, 0x03, 0x77, 0x0b, 0x11, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01, 0x12,
    0x03, 0x77, 0x12, 0x14, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x03, 0x77,
    0x17, 0x18, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x08, 0x02, 0x02, 0x12, 0x03, 0x79, 0x02, 0x1a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x02, 0x04, 0x12, 0x03, 0x79, 0x02, 0x0a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x08, 0x02, 0x02, 0x05, 0x12, 0x03, 0x79, 0x0b, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x02, 0x01, 0x12, 0x03, 0x79, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x02, 0x03, 0x12, 0x03, 0x79, 0x18, 0x19, 0x0a, 0x23, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x06, 0x80,
    0x01, 0x00, 0x86, 0x01, 0x01, 0x1a, 0x15, 0x2a, 0x0a, 0x20, 0x52, 0x65, 0x70, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x74, 0x73, 0x20, 0x61, 0x20, 0x55, 0x52, 0x4c, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x09, 0x01, 0x12, 0x04, 0x80, 0x01, 0x08, 0x0b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02,
    0x00, 0x12, 0x04, 0x81, 0x01, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x81, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x05, 0x12,
    0x04, 0x81, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x81, 0x01, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81,
    0x01, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x01, 0x12, 0x04, 0x82, 0x01, 0x02,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x04, 0x12, 0x04, 0x82, 0x01, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x06, 0x12, 0x04, 0x82, 0x01, 0x0b, 0x12, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x01, 0x12, 0x04, 0x82, 0x01, 0x13, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x01, 0x03, 0x12, 0x04, 0x82, 0x01, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x09, 0x02, 0x02, 0x12, 0x04, 0x83, 0x01, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x09, 0x02, 0x02, 0x04, 0x12, 0x04, 0x83, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09,
    0x02, 0x02, 0x05, 0x12, 0x04, 0x83, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x83, 0x01, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x02,
    0x03, 0x12, 0x04, 0x83, 0x01, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x03, 0x12,
    0x04, 0x84, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x04, 0x12, 0x04,
    0x84, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x06, 0x12, 0x04, 0x84,
    0x01, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x01, 0x12, 0x04, 0x84, 0x01,
    0x15, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x03, 0x03, 0x12, 0x04, 0x84, 0x01, 0x1d,
    0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x09, 0x02, 0x04, 0x12, 0x04, 0x85, 0x01, 0x02, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x04, 0x12, 0x04, 0x85, 0x01, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x09, 0x02, 0x04, 0x05, 0x12, 0x04, 0x85, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x09, 0x02, 0x04, 0x01, 0x12, 0x04, 0x85, 0x01, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x09, 0x02, 0x04, 0x03, 0x12, 0x04, 0x85, 0x01, 0x1d, 0x1e, 0x0a, 0xc2, 0x01, 0x0a, 0x02,
    0x04, 0x0a, 0x12, 0x06, 0x8e, 0x01, 0x00, 0x97, 0x01, 0x01, 0x1a, 0xb3, 0x01, 0x2a, 0x0a, 0x20,
    0x52, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x67,
    0x69, 0x76, 0x65, 0x6e, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
    0x6f, 0x76, 0x65, 0x72, 0x20, 0x61, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x64, 0x75, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x74,
    0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x70, 0x65, 0x72, 0x74, 0x61, 0x69, 0x6e, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x61, 0x6e, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20,
    0x61, 0x73, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x63, 0x65, 0x2c, 0x0a,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x67, 0x65,
    0x6e, 0x65, 0x72, 0x69, 0x63, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x08, 0x16, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04, 0x8f, 0x01, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8f, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a,
    0x02, 0x00, 0x06, 0x12, 0x04, 0x8f, 0x01, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x8f, 0x01, 0x14, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x8f, 0x01, 0x1c, 0x1d, 0x0a, 0x88, 0x01, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x01,
    0x12, 0x04, 0x93, 0x01, 0x02, 0x25, 0x1a, 0x7a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x64,
    0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x60, 0x73, 0x74, 0x61, 0x72, 0x74, 0x60, 0x2c, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x64, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69,
    0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x75, 0x6e, 0x73,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x75,
    0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x04, 0x12, 0x04, 0x93, 0x01, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x06, 0x12, 0x04, 0x93, 0x01, 0x0b, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x01, 0x12, 0x04, 0x93, 0x01, 0x18, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x01, 0x03, 0x12, 0x04, 0x93, 0x01, 0x23, 0x24, 0x0a, 0xff,
    0x01, 0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0xa1, 0x01, 0x00, 0xa4, 0x01, 0x01, 0x1a, 0xf0, 0x01,
    0x2a, 0x0a, 0x20, 0x52, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x61, 0x20,
    0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2c, 0x20,
    0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x68, 0x6f, 0x6c, 0x64, 0x20, 0x6f,
    0x6e, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74,
    0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x49, 0x6e, 0x20, 0x6f, 0x72,
    0x64, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20, 0x61, 0x6e, 0x20,
    0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69,
    0x6e, 0x65, 0x2c, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x68, 0x6f,
    0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x60, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x60, 0x69, 0x70,
    0x60, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x20,
    0x48, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x63, 0x61, 0x73, 0x65, 0x2d, 0x73, 0x65, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x76, 0x65, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0b, 0x01, 0x12, 0x04, 0xa1, 0x01, 0x08, 0x11, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x0b, 0x02, 0x00, 0x12, 0x04, 0xa2, 0x01, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xa2, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xa2, 0x01, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12,
    0x04, 0xa3, 0x01, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa3, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3,
    0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x01,
    0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x01, 0x17,
    0x18, 0x0a, 0x9a, 0x01, 0x0a, 0x02, 0x04, 0x0c, 0x12, 0x06, 0xab, 0x01, 0x00, 0xc7, 0x01, 0x01,
    0x1a, 0x8b, 0x01, 0x2a, 0x0a, 0x20, 0x48, 0x6f, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f,
    0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x61, 0x20,
    0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2c, 0x20,
    0x69, 0x74, 0x73, 0x20, 0x60, 0x6d, 0x6f, 0x64, 0x65, 0x60, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x61, 0x6e, 0x79, 0x20, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x0a, 0x20, 0x72, 0x65, 0x6c, 0x65, 0x76,
    0x61, 0x6e, 0x74, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x61, 0x66, 0x66, 0x65, 0x63, 0x74,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0c, 0x01, 0x12, 0x04, 0xab, 0x01, 0x08, 0x13, 0x0a, 0x96, 0x01, 0x0a, 0x04,
    0x04, 0x0c, 0x04, 0x00, 0x12, 0x06, 0xae, 0x01, 0x02, 0xbe, 0x01, 0x03, 0x1a, 0x85, 0x01, 0x20,
    0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65,
    0x76, 0x65, 0x72, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x62, 0x65, 0x20, 0x69, 0x6e, 0x2e, 0x20, 0x20, 0x41, 0x20, 0x60, 0x4d, 0x6f, 0x64, 0x65, 0x60,
    0x0a, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x6d,
    0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6c,
    0x6c, 0x20, 0x61, 0x73, 0x73, 0x6f, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69,
    0x6e, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x04, 0x00, 0x01, 0x12, 0x04, 0xae,
    0x01, 0x07, 0x0b, 0x0a, 0x6a, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb1,
    0x01, 0x04, 0x0b, 0x1a, 0x5a, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x6f,
    0x64, 0x65, 0x2c, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6e, 0x67, 0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c,
    0x6c, 0x79, 0x3b, 0x0a, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x04, 0x06,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xb1, 0x01, 0x09,
    0x0a, 0x0a, 0xd5, 0x02, 0x0a, 0x06, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x01,
    0x04, 0x11, 0x1a, 0xc4, 0x02, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x6f,
    0x64, 0x65, 0x2c, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x6f,
    0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
    0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x72, 0x61, 0x69,
    0x6e, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2e, 0x20, 0x20, 0x49, 0x6e,
    0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x2c, 0x20, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x69, 0x73, 0x20, 0x64, 0x6f, 0x6e, 0x65, 0x20, 0x61, 0x68, 0x65, 0x61, 0x64,
    0x20, 0x6f, 0x66, 0x0a, 0x20, 0x61, 0x20, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x60,
    0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x60, 0x2e,
    0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x64, 0x72, 0x61, 0x69, 0x6e, 0x65,
    0x64, 0x20, 0x73, 0x6f, 0x20, 0x61, 0x73, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x6d, 0x61, 0x78, 0x69,
    0x6d, 0x69, 0x7a, 0x65, 0x20, 0x75, 0x74, 0x69, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61,
    0x69, 0x6e, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x62, 0x75, 0x74, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x6c, 0x79, 0x0a,
    0x20, 0x76, 0x69, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x27, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69,
    0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x01, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c,
    0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xb8, 0x01, 0x0f, 0x10, 0x0a, 0xb6, 0x01, 0x0a, 0x06,
    0x04, 0x0c, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xbd, 0x01, 0x04, 0x0d, 0x1a, 0xa5, 0x01, 0x20,
    0x49, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2c, 0x20, 0x61, 0x20,
    0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x72,
    0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6f, 0x66,
    0x66, 0x65, 0x72, 0x0a, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x69, 0x74, 0x73, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2e, 0x20, 0x20, 0x41, 0x67, 0x65, 0x6e,
    0x74, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
    0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x6c,
    0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74,
    0x65, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xbd, 0x01, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0c, 0x04, 0x00, 0x02, 0x02, 0x02,
    0x12, 0x04, 0xbd, 0x01, 0x0b, 0x0c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00, 0x12, 0x04,
    0xc0, 0x01, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0,
    0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc0, 0x01,
    0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x15,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc0, 0x01, 0x1a, 0x1b,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x02, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc1, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc1, 0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x01, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc1, 0x01, 0x17, 0x18, 0x0a, 0xd4, 0x01, 0x0a, 0x04, 0x04,
    0x0c, 0x02, 0x02, 0x12, 0x04, 0xc6, 0x01, 0x02, 0x2d, 0x1a, 0xc5, 0x01, 0x20, 0x53, 0x69, 0x67,
    0x6e, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e,
    0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x74, 0x65,
    0x72, 0x76, 0x61, 0x6c, 0x2e, 0x0a, 0x20, 0x53, 0x65, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x65,
    0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x60, 0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61,
    0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x60, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x60, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x60, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x0a, 0x20, 0x69, 0x6e, 0x20,
    0x60, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x60, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x60, 0x49, 0x6e, 0x76,
    0x65, 0x72, 0x73, 0x65, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x60, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d,
    0x6f, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc6, 0x01, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x06, 0x12, 0x04, 0xc6, 0x01, 0x0b, 0x19, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x01, 0x1a, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc6, 0x01, 0x2b, 0x2c, 0x0a, 0x28, 0x0a,
    0x02, 0x04, 0x0d, 0x12, 0x06, 0xcd, 0x01, 0x00, 0xa3, 0x02, 0x01, 0x1a, 0x1a, 0x2a, 0x0a, 0x20,
    0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04,
    0xcd, 0x01, 0x08, 0x15, 0x0a, 0xc3, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x00, 0x12, 0x04, 0xd1,
    0x01, 0x02, 0x1b, 0x1a, 0xb4, 0x01, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64,
    0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x55, 0x6e, 0x69,
    0x78, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x72, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x0a, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63,
    0x68, 0x65, 0x64, 0x20, 0x61, 0x73, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75,
    0x73, 0x65, 0x72, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74,
    0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x6d, 0x70, 0x74, 0x79, 0x20, 0x73, 0x74, 0x72,
    0x69, 0x6e, 0x67, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x67, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72,
    0x65, 0x6e, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xd1, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd1, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd1, 0x01, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xd1, 0x01, 0x19, 0x1a, 0x0a, 0x48, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04,
    0xd4, 0x01, 0x02, 0x1b, 0x1a, 0x3a, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x73, 0x68, 0x6f, 0x77, 0x73, 0x20, 0x75, 0x70, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x57, 0x65, 0x62, 0x20, 0x55, 0x49, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd4, 0x01, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd4, 0x01, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd4, 0x01, 0x12, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd4, 0x01, 0x19, 0x1a, 0x0a, 0xff, 0x01, 0x0a,
    0x04, 0x04, 0x0d, 0x02, 0x02, 0x12, 0x04, 0xdb, 0x01, 0x02, 0x1e, 0x1a, 0xf0, 0x01, 0x20, 0x4e,
    0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x27, 0x69, 0x64, 0x27, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20,
    0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x68, 0x61, 0x73, 0x0a, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65,
    0x64, 0x2c, 0x20, 0x68, 0x6f, 0x77, 0x65, 0x76, 0x65, 0x72, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69,
    0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20,
    0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x63, 0x69,
    0x6c, 0x69, 0x74, 0x61, 0x74, 0x65, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e,
    0x2c, 0x20, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74,
    0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x53, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x65, 0x78,
    0x70, 0x65, 0x63, 0x74, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x69, 0x6e,
    0x67, 0x0a, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x6f, 0x76, 0x65, 0x72, 0x29, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdb, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x02, 0x06, 0x12, 0x04, 0xdb, 0x01, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdb, 0x01, 0x17, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdb, 0x01, 0x1c, 0x1d, 0x0a, 0x9e, 0x03, 0x0a, 0x04, 0x04,
    0x0d, 0x02, 0x03, 0x12, 0x04, 0xe5, 0x01, 0x02, 0x37, 0x1a, 0x8f, 0x03, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,
    0x28, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x29, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x77, 0x61, 0x69, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20,
    0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x74, 0x20,
    0x74, 0x65, 0x61, 0x72, 0x73, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x6b, 0x69, 0x6c,
    0x6c, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x69, 0x74, 0x73, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x6e, 0x6f, 0x6e,
    0x2d, 0x7a, 0x65, 0x72, 0x6f, 0x20, 0x69, 0x66, 0x20, 0x61, 0x0a, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x73, 0x20, 0x74, 0x6f,
    0x20, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72,
    0x20, 0x61, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x73, 0x65, 0x20, 0x69, 0x74, 0x73, 0x0a, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x73, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x20,
    0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x6f, 0x20, 0x61, 0x76, 0x6f, 0x69, 0x64, 0x20, 0x61,
    0x63, 0x63, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 0x75,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x2c, 0x20,
    0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x79, 0x70, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x6c,
    0x61, 0x72, 0x67, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e,
    0x2c, 0x20, 0x31, 0x20, 0x77, 0x65, 0x65, 0x6b, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe5, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xe5, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xe5, 0x01, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xe5, 0x01, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x08,
    0x12, 0x04, 0xe5, 0x01, 0x27, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x07, 0x12,
    0x04, 0xe5, 0x01, 0x32, 0x35, 0x0a, 0xef, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x04, 0x12, 0x04,
    0xeb, 0x01, 0x02, 0x31, 0x1a, 0xe0, 0x01, 0x20, 0x49, 0x66, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x70, 0x69, 0x64, 0x2c, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x70, 0x69, 0x64, 0x73, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x20,
    0x61, 0x72, 0x65, 0x0a, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x20, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f,
    0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x0a,
    0x20, 0x72, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x65, 0x64, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74,
    0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x6f, 0x6c, 0x64, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x0a, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x61, 0x74,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x69, 0x73,
    0x6b, 0x20, 0x49, 0x2f, 0x4f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xeb, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xeb, 0x01, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xeb, 0x01, 0x10, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x03, 0x12, 0x04, 0xeb,
    0x01, 0x1d, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x08, 0x12, 0x04, 0xeb, 0x01,
    0x1f, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x04, 0x07, 0x12, 0x04, 0xeb, 0x01, 0x2a,
    0x2f, 0x0a, 0x72, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x05, 0x12, 0x04, 0xef, 0x01, 0x02, 0x2b, 0x1a,
    0x64, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61,
    0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x65, 0x63, 0x69, 0x73, 0x69,
    0x6f, 0x6e, 0x73, 0x2c, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x6f,
    0x6e, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x75,
    0x73, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xef, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x05, 0x12, 0x04, 0xef,
    0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x01, 0x12, 0x04, 0xef, 0x01,
    0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x03, 0x12, 0x04, 0xef, 0x01, 0x19,
    0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x08, 0x12, 0x04, 0xef, 0x01, 0x1b, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x05, 0x07, 0x12, 0x04, 0xef, 0x01, 0x26, 0x29, 0x0a,
    0xd8, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x06, 0x12, 0x04, 0xf5, 0x01, 0x02, 0x1f, 0x1a, 0xc9,
    0x01, 0x20, 0x55, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x68,
    0x6f, 0x73, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x69, 0x73, 0x0a,
    0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x57, 0x65, 0x62, 0x20, 0x55, 0x49, 0x2e,
    0x20, 0x49, 0x66, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x6d,
    0x70, 0x74, 0x79, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73,
    0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x67, 0x69, 0x63,
    0x61, 0x6c, 0x6c, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e,
    0x61, 0x6d, 0x65, 0x20, 0x69, 0x66, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61,
    0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x06, 0x04, 0x12, 0x04, 0xf5, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x06, 0x05, 0x12, 0x04, 0xf5, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06,
    0x01, 0x12, 0x04, 0xf5, 0x01, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x06, 0x03,
    0x12, 0x04, 0xf5, 0x01, 0x1d, 0x1e, 0x0a, 0x90, 0x02, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x07, 0x12,
    0x04, 0xfb, 0x01, 0x02, 0x20, 0x1a, 0x81, 0x02, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69,
    0x65, 0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x27,
    0x73, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x73, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69,
    0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x41, 0x50, 0x49, 0x0a, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6c,
    0x69, 0x6d, 0x69, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x79, 0x6e, 0x61,
    0x6d, 0x69, 0x63, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
    0x2e, 0x20, 0x49, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73,
    0x65, 0x74, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x0a, 0x20, 0x69, 0x66, 0x20, 0x61, 0x75, 0x74, 0x68,
    0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x73, 0x65, 0x20, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x64, 0x65, 0x73, 0x69, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x07, 0x04, 0x12, 0x04, 0xfb, 0x01, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07,
    0x05, 0x12, 0x04, 0xfb, 0x01, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07, 0x01,
    0x12, 0x04, 0xfb, 0x01, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xfb, 0x01, 0x1e, 0x1f, 0x0a, 0xc6, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x08, 0x12, 0x04,
    0x80, 0x02, 0x02, 0x20, 0x1a, 0xb7, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69,
    0x73, 0x65, 0x20, 0x69, 0x74, 0x73, 0x20, 0x77, 0x65, 0x62, 0x20, 0x55, 0x49, 0x2c, 0x20, 0x73,
    0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f,
    0x73, 0x20, 0x77, 0x65, 0x62, 0x20, 0x55, 0x49, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6c, 0x69, 0x6e,
    0x6b, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x74, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x65,
    0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x61, 0x20,
    0x66, 0x75, 0x6c, 0x6c, 0x20, 0x55, 0x52, 0x4c, 0x2c, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65,
    0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x6d, 0x79,
    0x2d, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x2e, 0x65, 0x78, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x2e, 0x63, 0x6f, 0x6d, 0x3a, 0x38, 0x30, 0x38, 0x30, 0x2f, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0d, 0x02, 0x08, 0x04, 0x12, 0x04, 0x80, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x08, 0x05, 0x12, 0x04, 0x80, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x08, 0x01, 0x12, 0x04, 0x80, 0x02, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x08, 0x03, 0x12, 0x04, 0x80, 0x02, 0x1e, 0x1f, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0d,
    0x03, 0x00, 0x12, 0x06, 0x82, 0x02, 0x02, 0x97, 0x02, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x03, 0x00, 0x01, 0x12, 0x04, 0x82, 0x02, 0x0a, 0x14, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x0d, 0x03,
    0x00, 0x04, 0x00, 0x12, 0x06, 0x83, 0x02, 0x04, 0x93, 0x02, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0d, 0x03, 0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0x83, 0x02, 0x09, 0x0d, 0x0a, 0xdf, 0x01, 0x0a,
    0x08, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0x88, 0x02, 0x06, 0x12, 0x1a,
    0xcc, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x65, 0x6e, 0x75, 0x6d, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6c, 0x69, 0x73,
    0x74, 0x2c, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x65, 0x6e, 0x73, 0x75, 0x72, 0x65, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x69, 0x66, 0x20, 0x27, 0x74, 0x79, 0x70, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x55,
    0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61,
    0x62, 0x6c, 0x65, 0x73, 0x20, 0x65, 0x6e, 0x75, 0x6d, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x61, 0x64, 0x64, 0x65, 0x64, 0x0a, 0x20, 0x69, 0x6e,
    0x20, 0x61, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x77, 0x61, 0x72, 0x64, 0x73, 0x2d, 0x63, 0x6f, 0x6d,
    0x70, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x77, 0x61, 0x79, 0x2e, 0x20, 0x53, 0x65, 0x65,
    0x3a, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x34, 0x39, 0x39, 0x37, 0x2e, 0x0a, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x02, 0x06,
    0x0d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04,
    0x88, 0x02, 0x10, 0x11, 0x0a, 0x8a, 0x01, 0x0a, 0x08, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02,
    0x01, 0x12, 0x04, 0x8d, 0x02, 0x06, 0x1e, 0x1a, 0x78, 0x20, 0x52, 0x65, 0x63, 0x65, 0x69, 0x76,
    0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x72, 0x65,
    0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x73, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x27, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x27, 0x0a, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x64,
    0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x76, 0x69,
    0x6e, 0x6f, 0x64, 0x29, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75,
    0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x20, 0x6e, 0x6f, 0x2d, 0x6f, 0x70, 0x2e,
    0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x8d, 0x02, 0x06, 0x19, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01,
    0x02, 0x12, 0x04, 0x8d, 0x02, 0x1c, 0x1d, 0x0a, 0xbe, 0x01, 0x0a, 0x08, 0x04, 0x0d, 0x03, 0x00,
    0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0x92, 0x02, 0x06, 0x1d, 0x1a, 0xab, 0x01, 0x20, 0x52, 0x65,
    0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b,
    0x49, 0x4c, 0x4c, 0x49, 0x4e, 0x47, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x65,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x69, 0x73, 0x20,
    0x62, 0x65, 0x69, 0x6e, 0x67, 0x0a, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x65, 0x78, 0x61, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x63, 0x61,
    0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65,
    0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x69, 0x74,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b,
    0x49, 0x4c, 0x4c, 0x49, 0x4e, 0x47, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x0d, 0x03, 0x00,
    0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x92, 0x02, 0x06, 0x18, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x0d, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0x92, 0x02, 0x1b, 0x1c, 0x0a, 0x42,
    0x0a, 0x06, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x96, 0x02, 0x04, 0x1b, 0x1a, 0x32,
    0x20, 0x45, 0x6e, 0x75, 0x6d, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x73, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x2c,
    0x20, 0x73, 0x65, 0x65, 0x3a, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x34, 0x39, 0x39, 0x37,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x96,
    0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04,
    0x96, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x96, 0x02, 0x12, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0d, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x96, 0x02, 0x19, 0x1a, 0x0a, 0x90, 0x01, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x09, 0x12,
    0x04, 0x9c, 0x02, 0x02, 0x28, 0x1a, 0x81, 0x01, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69,
    0x65, 0x6c, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74,
    0x69, 0x73, 0x65, 0x20, 0x69, 0x74, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x0a, 0x20,
    0x63, 0x61, 0x70, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x20, 0x28, 0x65, 0x2e,
    0x67, 0x2e, 0x2c, 0x20, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x72,
    0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x72, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x09, 0x04, 0x12, 0x04, 0x9c, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x09,
    0x06, 0x12, 0x04, 0x9c, 0x02, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x09, 0x01,
    0x12, 0x04, 0x9c, 0x02, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x09, 0x03, 0x12,
    0x04, 0x9c, 0x02, 0x25, 0x27, 0x0a, 0x8a, 0x02, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x0a, 0x12, 0x04,
    0xa2, 0x02, 0x02, 0x1e, 0x1a, 0xfb, 0x01, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65, 0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x73, 0x75, 0x70,
    0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20,
    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66,
    0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x29, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x73, 0x65, 0x20,
    0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69,
    0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65,
    0x73, 0x6f, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x2e, 0x0a, 0x20, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x20, 0x6b, 0x65, 0x79, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xa2, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x0a, 0x06, 0x12, 0x04, 0xa2, 0x02, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xa2, 0x02, 0x12, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xa2, 0x02, 0x1b, 0x1d, 0x0a, 0x80,
    0x02, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0xac, 0x02, 0x00, 0xdd, 0x02, 0x01, 0x1a, 0xf1, 0x01,
    0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x68,
    0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x20, 0x28, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74,
    0x72, 0x61, 0x72, 0x79, 0x0a, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x2f, 0x63, 0x6f,
    0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x29, 0x2e, 0x20, 0x41, 0x20, 0x22, 0x73, 0x74, 0x72, 0x61, 0x74,
    0x65, 0x67, 0x79, 0x22, 0x20, 0x69, 0x73, 0x20, 0x70, 0x69, 0x63, 0x6b, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61,
    0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x3b, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e,
    0x74, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x27, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x2e,
    0x0a, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x6f, 0x72,
    0x65, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x73, 0x74, 0x72, 0x61, 0x74,
    0x65, 0x67, 0x79, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0xac, 0x02, 0x08, 0x13, 0x0a, 0x7e,
    0x0a, 0x04, 0x04, 0x0e, 0x03, 0x00, 0x12, 0x06, 0xaf, 0x02, 0x02, 0xc0, 0x02, 0x03, 0x1a, 0x6e,
    0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x48, 0x54,
    0x54, 0x50, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x66, 0x75, 0x6c,
    0x6c, 0x79, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
    0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x65,
    0x65, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x32, 0x35, 0x33, 0x33, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x03, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x02, 0x0a, 0x0e, 0x0a, 0x30, 0x0a,
    0x06, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb1, 0x02, 0x04, 0x1d, 0x1a, 0x20, 0x20,
    0x50, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb1, 0x02, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb1, 0x02, 0x0d,
    0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb1, 0x02,
    0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb1,
    0x02, 0x1b, 0x1c, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb4,
    0x02, 0x04, 0x2d, 0x1a, 0x14, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb4, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0e,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb4, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0e, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb4, 0x02, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0e, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb4, 0x02, 0x1b, 0x1c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x01, 0x08, 0x12, 0x04, 0xb4, 0x02, 0x1d, 0x2c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x01, 0x07, 0x12, 0x04, 0xb4, 0x02, 0x28, 0x2b, 0x0a,
    0x7a, 0x0a, 0x06, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xbc, 0x02, 0x04, 0x21, 0x1a,
    0x6a, 0x20, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x4e, 0x6f,
    0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x79,
    0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x65,
    0x73, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65, 0x74, 0x75,
    0x72, 0x6e, 0x65, 0x64, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x63, 0x63, 0x65, 0x70, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0e, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbc, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0e, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbc, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x02, 0x14, 0x1c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0e, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbc, 0x02, 0x1f, 0x20, 0x0a,
    0x50, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x19, 0x1a, 0x42, 0x20,
    0x48, 0x54, 0x54, 0x50, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63,
    0x6b, 0x20, 0x2d, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x79, 0x65, 0x74, 0x20, 0x72, 0x65, 0x63, 0x6f,
    0x6d, 0x6d, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x75, 0x73, 0x65, 0x2c,
    0x20, 0x73, 0x65, 0x65, 0x20, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x32, 0x35, 0x33, 0x33, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc3, 0x02, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc3, 0x02, 0x10, 0x14, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x02, 0x17, 0x18, 0x0a, 0x48, 0x0a,
    0x04, 0x04, 0x0e, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x02, 0x02, 0x35, 0x1a, 0x3a, 0x20, 0x41, 0x6d,
    0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20,
    0x77, 0x61, 0x69, 0x74, 0x20, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63,
    0x68, 0x65, 0x63, 0x6b, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xcd, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xcd, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xcd, 0x02, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd,
    0x02, 0x22, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x08, 0x12, 0x04, 0xcd, 0x02,
    0x24, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x01, 0x07, 0x12, 0x04, 0xcd, 0x02, 0x2f,
    0x33, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x02, 0x12, 0x04, 0xd0, 0x02, 0x02, 0x38, 0x1a,
    0x21, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65,
    0x65, 0x6e, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd0, 0x02, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x02, 0x12, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd0, 0x02, 0x25, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x02, 0x08, 0x12, 0x04, 0xd0, 0x02, 0x27, 0x37, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x02, 0x07, 0x12, 0x04, 0xd0, 0x02, 0x32, 0x36, 0x0a, 0x48, 0x0a, 0x04,
    0x04, 0x0e, 0x02, 0x03, 0x12, 0x04, 0xd3, 0x02, 0x02, 0x37, 0x1a, 0x3a, 0x20, 0x41, 0x6d, 0x6f,
    0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x77,
    0x61, 0x69, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c,
    0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6d, 0x70,
    0x6c, 0x65, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xd3, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xd3, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd3,
    0x02, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd3, 0x02,
    0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x08, 0x12, 0x04, 0xd3, 0x02, 0x26,
    0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x03, 0x07, 0x12, 0x04, 0xd3, 0x02, 0x31, 0x35,
    0x0a, 0x49, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x04, 0x12, 0x04, 0xd6, 0x02, 0x02, 0x39, 0x1a, 0x3b,
    0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x65,
    0x63, 0x75, 0x74, 0x69, 0x76, 0x65, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x20,
    0x75, 0x6e, 0x74, 0x69, 0x6c, 0x20, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x20,
    0x6b, 0x69, 0x6c, 0x6c, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd6, 0x02, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xd6, 0x02, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xd6, 0x02, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xd6, 0x02, 0x29, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04, 0x08,
    0x12, 0x04, 0xd6, 0x02, 0x2b, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x04, 0x07, 0x12,
    0x04, 0xd6, 0x02, 0x36, 0x37, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x0e, 0x02, 0x05, 0x12, 0x04, 0xd9,
    0x02, 0x02, 0x3c, 0x1a, 0x3c, 0x20, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x65, 0x64, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63,
    0x6b, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd9, 0x02, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd9, 0x02, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd9, 0x02, 0x12, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0e, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd9, 0x02, 0x29, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0e, 0x02, 0x05, 0x08, 0x12, 0x04, 0xd9, 0x02, 0x2b, 0x3b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x05, 0x07, 0x12, 0x04, 0xd9, 0x02, 0x36, 0x3a, 0x0a, 0x25, 0x0a, 0x04, 0x04,
    0x0e, 0x02, 0x06, 0x12, 0x04, 0xdc, 0x02, 0x02, 0x23, 0x1a, 0x17, 0x20, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x06, 0x04, 0x12, 0x04, 0xdc, 0x02, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x06, 0x06, 0x12, 0x04, 0xdc, 0x02, 0x0b, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x06, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x17, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02, 0x06, 0x03, 0x12, 0x04, 0xdc, 0x02, 0x21, 0x22, 0x0a, 0xd5,
    0x04, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06, 0xea, 0x02, 0x00, 0x9b, 0x03, 0x01, 0x1a, 0xc6, 0x04,
    0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x64,
    0x20, 0x76, 0x69, 0x61, 0x3a, 0x20, 0x27, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x20, 0x2d,
    0x63, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x2e, 0x20, 0x41, 0x6e, 0x79, 0x20, 0x55, 0x52,
    0x49, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x0a, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63,
    0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x20, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x75, 0x72, 0x69, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x65, 0x74, 0x2c, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20,
    0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6f,
    0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x0a, 0x20,
    0x4f, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x66, 0x69, 0x6c,
    0x65, 0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a,
    0x65, 0x64, 0x20, 0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e,
    0x73, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x28, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79,
    0x20, 0x5b, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x5d, 0x20, 0x74, 0x61,
    0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x7a, 0x69, 0x70, 0x29, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x27, 0x73, 0x0a, 0x20,
    0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72,
    0x79, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x60, 0x65,
    0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x60, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x66, 0x61, 0x6c, 0x73,
    0x65, 0x2e, 0x20, 0x49, 0x6e, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20,
    0x61, 0x6e, 0x79, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20,
    0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
    0x6e, 0x67, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x20,
    0x28, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x22, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74,
    0x65, 0x72, 0x69, 0x7a, 0x65, 0x22, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0xea,
    0x02, 0x08, 0x13, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x0f, 0x03, 0x00, 0x12, 0x06, 0xeb, 0x02, 0x02,
    0x80, 0x03, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x03, 0x00, 0x01, 0x12, 0x04, 0xeb, 0x02,
    0x0a, 0x0d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xec, 0x02,
    0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xec,
    0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xec, 0x02, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xec, 0x02, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xec, 0x02, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x01,
    0x12, 0x04, 0xed, 0x02, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xed, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xed, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xed, 0x02, 0x12, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03,
    0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xed, 0x02, 0x1f, 0x20, 0x0a, 0xf5, 0x01, 0x0a, 0x06, 0x04,
    0x0f, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf3, 0x02, 0x04, 0x2f, 0x1a, 0xe4, 0x01, 0x20, 0x49,
    0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68,
    0x65, 0x64, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x63, 0x6f, 0x67,
    0x6e, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x72, 0x63, 0x68,
    0x69, 0x76, 0x65, 0x2c, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x0a, 0x20, 0x69, 0x74,
    0x73, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x2e, 0x20, 0x4e, 0x6f, 0x74,
    0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20,
    0x61, 0x72, 0x63, 0x68, 0x69, 0x76, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x63, 0x6f, 0x70, 0x69, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6e,
    0x64, 0x62, 0x6f, 0x78, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x65, 0x78, 0x74,
    0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61,
    0x74, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x72, 0x63, 0x68,
    0x69, 0x76, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf3,
    0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04,
    0xf3, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xf3, 0x02, 0x12, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xf3, 0x02, 0x1c, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x02,
    0x08, 0x12, 0x04, 0xf3, 0x02, 0x1e, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02,
    0x02, 0x07, 0x12, 0x04, 0xf3, 0x02, 0x29, 0x2d, 0x0a, 0xe0, 0x04, 0x0a, 0x06, 0x04, 0x0f, 0x03,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xff, 0x02, 0x04, 0x1c, 0x1a, 0xcf, 0x04, 0x20, 0x49, 0x66, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x22, 0x74,
    0x72, 0x75, 0x65, 0x22, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65,
    0x72, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x2c, 0x0a, 0x20, 0x66,
    0x65, 0x74, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x65, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64,
    0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6c,
    0x79, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x61, 0x6e, 0x64,
    0x62, 0x6f, 0x78, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x2c, 0x20, 0x6e,
    0x6f, 0x20, 0x6d, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72,
    0x20, 0x61, 0x20, 0x73, 0x75, 0x69, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68,
    0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x72, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x64,
    0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x66, 0x69, 0x6c, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x6e,
    0x20, 0x63, 0x6f, 0x70, 0x79, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x2e,
    0x20, 0x53, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x74, 0x0a, 0x20, 0x66, 0x65, 0x74,
    0x63, 0x68, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x55, 0x52, 0x49, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x6f, 0x6d, 0x69, 0x74, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
    0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x6f, 0x70, 0x79, 0x0a, 0x20, 0x66, 0x72,
    0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x61, 0x73, 0x20,
    0x6c, 0x6f, 0x6e, 0x67, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65,
    0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x72, 0x65, 0x2e, 0x20, 0x43, 0x61, 0x63, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x0a,
    0x20, 0x6d, 0x61, 0x79, 0x20, 0x67, 0x65, 0x74, 0x20, 0x65, 0x76, 0x69, 0x63, 0x74, 0x65, 0x64,
    0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20, 0x77, 0x68,
    0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x6c, 0x65, 0x61, 0x64, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x65, 0x64, 0x0a, 0x20, 0x64, 0x6f, 0x77, 0x6e, 0x6c,
    0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x20, 0x61, 0x6c, 0x73, 0x6f,
    0x20, 0x22, 0x64, 0x6f, 0x63, 0x73, 0x2f, 0x66, 0x65, 0x74, 0x63, 0x68, 0x65, 0x72, 0x2e, 0x6d,
    0x64, 0x22, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20, 0x22, 0x64, 0x6f, 0x63, 0x73, 0x2f, 0x66, 0x65,
    0x74, 0x63, 0x68, 0x65, 0x72, 0x2d, 0x63, 0x61, 0x63, 0x68, 0x65, 0x2d, 0x69, 0x6e, 0x74, 0x65,
    0x72, 0x6e, 0x61, 0x6c, 0x73, 0x2e, 0x6d, 0x64, 0x22, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x0f, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xff, 0x02, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x0f, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xff, 0x02, 0x0d, 0x11, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xff, 0x02, 0x12, 0x17, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x0f, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xff, 0x02, 0x1a, 0x1b, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0x82, 0x03, 0x02, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x00, 0x06, 0x12, 0x04, 0x82, 0x03, 0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x03, 0x0f, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x03, 0x16, 0x17, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02,
    0x01, 0x12, 0x04, 0x84, 0x03, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x84, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x06, 0x12,
    0x04, 0x84, 0x03, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x84, 0x03, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12, 0x04, 0x84,
    0x03, 0x25, 0x26, 0x0a, 0xfb, 0x05, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x02, 0x12, 0x04, 0x93, 0x03,
    0x02, 0x2b, 0x1a, 0xec, 0x05, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x74, 0x77, 0x6f, 0x20, 0x77, 0x61, 0x79, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x3a,
    0x0a, 0x20, 0x31, 0x29, 0x20, 0x49, 0x66, 0x20, 0x27, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x20, 0x3d,
    0x3d, 0x20, 0x74, 0x72, 0x75, 0x65, 0x27, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d,
    0x6d, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x61, 0x75,
    0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x76, 0x69, 0x61, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x0a,
    0x09, 0x09, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68,
    0x20, 0x2d, 0x63, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x29, 0x2e, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x69, 0x65, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x0a, 0x09, 0x09, 0x74, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x68, 0x65,
    0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x27, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x27, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x62, 0x65, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x20, 0x32, 0x29,
    0x20, 0x49, 0x66, 0x20, 0x27, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x20, 0x3d, 0x3d, 0x20, 0x66, 0x61,
    0x6c, 0x73, 0x65, 0x27, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x70, 0x61, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x0a, 0x09, 0x09,
    0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65,
    0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x0a, 0x09, 0x09, 0x74, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x6e,
    0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x61, 0x72, 0x67, 0x75,
    0x6d, 0x65, 0x6e, 0x74, 0x73, 0x27, 0x0a, 0x09, 0x09, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65,
    0x20, 0x74, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x0a, 0x09, 0x09, 0x73, 0x69, 0x6d, 0x69, 0x6c, 0x61, 0x72, 0x20, 0x74,
    0x6f, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x50, 0x4f, 0x53, 0x49, 0x58, 0x20, 0x65, 0x78, 0x65, 0x63,
    0x20, 0x66, 0x61, 0x6d, 0x69, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68,
    0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e,
    0x2c, 0x0a, 0x09, 0x09, 0x65, 0x78, 0x65, 0x63, 0x6c, 0x70, 0x28, 0x76, 0x61, 0x6c, 0x75, 0x65,
    0x2c, 0x20, 0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x28, 0x30, 0x29, 0x2c, 0x20,
    0x61, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x28, 0x31, 0x29, 0x2c, 0x20, 0x2e, 0x2e,
    0x2e, 0x29, 0x29, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x27, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x27, 0x20, 0x69, 0x73,
    0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x27, 0x72,
    0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x27, 0x20, 0x74, 0x6f, 0x20, 0x27, 0x6f, 0x70, 0x74,
    0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x27, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x30, 0x2e,
    0x30, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20,
    0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x73, 0x20, 0x69, 0x66, 0x20,
    0x61, 0x20, 0x6e, 0x65, 0x77, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x69, 0x73, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x6f, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x04, 0x12, 0x04, 0x93, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x05, 0x12, 0x04, 0x93, 0x03, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0x93, 0x03, 0x10, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x03, 0x12, 0x04, 0x93, 0x03, 0x18, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x02, 0x08, 0x12, 0x04, 0x93, 0x03, 0x1a, 0x2a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x02, 0x07, 0x12, 0x04, 0x93, 0x03, 0x25, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x03, 0x12, 0x04, 0x94, 0x03, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x94, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03,
    0x05, 0x12, 0x04, 0x94, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x01,
    0x12, 0x04, 0x94, 0x03, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x03, 0x03, 0x12,
    0x04, 0x94, 0x03, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x04, 0x12, 0x04, 0x95,
    0x03, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x04, 0x12, 0x04, 0x95, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x05, 0x12, 0x04, 0x95, 0x03, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x01, 0x12, 0x04, 0x95, 0x03, 0x12, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x04, 0x03, 0x12, 0x04, 0x95, 0x03, 0x1e, 0x1f, 0x0a,
    0xb2, 0x01, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x05, 0x12, 0x04, 0x9a, 0x03, 0x02, 0x1b, 0x1a, 0xa3,
    0x01, 0x20, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20,
    0x72, 0x75, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x63, 0x20, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75,
    0x73, 0x65, 0x72, 0x0a, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72,
    0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x20, 0x69, 0x6e, 0x20, 0x46, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x68, 0x65, 0x72, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e,
    0x64, 0x49, 0x6e, 0x66, 0x6f, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x76, 0x61, 0x6c, 0x75,
    0x65, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x73, 0x20, 0x70, 0x72, 0x65, 0x63, 0x65, 0x64, 0x65, 0x6e,
    0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x04, 0x12, 0x04, 0x9a,
    0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x05, 0x12, 0x04, 0x9a, 0x03,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x12,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x05, 0x03, 0x12, 0x04, 0x9a, 0x03, 0x19, 0x1a,
    0x0a, 0x80, 0x01, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0xa2, 0x03, 0x00, 0xbd, 0x03, 0x01, 0x1a,
    0x72, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20,
    0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x27, 0x64, 0x61, 0x74, 0x61, 0x27, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x61,
    0x73, 0x73, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72, 0x61, 0x72, 0x79, 0x20, 0x62, 0x79, 0x74,
    0x65, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0xa2, 0x03, 0x08, 0x14,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x00, 0x12, 0x04, 0xa3, 0x03, 0x02, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa3, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa3, 0x03, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x03, 0x24, 0x25, 0x0a, 0x2f, 0x0a, 0x04, 0x04, 0x10,
    0x02, 0x01, 0x12, 0x04, 0xa4, 0x03, 0x02, 0x28, 0x22, 0x21, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28,
    0x62, 0x65, 0x6e, 0x68, 0x29, 0x3a, 0x20, 0x4d, 0x61, 0x6b, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa4, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xa4, 0x03, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xa4, 0x03, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xa4, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x02, 0x12,
    0x04, 0xa5, 0x03, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xa5, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x06, 0x12, 0x04, 0xa5,
    0x03, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x03,
    0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x03, 0x21,
    0x22, 0x0a, 0xa7, 0x01, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x03, 0x12, 0x04, 0xa9, 0x03, 0x02, 0x28,
    0x1a, 0x98, 0x01, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x70, 0x72, 0x6f,
    0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e,
    0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6c, 0x61, 0x75, 0x6e,
    0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x27, 0x73, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66,
    0x6f, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x65, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x74, 0x6f,
    0x0a, 0x20, 0x61, 0x63, 0x74, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa9, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x03, 0x06, 0x12, 0x04, 0xa9, 0x03, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xa9, 0x03, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xa9, 0x03, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x04, 0x12,
    0x04, 0xaa, 0x03, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xaa, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x06, 0x12, 0x04, 0xaa,
    0x03, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x01, 0x12, 0x04, 0xaa, 0x03,
    0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x04, 0x03, 0x12, 0x04, 0xaa, 0x03, 0x20,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x05, 0x12, 0x04, 0xab, 0x03, 0x02, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x04, 0x12, 0x04, 0xab, 0x03, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x10, 0x02, 0x05, 0x05, 0x12, 0x04, 0xab, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x05, 0x01, 0x12, 0x04, 0xab, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x05, 0x03, 0x12, 0x04, 0xab, 0x03, 0x19, 0x1a, 0x0a, 0x85, 0x03, 0x0a, 0x04,
    0x04, 0x10, 0x02, 0x06, 0x12, 0x04, 0xb4, 0x03, 0x02, 0x1e, 0x1a, 0xf6, 0x02, 0x20, 0x27, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x64, 0x65,
    0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x20, 0x73, 0x74, 0x79, 0x6c, 0x65, 0x20, 0x73, 0x74,
    0x72, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x63,
    0x6b, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x61, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x66, 0x75, 0x6c, 0x20, 0x77, 0x68, 0x65, 0x6e,
    0x20, 0x69, 0x74, 0x27, 0x73, 0x0a, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x65, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69, 0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,
    0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x73, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69,
    0x63, 0x61, 0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x27,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73,
    0x65, 0x64, 0x20, 0x61, 0x6c, 0x6f, 0x6e, 0x67, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x20, 0x76, 0x69, 0x61, 0x20, 0x4a, 0x53, 0x4f, 0x4e, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x6c,
    0x6f, 0x77, 0x73, 0x20, 0x75, 0x73, 0x65, 0x72, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6d, 0x70,
    0x6f, 0x72, 0x74, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72,
    0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x74, 0x69,
    0x6d, 0x65, 0x20, 0x73, 0x65, 0x72, 0x69, 0x65, 0x73, 0x20, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61,
    0x73, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x6e, 0x69, 0x74, 0x6f, 0x72, 0x69, 0x6e,
    0x67, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb4, 0x03,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x06, 0x05, 0x12, 0x04, 0xb4, 0x03, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb4, 0x03, 0x12, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb4, 0x03, 0x1b, 0x1d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x10, 0x02, 0x07, 0x12, 0x04, 0xb6, 0x03, 0x02, 0x1a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x10, 0x02, 0x07, 0x04, 0x12, 0x04, 0xb6, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x10, 0x02, 0x07, 0x05, 0x12, 0x04, 0xb6, 0x03, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x10, 0x02, 0x07, 0x01, 0x12, 0x04, 0xb6, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10,
    0x02, 0x07, 0x03, 0x12, 0x04, 0xb6, 0x03, 0x18, 0x19, 0x0a, 0xf9, 0x01, 0x0a, 0x04, 0x04, 0x10,
    0x02, 0x08, 0x12, 0x04, 0xbc, 0x03, 0x02, 0x28, 0x1a, 0xea, 0x01, 0x20, 0x53, 0x65, 0x72, 0x76,
    0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69,
    0x73, 0x20, 0x6e, 0x6f, 0x74, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74,
    0x65, 0x64, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e,
    0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x0a, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x79, 0x73, 0x74,
    0x65, 0x6d, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x6e, 0x65,
    0x65, 0x64, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x61, 0x6e, 0x64,
    0x6c, 0x65, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69,
    0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x04, 0x12, 0x04,
    0xbc, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x06, 0x12, 0x04, 0xbc,
    0x03, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x01, 0x12, 0x04, 0xbc, 0x03,
    0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x08, 0x03, 0x12, 0x04, 0xbc, 0x03, 0x25,
    0x27, 0x0a, 0xa9, 0x01, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xc5, 0x03, 0x00, 0xe4, 0x03, 0x01,
    0x1a, 0x9a, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x61, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x20, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x68, 0x61, 0x76,
    0x65, 0x20, 0x6d, 0x6f, 0x72, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x6e,
    0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x20, 0x77, 0x68, 0x69,
    0x63, 0x68, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x2c, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2c, 0x20, 0x74,
    0x6f, 0x20, 0x6c, 0x69, 0x6e, 0x6b, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x77, 0x65, 0x62, 0x75, 0x69, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x6d,
    0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x77, 0x65, 0x62, 0x75, 0x69, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11,
    0x02, 0x00, 0x12, 0x04, 0xc6, 0x03, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xc6, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xc6, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xc6, 0x03, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xc6, 0x03, 0x17, 0x18, 0x0a, 0x88, 0x01, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12, 0x04, 0xca,
    0x03, 0x02, 0x19, 0x1a, 0x7a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x20, 0x28, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x49, 0x50, 0x76, 0x34, 0x29,
    0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x64, 0x20, 0x34, 0x2d, 0x62,
    0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x2c, 0x0a, 0x20, 0x73,
    0x74, 0x6f, 0x72, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x2e, 0x20, 0x20, 0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61,
    0x74, 0x65, 0x64, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x20, 0x60, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x2e, 0x69, 0x70, 0x60, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x04, 0x12, 0x04, 0xca, 0x03, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x05, 0x12, 0x04, 0xca, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xca, 0x03, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x01, 0x03, 0x12, 0x04, 0xca, 0x03, 0x17, 0x18, 0x0a, 0x7c, 0x0a, 0x04, 0x04,
    0x11, 0x02, 0x02, 0x12, 0x04, 0xce, 0x03, 0x02, 0x2c, 0x1a, 0x6e, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x54, 0x43, 0x50, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x61, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x69, 0x6e, 0x67,
    0x20, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67,
    0x0a, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x3b,
    0x20, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x75, 0x73, 0x65,
    0x20, 0x60, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x70, 0x6f, 0x72, 0x74, 0x60, 0x20,
    0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xce, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xce, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xce, 0x03, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xce, 0x03, 0x19, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x08, 0x12, 0x04,
    0xce, 0x03, 0x1b, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x02, 0x07, 0x12, 0x04, 0xce,
    0x03, 0x26, 0x2a, 0x0a, 0xfa, 0x01, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x03, 0x12, 0x04, 0xd4, 0x03,
    0x02, 0x1a, 0x1a, 0xeb, 0x01, 0x20, 0x49, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x0a, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x62, 0x6f, 0x74, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x70,
    0x6f, 0x72, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x6e,
    0x61, 0x6d, 0x65, 0x3b, 0x20, 0x69, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x72,
    0x65, 0x61, 0x6c, 0x6c, 0x79, 0x0a, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65,
    0x6c, 0x69, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x65, 0x78, 0x74,
    0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x6f, 0x6c, 0x69, 0x6e, 0x67, 0x2f, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x62, 0x65, 0x0a,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x22,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x22, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d,
    0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd4, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd4, 0x03, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x12, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd4, 0x03, 0x18, 0x19, 0x0a, 0xec, 0x01, 0x0a,
    0x04, 0x04, 0x11, 0x02, 0x04, 0x12, 0x04, 0xda, 0x03, 0x02, 0x1f, 0x1a, 0xdd, 0x01, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x27, 0x73, 0x20, 0x68, 0x6f, 0x73, 0x74,
    0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
    0x6c, 0x65, 0x3b, 0x20, 0x69, 0x74, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6e,
    0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x20, 0x65, 0x6e, 0x76,
    0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x44, 0x4e, 0x53, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c,
    0x20, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x28, 0x65, 0x67, 0x2c, 0x20,
    0x73, 0x6f, 0x6d, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20, 0x63, 0x6c, 0x6f, 0x75,
    0x64, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x29, 0x2e, 0x0a, 0x20, 0x44,
    0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x75, 0x73, 0x65, 0x20, 0x60,
    0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65,
    0x60, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x04, 0x04, 0x12, 0x04, 0xda, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xda, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xda, 0x03, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xda, 0x03, 0x1d, 0x1e, 0x0a, 0x68, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x05, 0x12,
    0x04, 0xde, 0x03, 0x02, 0x1e, 0x1a, 0x5a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x6e,
    0x69, 0x6e, 0x67, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69,
    0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x3b,
    0x20, 0x74, 0x61, 0x6b, 0x65, 0x6e, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x65, 0x64, 0x20, 0x22, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x2f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x68, 0x70, 0x70, 0x22, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x05, 0x04, 0x12, 0x04, 0xde, 0x03, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x05, 0x05, 0x12, 0x04, 0xde, 0x03, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x05, 0x01, 0x12, 0x04, 0xde, 0x03, 0x12, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x11, 0x02, 0x05, 0x03, 0x12, 0x04, 0xde, 0x03, 0x1c, 0x1d, 0x0a, 0x95, 0x01,
    0x0a, 0x04, 0x04, 0x11, 0x02, 0x06, 0x12, 0x04, 0xe3, 0x03, 0x02, 0x1f, 0x1a, 0x86, 0x01, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x66, 0x75, 0x6c, 0x6c, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x20, 0x28, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x20, 0x62, 0x6f,
    0x74, 0x68, 0x20, 0x49, 0x50, 0x76, 0x34, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x49, 0x50, 0x76, 0x36,
    0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x73, 0x29, 0x0a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73,
    0x75, 0x70, 0x65, 0x72, 0x73, 0x65, 0x64, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x60, 0x69, 0x70, 0x60, 0x2c, 0x20, 0x60, 0x70, 0x6f, 0x72, 0x74,
    0x60, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x60, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x60,
    0x2e, 0x0a, 0x20, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x30,
    0x2e, 0x32, 0x34, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x04, 0x12, 0x04,
    0xe3, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x06, 0x12, 0x04, 0xe3,
    0x03, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe3, 0x03,
    0x13, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe3, 0x03, 0x1d,
    0x1e, 0x0a, 0xd7, 0x02, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xee, 0x03, 0x00, 0xf4, 0x03, 0x01,
    0x1a, 0xc8, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x61, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x69, 0x64, 0x27, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x20, 0x61,
    0x67, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20,
    0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20,
    0x74, 0x6f, 0x20, 0x66, 0x61, 0x63, 0x69, 0x6c, 0x69, 0x74, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65,
    0x2d, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20, 0x20,
    0x49, 0x66, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74,
    0x20, 0x69, 0x73, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e,
    0x67, 0x20, 0x69, 0x74, 0x73, 0x20, 0x6f, 0x77, 0x6e, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x6f, 0x74, 0x65, 0x6e, 0x74,
    0x69, 0x61, 0x6c, 0x6c, 0x79, 0x0a, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x73, 0x27, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28,
    0x69, 0x66, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x68,
    0x61, 0x73, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67,
    0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x29, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x12, 0x01, 0x12, 0x04, 0xee, 0x03, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x00,
    0x12, 0x04, 0xef, 0x03, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xef, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xef, 0x03, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x01, 0x12, 0x04, 0xef,
    0x03, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03, 0x12, 0x04, 0xef, 0x03,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x03, 0x02, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf0, 0x03, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf0, 0x03, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf0, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf0, 0x03, 0x18, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x01, 0x08, 0x12, 0x04, 0xf0, 0x03, 0x1a, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x01, 0x07, 0x12, 0x04, 0xf0, 0x03, 0x25, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12,
    0x02, 0x02, 0x12, 0x04, 0xf1, 0x03, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xf1, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xf1, 0x03, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xf1, 0x03, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xf1, 0x03, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x03, 0x12, 0x04, 0xf2, 0x03,
    0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf2, 0x03, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf2, 0x03, 0x0b, 0x14,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf2, 0x03, 0x15, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf2, 0x03, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf3, 0x03, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x04, 0x06, 0x12, 0x04, 0xf3, 0x03, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xf3, 0x03, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xf3, 0x03, 0x18, 0x19, 0x0a, 0x85, 0x01, 0x0a, 0x02, 0x04, 0x13, 0x12,
    0x06, 0xfb, 0x03, 0x00, 0xa5, 0x04, 0x01, 0x1a, 0x77, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75,
    0x74, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x22,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x2e, 0x20, 0x41, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x0a, 0x20, 0x75, 0x73,
    0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64,
    0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72,
    0x20, 0x22, 0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x22, 0x20, 0x74, 0x72, 0x69, 0x63, 0x6b, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0xfb, 0x03, 0x08, 0x0d, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x13, 0x04, 0x00, 0x12, 0x06, 0xfc, 0x03, 0x02, 0x81, 0x04, 0x03, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x13, 0x04, 0x00, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x07, 0x0b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x13, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x03, 0x04, 0x0f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x13, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfd, 0x03, 0x04, 0x0a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xfd, 0x03, 0x0d, 0x0e, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x13, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xfe, 0x03, 0x04, 0x0f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfe, 0x03, 0x04, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xfe, 0x03, 0x0d, 0x0e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xff, 0x03, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xff, 0x03, 0x04,
    0x07, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xff, 0x03,
    0x0a, 0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04, 0x80, 0x04,
    0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x80,
    0x04, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x04, 0x00, 0x02, 0x03, 0x02, 0x12, 0x04,
    0x80, 0x04, 0x0b, 0x0c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03, 0x00, 0x12, 0x06, 0x83, 0x04,
    0x02, 0x8d, 0x04, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03, 0x00, 0x01, 0x12, 0x04, 0x83,
    0x04, 0x0a, 0x10, 0x0a, 0xef, 0x03, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0x8c, 0x04, 0x04, 0x1e, 0x1a, 0xde, 0x03, 0x20, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73,
    0x65, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6c, 0x6f, 0x61,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x2e, 0x20, 0x54, 0x6f, 0x20, 0x72,
    0x65, 0x64, 0x75, 0x63, 0x65, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x63,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x75, 0x6e, 0x70, 0x72, 0x65, 0x64, 0x69, 0x63, 0x74, 0x61, 0x62,
    0x6c, 0x65, 0x20, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x69, 0x6e,
    0x74, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74,
    0x6f, 0x0a, 0x20, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x6f, 0x66, 0x66, 0x20, 0x65, 0x72, 0x72, 0x6f,
    0x72, 0x2c, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x73, 0x75,
    0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 0x20, 0x64, 0x65, 0x63,
    0x69, 0x6d, 0x61, 0x6c, 0x20, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x20, 0x6f, 0x66, 0x0a, 0x20,
    0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x73, 0x63,
    0x61, 0x6c, 0x61, 0x72, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x2c, 0x20, 0x66,
    0x6c, 0x6f, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x0a, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x72,
    0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x66, 0x69, 0x78, 0x65, 0x64, 0x20, 0x70,
    0x6f, 0x69, 0x6e, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x0a, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65,
    0x20, 0x64, 0x65, 0x63, 0x69, 0x6d, 0x61, 0x6c, 0x20, 0x64, 0x69, 0x67, 0x69, 0x74, 0x73, 0x20,
    0x6f, 0x66, 0x20, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64,
    0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x69,
    0x6e, 0x67, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x6f, 0x75, 0x74, 0x70,
    0x75, 0x74, 0x2e, 0x20, 0x41, 0x6e, 0x79, 0x20, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e,
    0x61, 0x6c, 0x20, 0x70, 0x72, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20,
    0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x63, 0x61,
    0x72, 0x64, 0x65, 0x64, 0x20, 0x28, 0x76, 0x69, 0x61, 0x20, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x69,
    0x6e, 0x67, 0x29, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x8c, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x8c, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x8c, 0x04, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x04, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03,
    0x01, 0x12, 0x06, 0x8f, 0x04, 0x02, 0x92, 0x04, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03,
    0x01, 0x01, 0x12, 0x04, 0x8f, 0x04, 0x0a, 0x0f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x04, 0x90, 0x04, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x01,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x90, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03,
    0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13,
    0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x04, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x13, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x90, 0x04, 0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x13, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0x91, 0x04, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x13, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x91, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x13, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x91, 0x04, 0x0d, 0x13, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x13, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x91, 0x04, 0x14, 0x17, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x91, 0x04, 0x1a, 0x1b,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03, 0x02, 0x12, 0x06, 0x94, 0x04, 0x02, 0x96, 0x04, 0x03,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03, 0x02, 0x01, 0x12, 0x04, 0x94, 0x04, 0x0a, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0x95, 0x04, 0x04, 0x1d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x04, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0x95, 0x04, 0x0d,
    0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x04,
    0x13, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95,
    0x04, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03, 0x03, 0x12, 0x06, 0x98, 0x04, 0x02,
    0x9a, 0x04, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03, 0x03, 0x01, 0x12, 0x04, 0x98, 0x04,
    0x0a, 0x0d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0x99, 0x04,
    0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99,
    0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x03, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x99, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x99, 0x04, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x03, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x99, 0x04, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x13, 0x03, 0x04, 0x12, 0x06,
    0x9c, 0x04, 0x02, 0x9e, 0x04, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x03, 0x04, 0x01, 0x12,
    0x04, 0x9c, 0x04, 0x0a, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x13, 0x03, 0x04, 0x02, 0x00, 0x12,
    0x04, 0x9d, 0x04, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x04, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x9d, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x04, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x9d, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x04, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x9d, 0x04, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x13, 0x03, 0x04,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x04, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02,
    0x00, 0x12, 0x04, 0xa0, 0x04, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xa0, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x06, 0x12,
    0x04, 0xa0, 0x04, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xa0, 0x04, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0,
    0x04, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x02,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa1, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa1, 0x04, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x12, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x13, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa1, 0x04, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x13, 0x02, 0x02, 0x12, 0x04, 0xa2, 0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x13, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa2, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13,
    0x02, 0x02, 0x06, 0x12, 0x04, 0xa2, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xa2, 0x04, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x03, 0x12,
    0x04, 0xa3, 0x04, 0x02, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xa3, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x03, 0x06, 0x12, 0x04, 0xa3,
    0x04, 0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa3, 0x04,
    0x0f, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa3, 0x04, 0x15,
    0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x13, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x04, 0x02, 0x19, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa4, 0x04, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x13, 0x02, 0x04, 0x06, 0x12, 0x04, 0xa4, 0x04, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x13, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa4, 0x04, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x13, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa4, 0x04, 0x17, 0x18, 0x0a, 0xd3, 0x01, 0x0a, 0x02,
    0x04, 0x14, 0x12, 0x06, 0xad, 0x04, 0x00, 0xb4, 0x04, 0x01, 0x1a, 0xc4, 0x01, 0x2a, 0x0a, 0x20,
    0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x74, 0x74,
    0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68,
    0x69, 0x6e, 0x65, 0x2e, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x77, 0x2c, 0x0a, 0x20, 0x61,
    0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x20, 0x74,
    0x79, 0x70, 0x65, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x61,
    0x79, 0x0a, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x74, 0x74, 0x72,
    0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20,
    0x62, 0x65, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x61, 0x73, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0xad, 0x04, 0x08, 0x11, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0xae, 0x04, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x00, 0x05, 0x12, 0x04, 0xae, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xae, 0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xae, 0x04, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x01,
    0x12, 0x04, 0xaf, 0x04, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xaf, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x06, 0x12, 0x04,
    0xaf, 0x04, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaf,
    0x04, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaf, 0x04,
    0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x02, 0x12, 0x04, 0xb0, 0x04, 0x02, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb0, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb0, 0x04, 0x0b, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb0, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x14, 0x02, 0x03, 0x12, 0x04, 0xb1, 0x04, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xb1, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x03, 0x06, 0x12, 0x04, 0xb1, 0x04, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xb1, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xb1, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x04, 0x12, 0x04,
    0xb2, 0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb2,
    0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x06, 0x12, 0x04, 0xb2, 0x04,
    0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb2, 0x04, 0x15,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb2, 0x04, 0x1b, 0x1c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x14, 0x02, 0x05, 0x12, 0x04, 0xb3, 0x04, 0x02, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x14, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb3, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x14, 0x02, 0x05, 0x06, 0x12, 0x04, 0xb3, 0x04, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x14, 0x02, 0x05, 0x01, 0x12, 0x04, 0xb3, 0x04, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x05, 0x03, 0x12, 0x04, 0xb3, 0x04, 0x1d, 0x1e, 0x0a, 0xe5, 0x04, 0x0a, 0x02, 0x04,
    0x15, 0x12, 0x06, 0xc4, 0x04, 0x00, 0xc5, 0x05, 0x01, 0x1a, 0xd6, 0x04, 0x2a, 0x0a, 0x20, 0x44,
    0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
    0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x60, 0x6e, 0x61, 0x6d, 0x65, 0x60, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x0a, 0x20,
    0x6c, 0x69, 0x6b, 0x65, 0x20, 0x22, 0x63, 0x70, 0x75, 0x73, 0x22, 0x20, 0x6f, 0x72, 0x20, 0x22,
    0x6d, 0x65, 0x6d, 0x22, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61,
    0x74, 0x65, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x6b, 0x69, 0x6e, 0x64, 0x20, 0x6f,
    0x66, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x3b, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x64, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
    0x69, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x2e, 0x20, 0x41, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x6f, 0x6e, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x72, 0x65, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x73, 0x3a,
    0x20, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x20, 0x28, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x29,
    0x2c, 0x20, 0x61, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x66, 0x69, 0x6e,
    0x69, 0x74, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x69, 0x73, 0x63, 0x72, 0x65, 0x74, 0x65,
    0x20, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x5b,
    0x31, 0x2d, 0x31, 0x30, 0x2c, 0x20, 0x32, 0x30, 0x2d, 0x33, 0x30, 0x5d, 0x29, 0x2c, 0x20, 0x6f,
    0x72, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x69, 0x74, 0x65, 0x6d,
    0x73, 0x2e, 0x20, 0x41, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73,
    0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x61, 0x72, 0x64, 0x20, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x62, 0x75, 0x66, 0x66, 0x65, 0x72, 0x0a, 0x20, 0x22,
    0x75, 0x6e, 0x69, 0x6f, 0x6e, 0x22, 0x20, 0x74, 0x72, 0x69, 0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x20,
    0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x22, 0x64, 0x69, 0x73, 0x6b, 0x22,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x6d, 0x65, 0x6d, 0x22, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x63, 0x61, 0x6c, 0x61, 0x72, 0x20,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64,
    0x20, 0x69, 0x6e, 0x0a, 0x20, 0x6d, 0x65, 0x67, 0x61, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2e, 0x20,
    0x46, 0x72, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x22, 0x63, 0x70, 0x75, 0x73,
    0x22, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c,
    0x6f, 0x77, 0x65, 0x64, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x22, 0x30, 0x2e, 0x35,
    0x22, 0x29, 0x2c, 0x0a, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x63, 0x6f, 0x72, 0x72, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c,
    0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x43, 0x50, 0x55,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0xc4, 0x04, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12, 0x04, 0xc5, 0x04, 0x02, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc5, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc5, 0x04, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc5, 0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xc5, 0x04, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02,
    0x01, 0x12, 0x04, 0xc6, 0x04, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xc6, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xc6, 0x04, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xc6, 0x04, 0x16, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc6,
    0x04, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x02, 0x12, 0x04, 0xc7, 0x04, 0x02,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc7, 0x04, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x06, 0x12, 0x04, 0xc7, 0x04, 0x0b, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc7, 0x04, 0x18, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc7, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x15, 0x02, 0x03, 0x12, 0x04, 0xc8, 0x04, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x15, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc8, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x03, 0x06, 0x12, 0x04, 0xc8, 0x04, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xc8, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xc8, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x04, 0x12,
    0x04, 0xc9, 0x04, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xc9, 0x04, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x04, 0x06, 0x12, 0x04, 0xc9,
    0x04, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc9, 0x04,
    0x15, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc9, 0x04, 0x1b,
    0x1c, 0x0a, 0xcc, 0x01, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x05, 0x12, 0x04, 0xce, 0x04, 0x02, 0x2b,
    0x1a, 0xbd, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x2e,
    0x20, 0x49, 0x66, 0x20, 0x22, 0x2a, 0x22, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x0a, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e,
    0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x2e, 0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x77,
    0x69, 0x73, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x62, 0x65, 0x20,
    0x6f, 0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x6e,
    0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x05, 0x04, 0x12, 0x04, 0xce, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x05, 0x05, 0x12, 0x04, 0xce, 0x04, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x05, 0x01, 0x12, 0x04, 0xce, 0x04, 0x12, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x05, 0x03, 0x12, 0x04, 0xce, 0x04, 0x19, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x05, 0x08, 0x12, 0x04, 0xce, 0x04, 0x1b, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x15, 0x02, 0x05, 0x07, 0x12, 0x04, 0xce, 0x04, 0x26, 0x29, 0x0a, 0xbf, 0x02, 0x0a, 0x04, 0x04,
    0x15, 0x03, 0x00, 0x12, 0x06, 0xd0, 0x04, 0x02, 0xe7, 0x04, 0x03, 0x22, 0xae, 0x02, 0x20, 0x44,
    0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d,
    0x69, 0x63, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x20,
    0x41, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x61, 0x63, 0x71, 0x75, 0x69, 0x72,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f,
    0x72, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x2f, 0x72, 0x65, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x27, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69,
    0x6e, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x62, 0x79, 0x0a, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x66,
    0x66, 0x65, 0x72, 0x20, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x20, 0x62, 0x79, 0x20, 0x73, 0x65, 0x6e,
    0x64, 0x69, 0x6e, 0x67, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x27, 0x4f,
    0x66, 0x66, 0x65, 0x72, 0x3a, 0x3a, 0x4f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a,
    0x3a, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x27, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x57, 0x65, 0x20, 0x63, 0x75, 0x72,
    0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x6c,
    0x6c, 0x6f, 0x77, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x22, 0x2a, 0x22, 0x20, 0x74, 0x6f, 0x0a,
    0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d, 0x69, 0x63, 0x20, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x03, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x04, 0x0a, 0x19, 0x0a, 0xdd, 0x02, 0x0a, 0x06,
    0x04, 0x15, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xde, 0x04, 0x04, 0x22, 0x1a, 0xcc, 0x02, 0x20,
    0x49, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72,
    0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x61, 0x6e, 0x79, 0x2c,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x6f, 0x72, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x0a, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x72,
    0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x60, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e,
    0x66, 0x6f, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x60, 0x2e, 0x20, 0x49,
    0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x63, 0x6f,
    0x6e, 0x6a, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x60, 0x55, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x52, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x60, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x74, 0x6f, 0x20, 0x64,
    0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x0a, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x20, 0x61, 0x74, 0x74,
    0x65, 0x6d, 0x70, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x75, 0x6e, 0x72, 0x65, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x20, 0x73, 0x6f, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x15, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xde, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x15, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xde, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xde, 0x04, 0x14, 0x1d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xde, 0x04, 0x20, 0x21, 0x0a,
    0xd1, 0x02, 0x0a, 0x06, 0x04, 0x15, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x04, 0x04, 0x1f,
    0x1a, 0xc0, 0x02, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66,
    0x72, 0x65, 0x65, 0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61,
    0x6e, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x61, 0x73,
    0x73, 0x6f, 0x63, 0x69, 0x61, 0x74, 0x65, 0x20, 0x61, 0x72, 0x62, 0x69, 0x74, 0x72, 0x61, 0x72,
    0x79, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20,
    0x61, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x2e, 0x20, 0x20, 0x46, 0x6f, 0x72, 0x0a, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x2c, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x63,
    0x61, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x74, 0x6f,
    0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x0a, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6f, 0x73, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x68, 0x61, 0x73,
    0x0a, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x61, 0x20,
    0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x0a, 0x20, 0x6b, 0x65, 0x79, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72,
    0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xe6, 0x04, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x01, 0x06, 0x12,
    0x04, 0xe6, 0x04, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xe6, 0x04, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xe6, 0x04, 0x1d, 0x1e, 0x0a, 0xd6, 0x01, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x06,
    0x12, 0x04, 0xec, 0x04, 0x02, 0x2b, 0x1a, 0xc7, 0x01, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x77, 0x61, 0x73, 0x20, 0x64, 0x79, 0x6e, 0x61,
    0x6d, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72,
    0x20, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e,
    0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x65, 0x69, 0x74,
    0x68, 0x65, 0x72, 0x20, 0x75, 0x6e, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x0a, 0x20,
    0x6f, 0x72, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x72, 0x65,
    0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65,
    0x72, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x76, 0x69, 0x61, 0x20, 0x74, 0x68, 0x65, 0x20, 0x2d, 0x2d,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x06, 0x04, 0x12, 0x04, 0xec, 0x04, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x06, 0x06, 0x12, 0x04, 0xec, 0x04, 0x0b, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x06, 0x01, 0x12, 0x04, 0xec, 0x04, 0x1b, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x06, 0x03, 0x12, 0x04, 0xec, 0x04, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x15, 0x03, 0x01, 0x12, 0x06, 0xee, 0x04, 0x02, 0xb8, 0x05, 0x03, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x03, 0x01, 0x01, 0x12, 0x04, 0xee, 0x04, 0x0a, 0x12, 0x0a, 0x81, 0x05, 0x0a, 0x06,
    0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x12, 0x06, 0xfa, 0x04, 0x04, 0x8c, 0x05, 0x05, 0x1a, 0xee,
    0x04, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x65,
    0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f,
    0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x0a, 0x20, 0x41, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74,
    0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6f,
    0x6d, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67,
    0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x69, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x2f, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74,
    0x65, 0x73, 0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x69, 0x73, 0x0a, 0x20, 0x72, 0x65, 0x2d, 0x6f,
    0x66, 0x66, 0x65, 0x72, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x28, 0x73, 0x29, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x6e,
    0x67, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x27, 0x72, 0x6f, 0x6c,
    0x65, 0x27, 0x2e, 0x0a, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20,
    0x28, 0x69, 0x66, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65,
    0x74, 0x20, 0x79, 0x65, 0x74, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x78, 0x70, 0x72, 0x65, 0x73,
    0x73, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x74, 0x6f, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x77,
    0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b,
    0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x0a, 0x20,
    0x72, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x20, 0x54, 0x6f, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65, 0x20,
    0x61, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x6c, 0x79, 0x20, 0x63, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x64, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2c, 0x20, 0x61, 0x0a, 0x20,
    0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6c, 0x61,
    0x75, 0x6e, 0x63, 0x68, 0x20, 0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2f, 0x65, 0x78, 0x65, 0x63,
    0x75, 0x74, 0x6f, 0x72, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x74, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x0a, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e,
    0x74, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20,
    0x49, 0x44, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45,
    0x3a, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c, 0x20, 0x77, 0x65, 0x20,
    0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x61, 0x20, 0x70,
    0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76,
    0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x61,
    0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x69, 0x2e,
    0x65, 0x2e, 0x2c, 0x20, 0x27, 0x72, 0x6f, 0x6c, 0x65, 0x27, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x27, 0x2a, 0x27, 0x29, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0xfa, 0x04, 0x0c, 0x17,
    0x0a, 0x78, 0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x04,
    0x06, 0x1d, 0x1a, 0x66, 0x20, 0x41, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x49, 0x44,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74,
    0x65, 0x6e, 0x74, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e,
    0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x49, 0x44, 0x20, 0x6e,
    0x65, 0x65, 0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6e, 0x69, 0x71, 0x75,
    0x65, 0x20, 0x70, 0x65, 0x72, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20, 0x65, 0x61,
    0x63, 0x68, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15,
    0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x04, 0x06, 0x0e, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfd, 0x04, 0x0f, 0x15,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfd,
    0x04, 0x16, 0x18, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xfd, 0x04, 0x1b, 0x1c, 0x0a, 0xc3, 0x04, 0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0x8b, 0x05, 0x06, 0x24, 0x1a, 0xb0, 0x04, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x61, 0x74, 0x65,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x20,
    0x6f, 0x72, 0x0a, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73,
    0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x6a, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x22, 0x64, 0x65, 0x73,
    0x74, 0x72, 0x6f, 0x79, 0x22, 0x20, 0x41, 0x43, 0x4c, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x74,
    0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61,
    0x6e, 0x20, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x0a, 0x20, 0x61, 0x74, 0x74, 0x65, 0x6d, 0x70,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x73, 0x74, 0x72, 0x6f, 0x79, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x65,
    0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x6f, 0x20, 0x73, 0x6f,
    0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
    0x2c, 0x20, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x60, 0x70, 0x72, 0x69,
    0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x60, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x69, 0x6e,
    0x0a, 0x20, 0x60, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e,
    0x66, 0x6f, 0x60, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6f,
    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x61, 0x6c, 0x6c, 0x6f,
    0x77, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62,
    0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74,
    0x20, 0x61, 0x0a, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x2c, 0x20, 0x74,
    0x68, 0x6f, 0x75, 0x67, 0x68, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20,
    0x69, 0x74, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69,
    0x64, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6d,
    0x61, 0x74, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c,
    0x20, 0x6f, 0x66, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8b, 0x05, 0x06, 0x0e, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8b, 0x05,
    0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x8b, 0x05, 0x16, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x00, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x8b, 0x05, 0x22, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x15, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x04, 0x8e, 0x05, 0x04, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x8e, 0x05, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03,
    0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8e, 0x05, 0x0d, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15,
    0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8e, 0x05, 0x19, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x15, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8e, 0x05, 0x27, 0x28, 0x0a, 0xd9, 0x03, 0x0a,
    0x06, 0x04, 0x15, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0x99, 0x05, 0x04, 0x1f, 0x1a, 0xc8, 0x03,
    0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65,
    0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20,
    0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x61, 0x6e, 0x64, 0x62, 0x6f, 0x78, 0x2e,
    0x20, 0x4f, 0x74, 0x68, 0x65, 0x72, 0x77, 0x69, 0x73, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x61,
    0x63, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x27, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x74, 0x68,
    0x27, 0x20, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65,
    0x27, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x27, 0x68, 0x6f, 0x73, 0x74, 0x5f, 0x70, 0x61, 0x74,
    0x68, 0x27, 0x20, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x0a, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75,
    0x6d, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x2e, 0x0a,
    0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x49, 0x66, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d,
    0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x62, 0x75, 0x74, 0x20, 0x27, 0x70,
    0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x76, 0x6f, 0x6c,
    0x75, 0x6d, 0x65, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x61, 0x75, 0x74, 0x6f,
    0x6d, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x67, 0x61, 0x72, 0x62, 0x61, 0x67,
    0x65, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74, 0x65,
    0x72, 0x0a, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2f, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x74, 0x65, 0x73, 0x2e, 0x20, 0x43, 0x75, 0x72,
    0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x27, 0x70, 0x65, 0x72, 0x73,
    0x69, 0x73, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x27, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c,
    0x0a, 0x20, 0x27, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x27, 0x20, 0x6d, 0x75, 0x73, 0x74, 0x20,
    0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x99, 0x05, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03,
    0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0x99, 0x05, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15,
    0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x99, 0x05, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x15, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x99, 0x05, 0x1d, 0x1e, 0x0a, 0x6b, 0x0a, 0x06,
    0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x12, 0x06, 0x9d, 0x05, 0x04, 0xb5, 0x05, 0x05, 0x1a, 0x59,
    0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65,
    0x20, 0x61, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x20, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x74,
    0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x2e, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x6a,
    0x6d, 0x6c, 0x76, 0x61, 0x6e, 0x72, 0x65, 0x29, 0x3a, 0x20, 0x41, 0x64, 0x64, 0x20, 0x73, 0x75,
    0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x42, 0x4c, 0x4f, 0x43, 0x4b, 0x20,
    0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03,
    0x01, 0x03, 0x01, 0x01, 0x12, 0x04, 0x9d, 0x05, 0x0c, 0x12, 0x0a, 0x12, 0x0a, 0x08, 0x04, 0x15,
    0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x12, 0x06, 0x9e, 0x05, 0x06, 0xa1, 0x05, 0x07, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x01, 0x12, 0x04, 0x9e, 0x05, 0x0b,
    0x0f, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x02, 0x00, 0x12,
    0x04, 0x9f, 0x05, 0x08, 0x11, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x04,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9f, 0x05, 0x08, 0x0c, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15,
    0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0x9f, 0x05, 0x0f, 0x10, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa0,
    0x05, 0x08, 0x12, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x04, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xa0, 0x05, 0x08, 0x0d, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01,
    0x03, 0x01, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xa0, 0x05, 0x10, 0x11, 0x0a, 0x90, 0x01,
    0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x12, 0x06, 0xa5, 0x05, 0x06, 0xa8,
    0x05, 0x07, 0x1a, 0x7c, 0x20, 0x41, 0x20, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x20, 0x74, 0x68,
    0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x6f, 0x6e, 0x20, 0x61, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x20,
    0x64, 0x69, 0x73, 0x6b, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x0a, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x64,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x61, 0x72, 0x76, 0x65, 0x64, 0x20, 0x75, 0x70, 0x20, 0x61,
    0x73, 0x20, 0x6e, 0x65, 0x63, 0x65, 0x73, 0x73, 0x61, 0x72, 0x79, 0x20, 0x62, 0x65, 0x74, 0x77,
    0x65, 0x65, 0x6e, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x2e, 0x0a,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0xa5,
    0x05, 0x0e, 0x12, 0x0a, 0x41, 0x0a, 0x0a, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xa7, 0x05, 0x08, 0x21, 0x1a, 0x2d, 0x20, 0x50, 0x61, 0x74, 0x68, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x64, 0x65, 0x72, 0x20, 0x28, 0x65, 0x2e,
    0x67, 0x2e, 0x2c, 0x20, 0x2f, 0x6d, 0x6e, 0x74, 0x2f, 0x72, 0x61, 0x69, 0x64, 0x2f, 0x64, 0x69,
    0x73, 0x6b, 0x30, 0x29, 0x2e, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01,
    0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x05, 0x08, 0x10, 0x0a, 0x13, 0x0a, 0x0b, 0x04,
    0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa7, 0x05, 0x11, 0x17,
    0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa7, 0x05, 0x18, 0x1c, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa7, 0x05, 0x1f, 0x20, 0x0a, 0xae, 0x01, 0x0a, 0x08, 0x04,
    0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x12, 0x06, 0xad, 0x05, 0x06, 0xb0, 0x05, 0x07, 0x1a,
    0x99, 0x01, 0x20, 0x41, 0x20, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x66, 0x69, 0x6c,
    0x65, 0x2d, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x73, 0x65, 0x74, 0x20, 0x75, 0x70, 0x20,
    0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x64, 0x6d,
    0x69, 0x6e, 0x69, 0x73, 0x74, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x0a, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73,
    0x65, 0x64, 0x20, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x73, 0x69, 0x76, 0x65, 0x6c, 0x79, 0x3a, 0x20,
    0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x20, 0x61, 0x0a, 0x20, 0x70, 0x61,
    0x72, 0x74, 0x69, 0x61, 0x6c, 0x20, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x69, 0x73, 0x6b, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x01, 0x12, 0x04, 0xad, 0x05, 0x0e, 0x13, 0x0a, 0x42,
    0x0a, 0x0a, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x05,
    0x08, 0x21, 0x1a, 0x2e, 0x20, 0x50, 0x61, 0x74, 0x68, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x6f, 0x75,
    0x6e, 0x74, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20,
    0x2f, 0x6d, 0x6e, 0x74, 0x2f, 0x72, 0x61, 0x69, 0x64, 0x2f, 0x64, 0x69, 0x73, 0x6b, 0x30, 0x29,
    0x2e, 0x0a, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xaf, 0x05, 0x08, 0x10, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03,
    0x01, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xaf, 0x05, 0x11, 0x17, 0x0a, 0x13, 0x0a, 0x0b,
    0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x05, 0x18,
    0x1c, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xaf, 0x05, 0x1f, 0x20, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x04, 0xb2, 0x05, 0x06, 0x1d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01,
    0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb2, 0x05, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xb2, 0x05, 0x0f, 0x13, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb2, 0x05, 0x14,
    0x18, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xb2, 0x05, 0x1b, 0x1c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x01,
    0x12, 0x04, 0xb3, 0x05, 0x06, 0x1d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xb3, 0x05, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03,
    0x01, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xb3, 0x05, 0x0f, 0x13, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb3, 0x05, 0x14, 0x18, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb3, 0x05,
    0x1b, 0x1c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04,
    0xb4, 0x05, 0x06, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xb4, 0x05, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15, 0x03, 0x01, 0x03,
    0x01, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb4, 0x05, 0x0f, 0x14, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x15,
    0x03, 0x01, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x15, 0x1a, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x15, 0x03, 0x01, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb4, 0x05, 0x1d, 0x1e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x15, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xb7, 0x05, 0x04, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb7, 0x05, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb7, 0x05,
    0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb7,
    0x05, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x15, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xb7, 0x05, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x07, 0x12, 0x04, 0xba, 0x05,
    0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x07, 0x04, 0x12, 0x04, 0xba, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x07, 0x06, 0x12, 0x04, 0xba, 0x05, 0x0b, 0x13,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x07, 0x01, 0x12, 0x04, 0xba, 0x05, 0x14, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x07, 0x03, 0x12, 0x04, 0xba, 0x05, 0x1b, 0x1c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x15, 0x03, 0x02, 0x12, 0x04, 0xbc, 0x05, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x03, 0x02, 0x01, 0x12, 0x04, 0xbc, 0x05, 0x0a, 0x17, 0x0a, 0xe1, 0x02, 0x0a, 0x04,
    0x04, 0x15, 0x02, 0x08, 0x12, 0x04, 0xc4, 0x05, 0x02, 0x27, 0x1a, 0xd2, 0x02, 0x20, 0x49, 0x66,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x72, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x2c,
    0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x65,
    0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65,
    0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x70, 0x72, 0x65, 0x65, 0x6d, 0x70, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20,
    0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79,
    0x20, 0x74, 0x69, 0x6d, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x75, 0x6e, 0x0a, 0x20,
    0x62, 0x65, 0x73, 0x74, 0x20, 0x65, 0x66, 0x66, 0x6f, 0x72, 0x74, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6e, 0x65,
    0x65, 0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x20, 0x75, 0x70, 0x74, 0x69, 0x6d, 0x65,
    0x20, 0x6f, 0x72, 0x20, 0x70, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x0a,
    0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x73, 0x2e, 0x20, 0x4e, 0x6f, 0x74,
    0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69,
    0x73, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x27, 0x64, 0x69, 0x73, 0x6b, 0x27, 0x20, 0x6f, 0x72,
    0x20, 0x27, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x27, 0x0a, 0x20,
    0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x08, 0x04, 0x12, 0x04, 0xc4, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x08, 0x06, 0x12, 0x04, 0xc4, 0x05, 0x0b, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x08, 0x01, 0x12, 0x04, 0xc4, 0x05, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x15, 0x02, 0x08, 0x03, 0x12, 0x04, 0xc4, 0x05, 0x25, 0x26, 0x0a, 0x80, 0x09, 0x0a, 0x02,
    0x04, 0x16, 0x12, 0x06, 0xe0, 0x05, 0x00, 0xeb, 0x05, 0x01, 0x1a, 0xf1, 0x08, 0x2a, 0x0a, 0x20,
    0x57, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x20, 0x63, 0x61, 0x70, 0x73, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20, 0x69,
    0x73, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74,
    0x2c, 0x20, 0x6f, 0x75, 0x74, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65,
    0x74, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x65, 0x69, 0x74, 0x68, 0x65, 0x72,
    0x20, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x64, 0x72, 0x6f,
    0x70, 0x70, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x6c, 0x79, 0x20,
    0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x69,
    0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61,
    0x78, 0x69, 0x6d, 0x75, 0x6d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x77, 0x69, 0x64, 0x74, 0x68, 0x0a,
    0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x61, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x70, 0x29, 0x20, 0x6f, 0x72, 0x20,
    0x62, 0x65, 0x63, 0x61, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x62,
    0x69, 0x6e, 0x65, 0x64, 0x0a, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x72,
    0x61, 0x66, 0x66, 0x69, 0x63, 0x20, 0x6f, 0x66, 0x20, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c,
    0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x73, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x6d, 0x69, 0x74, 0x20, 0x63,
    0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68,
    0x6f, 0x73, 0x74, 0x20, 0x28, 0x74, 0x68, 0x65, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x29, 0x2e,
    0x20, 0x57, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x74,
    0x68, 0x65, 0x0a, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x74,
    0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x61, 0x63,
    0x68, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x64, 0x69,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x64,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x6c, 0x79, 0x0a, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x54, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x20,
    0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x20, 0x51, 0x75, 0x65, 0x75, 0x65, 0x69, 0x6e, 0x67,
    0x20, 0x44, 0x69, 0x73, 0x63, 0x69, 0x70, 0x6c, 0x69, 0x6e, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x69,
    0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x61, 0x6d, 0x65,
    0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x72, 0x2c,
    0x20, 0x65, 0x2e, 0x67, 0x2e, 0x20, 0x27, 0x74, 0x78, 0x5f, 0x62, 0x77, 0x5f, 0x63, 0x61, 0x70,
    0x27, 0x0a, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x6c, 0x6f, 0x67, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20,
    0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x64, 0x65, 0x6c, 0x61,
    0x79, 0x65, 0x64, 0x0a, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x3a, 0x20, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x73, 0x65,
    0x65, 0x6e, 0x0a, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a,
    0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65,
    0x74, 0x73, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x6f,
    0x74, 0x61, 0x6c, 0x0a, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x20,
    0x3a, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b,
    0x65, 0x74, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x65, 0x78, 0x63, 0x65, 0x65, 0x64,
    0x65, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x70,
    0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x74, 0x6f, 0x74, 0x61,
    0x6c, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x73, 0x65, 0x65, 0x6e, 0x0a, 0x20,
    0x71, 0x6c, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x75, 0x6d,
    0x62, 0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x20, 0x63,
    0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x71, 0x75, 0x65, 0x75, 0x65, 0x64, 0x0a,
    0x20, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x62, 0x70, 0x73, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x74, 0x68,
    0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x2f, 0x73, 0x65, 0x63, 0x0a, 0x20, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x70, 0x73, 0x20,
    0x20, 0x20, 0x3a, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x70, 0x75, 0x74, 0x20, 0x69,
    0x6e, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x2f, 0x73, 0x65, 0x63, 0x0a, 0x20, 0x72,
    0x65, 0x71, 0x75, 0x65, 0x75, 0x65, 0x73, 0x20, 0x20, 0x20, 0x3a, 0x20, 0x6e, 0x75, 0x6d, 0x62,
    0x65, 0x72, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x20, 0x61, 0x20, 0x70, 0x61,
    0x63, 0x6b, 0x65, 0x74, 0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x64, 0x65,
    0x6c, 0x61, 0x79, 0x65, 0x64, 0x20, 0x64, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x6b, 0x69,
    0x6e, 0x67, 0x20, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x20, 0x63, 0x6f, 0x6e,
    0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x73, 0x75, 0x65, 0x73, 0x0a, 0x0a,
    0x20, 0x4d, 0x6f, 0x72, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x54, 0x72, 0x61, 0x66,
    0x66, 0x69, 0x63, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x20, 0x63, 0x61, 0x6e, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x61, 0x74, 0x20, 0x68, 0x74, 0x74,
    0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6c, 0x61, 0x72, 0x74, 0x63, 0x2e, 0x6f, 0x72,
    0x67, 0x2f, 0x6c, 0x61, 0x72, 0x74, 0x63, 0x2e, 0x68, 0x74, 0x6d, 0x6c, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xe0, 0x05, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x16, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x05, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe1, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xe1, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe1, 0x05, 0x12, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xe1, 0x05, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x01, 0x12, 0x04, 0xe2,
    0x05, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe2, 0x05,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe2, 0x05, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x05, 0x12, 0x19,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe2, 0x05, 0x1c, 0x1d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x02, 0x12, 0x04, 0xe3, 0x05, 0x02, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe3, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe3, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe3, 0x05, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xe3, 0x05, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02,
    0x03, 0x12, 0x04, 0xe4, 0x05, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x04,
    0x12, 0x04, 0xe4, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x05, 0x12,
    0x04, 0xe4, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xe4, 0x05, 0x12, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe4,
    0x05, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x04, 0x12, 0x04, 0xe5, 0x05, 0x02,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe5, 0x05, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe5, 0x05, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe5, 0x05, 0x12, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe5, 0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x16, 0x02, 0x05, 0x12, 0x04, 0xe6, 0x05, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x16, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16,
    0x02, 0x05, 0x05, 0x12, 0x04, 0xe6, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xe6, 0x05, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xe6, 0x05, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x06, 0x12,
    0x04, 0xe7, 0x05, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x04, 0x12, 0x04,
    0xe7, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x05, 0x12, 0x04, 0xe7,
    0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe7, 0x05,
    0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe7, 0x05, 0x19,
    0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x07, 0x12, 0x04, 0xe8, 0x05, 0x02, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x04, 0x12, 0x04, 0xe8, 0x05, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x16, 0x02, 0x07, 0x05, 0x12, 0x04, 0xe8, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x16, 0x02, 0x07, 0x01, 0x12, 0x04, 0xe8, 0x05, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x16, 0x02, 0x07, 0x03, 0x12, 0x04, 0xe8, 0x05, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x16, 0x02, 0x08, 0x12, 0x04, 0xe9, 0x05, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x08, 0x04, 0x12, 0x04, 0xe9, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08,
    0x05, 0x12, 0x04, 0xe9, 0x05, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x01,
    0x12, 0x04, 0xe9, 0x05, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x08, 0x03, 0x12,
    0x04, 0xe9, 0x05, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x16, 0x02, 0x09, 0x12, 0x04, 0xea,
    0x05, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x04, 0x12, 0x04, 0xea, 0x05,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x05, 0x12, 0x04, 0xea, 0x05, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x01, 0x12, 0x04, 0xea, 0x05, 0x12, 0x1a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x09, 0x03, 0x12, 0x04, 0xea, 0x05, 0x1d, 0x1f, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0xee, 0x05, 0x00, 0x82, 0x06, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0xee, 0x05, 0x08, 0x14, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17,
    0x02, 0x00, 0x12, 0x04, 0xef, 0x05, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xef, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xef, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xef, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xef, 0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x05,
    0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf0, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf0, 0x05, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf0, 0x05, 0x11, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf0, 0x05, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x02, 0x12, 0x04, 0xf1, 0x05, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf1, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf1, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xf1, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xf1, 0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x03,
    0x12, 0x04, 0xf2, 0x05, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xf2, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xf2, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf2,
    0x05, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf2, 0x05,
    0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x05, 0x02, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf3, 0x05, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x05, 0x12, 0x04, 0xf3, 0x05, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf3, 0x05, 0x11, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf3, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x17, 0x02, 0x05, 0x12, 0x04, 0xf4, 0x05, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xf4, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x05, 0x05, 0x12, 0x04, 0xf4, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xf4, 0x05, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xf4, 0x05, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x06, 0x12, 0x04,
    0xf5, 0x05, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x04, 0x12, 0x04, 0xf5,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x05, 0x12, 0x04, 0xf5, 0x05,
    0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf5, 0x05, 0x11,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x06, 0x03, 0x12, 0x04, 0xf5, 0x05, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x07, 0x12, 0x04, 0xf6, 0x05, 0x02, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x07, 0x04, 0x12, 0x04, 0xf6, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x07, 0x05, 0x12, 0x04, 0xf6, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf6, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x07, 0x03, 0x12, 0x04, 0xf6, 0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17,
    0x02, 0x08, 0x12, 0x04, 0xf7, 0x05, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08,
    0x04, 0x12, 0x04, 0xf7, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x05,
    0x12, 0x04, 0xf7, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x01, 0x12,
    0x04, 0xf7, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x08, 0x03, 0x12, 0x04,
    0xf7, 0x05, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x09, 0x12, 0x04, 0xf8, 0x05,
    0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x04, 0x12, 0x04, 0xf8, 0x05, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x05, 0x12, 0x04, 0xf8, 0x05, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x01, 0x12, 0x04, 0xf8, 0x05, 0x11, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x09, 0x03, 0x12, 0x04, 0xf8, 0x05, 0x1f, 0x21, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x0a, 0x12, 0x04, 0xf9, 0x05, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xf9, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xf9, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x0a, 0x01, 0x12, 0x04, 0xf9, 0x05, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x0a, 0x03, 0x12, 0x04, 0xf9, 0x05, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x0b,
    0x12, 0x04, 0xfa, 0x05, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0b, 0x04, 0x12,
    0x04, 0xfa, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0b, 0x05, 0x12, 0x04,
    0xfa, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xfa,
    0x05, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xfa, 0x05,
    0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x0c, 0x12, 0x04, 0xfb, 0x05, 0x02, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xfb, 0x05, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xfb, 0x05, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xfb, 0x05, 0x11, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xfb, 0x05, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x17, 0x02, 0x0d, 0x12, 0x04, 0xfc, 0x05, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x0d, 0x04, 0x12, 0x04, 0xfc, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x0d, 0x05, 0x12, 0x04, 0xfc, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0d,
    0x01, 0x12, 0x04, 0xfc, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0d, 0x03,
    0x12, 0x04, 0xfc, 0x05, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x0e, 0x12, 0x04,
    0xfd, 0x05, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xfd,
    0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xfd, 0x05,
    0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xfd, 0x05, 0x11,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xfd, 0x05, 0x1c, 0x1e,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x0f, 0x12, 0x04, 0xfe, 0x05, 0x02, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x17, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xfe, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xfe, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xfe, 0x05, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xfe, 0x05, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17,
    0x02, 0x10, 0x12, 0x04, 0xff, 0x05, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x10,
    0x04, 0x12, 0x04, 0xff, 0x05, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x10, 0x05,
    0x12, 0x04, 0xff, 0x05, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x10, 0x01, 0x12,
    0x04, 0xff, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x10, 0x03, 0x12, 0x04,
    0xff, 0x05, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x11, 0x12, 0x04, 0x80, 0x06,
    0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x11, 0x04, 0x12, 0x04, 0x80, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x11, 0x05, 0x12, 0x04, 0x80, 0x06, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x11, 0x01, 0x12, 0x04, 0x80, 0x06, 0x11, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x11, 0x03, 0x12, 0x04, 0x80, 0x06, 0x1d, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x17, 0x02, 0x12, 0x12, 0x04, 0x81, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x12, 0x04, 0x12, 0x04, 0x81, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x12, 0x05, 0x12, 0x04, 0x81, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x12, 0x01, 0x12, 0x04, 0x81, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02,
    0x12, 0x03, 0x12, 0x04, 0x81, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06,
    0x85, 0x06, 0x00, 0xa1, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0x85,
    0x06, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0x86, 0x06, 0x02,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0x86, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0x86, 0x06, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x01, 0x12, 0x04, 0x86, 0x06, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x00, 0x03, 0x12, 0x04, 0x86, 0x06, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x01, 0x12, 0x04, 0x87, 0x06, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x01, 0x04, 0x12, 0x04, 0x87, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x87, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x87, 0x06, 0x11, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x87, 0x06, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x02, 0x12,
    0x04, 0x88, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x04, 0x12, 0x04,
    0x88, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x05, 0x12, 0x04, 0x88,
    0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x01, 0x12, 0x04, 0x88, 0x06,
    0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x02, 0x03, 0x12, 0x04, 0x88, 0x06, 0x20,
    0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x03, 0x12, 0x04, 0x89, 0x06, 0x02, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x04, 0x12, 0x04, 0x89, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x03, 0x05, 0x12, 0x04, 0x89, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x03, 0x01, 0x12, 0x04, 0x89, 0x06, 0x11, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x03, 0x03, 0x12, 0x04, 0x89, 0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x18, 0x02, 0x04, 0x12, 0x04, 0x8a, 0x06, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x04, 0x04, 0x12, 0x04, 0x8a, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04,
    0x05, 0x12, 0x04, 0x8a, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x01,
    0x12, 0x04, 0x8a, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x04, 0x03, 0x12,
    0x04, 0x8a, 0x06, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x05, 0x12, 0x04, 0x8b,
    0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x04, 0x12, 0x04, 0x8b, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x05, 0x12, 0x04, 0x8b, 0x06, 0x0b,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x01, 0x12, 0x04, 0x8b, 0x06, 0x11, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x05, 0x03, 0x12, 0x04, 0x8b, 0x06, 0x20, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x06, 0x12, 0x04, 0x8c, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x06, 0x04, 0x12, 0x04, 0x8c, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x06, 0x05, 0x12, 0x04, 0x8c, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x06, 0x01, 0x12, 0x04, 0x8c, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x06, 0x03, 0x12, 0x04, 0x8c, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02,
    0x07, 0x12, 0x04, 0x8d, 0x06, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x04,
    0x12, 0x04, 0x8d, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x05, 0x12,
    0x04, 0x8d, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x8d, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x07, 0x03, 0x12, 0x04, 0x8d,
    0x06, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x08, 0x12, 0x04, 0x8e, 0x06, 0x02,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x04, 0x12, 0x04, 0x8e, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x05, 0x12, 0x04, 0x8e, 0x06, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x01, 0x12, 0x04, 0x8e, 0x06, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x08, 0x03, 0x12, 0x04, 0x8e, 0x06, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x09, 0x12, 0x04, 0x8f, 0x06, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x09, 0x04, 0x12, 0x04, 0x8f, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x09, 0x05, 0x12, 0x04, 0x8f, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x09, 0x01, 0x12, 0x04, 0x8f, 0x06, 0x11, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x09,
    0x03, 0x12, 0x04, 0x8f, 0x06, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x0a, 0x12,
    0x04, 0x90, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x04, 0x12, 0x04,
    0x90, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x90,
    0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x90, 0x06,
    0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0a, 0x03, 0x12, 0x04, 0x90, 0x06, 0x20,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x0b, 0x12, 0x04, 0x91, 0x06, 0x02, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x04, 0x12, 0x04, 0x91, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x0b, 0x05, 0x12, 0x04, 0x91, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x0b, 0x01, 0x12, 0x04, 0x91, 0x06, 0x11, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x0b, 0x03, 0x12, 0x04, 0x91, 0x06, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x18, 0x02, 0x0c, 0x12, 0x04, 0x92, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x0c, 0x04, 0x12, 0x04, 0x92, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0c,
    0x05, 0x12, 0x04, 0x92, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0c, 0x01,
    0x12, 0x04, 0x92, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0c, 0x03, 0x12,
    0x04, 0x92, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x0d, 0x12, 0x04, 0x93,
    0x06, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0d, 0x04, 0x12, 0x04, 0x93, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0d, 0x05, 0x12, 0x04, 0x93, 0x06, 0x0b,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0d, 0x01, 0x12, 0x04, 0x93, 0x06, 0x11, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0d, 0x03, 0x12, 0x04, 0x93, 0x06, 0x22, 0x24, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x0e, 0x12, 0x04, 0x94, 0x06, 0x02, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x0e, 0x04, 0x12, 0x04, 0x94, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x0e, 0x05, 0x12, 0x04, 0x94, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x0e, 0x01, 0x12, 0x04, 0x94, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x0e, 0x03, 0x12, 0x04, 0x94, 0x06, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02,
    0x0f, 0x12, 0x04, 0x95, 0x06, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0f, 0x04,
    0x12, 0x04, 0x95, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0f, 0x05, 0x12,
    0x04, 0x95, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0f, 0x01, 0x12, 0x04,
    0x95, 0x06, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x0f, 0x03, 0x12, 0x04, 0x95,
    0x06, 0x1d, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x10, 0x12, 0x04, 0x96, 0x06, 0x02,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x10, 0x04, 0x12, 0x04, 0x96, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x10, 0x05, 0x12, 0x04, 0x96, 0x06, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x10, 0x01, 0x12, 0x04, 0x96, 0x06, 0x11, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x10, 0x03, 0x12, 0x04, 0x96, 0x06, 0x23, 0x25, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x11, 0x12, 0x04, 0x97, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x11, 0x04, 0x12, 0x04, 0x97, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x11, 0x05, 0x12, 0x04, 0x97, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x11, 0x01, 0x12, 0x04, 0x97, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x11,
    0x03, 0x12, 0x04, 0x97, 0x06, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x12, 0x12,
    0x04, 0x98, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x12, 0x04, 0x12, 0x04,
    0x98, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x12, 0x05, 0x12, 0x04, 0x98,
    0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x12, 0x01, 0x12, 0x04, 0x98, 0x06,
    0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x12, 0x03, 0x12, 0x04, 0x98, 0x06, 0x20,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x13, 0x12, 0x04, 0x99, 0x06, 0x02, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x13, 0x04, 0x12, 0x04, 0x99, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x13, 0x05, 0x12, 0x04, 0x99, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x13, 0x01, 0x12, 0x04, 0x99, 0x06, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x13, 0x03, 0x12, 0x04, 0x99, 0x06, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x18, 0x02, 0x14, 0x12, 0x04, 0x9a, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x14, 0x04, 0x12, 0x04, 0x9a, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x14,
    0x05, 0x12, 0x04, 0x9a, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x14, 0x01,
    0x12, 0x04, 0x9a, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x14, 0x03, 0x12,
    0x04, 0x9a, 0x06, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x15, 0x12, 0x04, 0x9b,
    0x06, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x15, 0x04, 0x12, 0x04, 0x9b, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x15, 0x05, 0x12, 0x04, 0x9b, 0x06, 0x0b,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x15, 0x01, 0x12, 0x04, 0x9b, 0x06, 0x11, 0x19,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x15, 0x03, 0x12, 0x04, 0x9b, 0x06, 0x1c, 0x1e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x16, 0x12, 0x04, 0x9c, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x18, 0x02, 0x16, 0x04, 0x12, 0x04, 0x9c, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x16, 0x05, 0x12, 0x04, 0x9c, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x16, 0x01, 0x12, 0x04, 0x9c, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x16, 0x03, 0x12, 0x04, 0x9c, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02,
    0x17, 0x12, 0x04, 0x9d, 0x06, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x17, 0x04,
    0x12, 0x04, 0x9d, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x17, 0x05, 0x12,
    0x04, 0x9d, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x17, 0x01, 0x12, 0x04,
    0x9d, 0x06, 0x11, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x17, 0x03, 0x12, 0x04, 0x9d,
    0x06, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x18, 0x12, 0x04, 0x9e, 0x06, 0x02,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x18, 0x04, 0x12, 0x04, 0x9e, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x18, 0x05, 0x12, 0x04, 0x9e, 0x06, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x18, 0x01, 0x12, 0x04, 0x9e, 0x06, 0x11, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x18, 0x02, 0x18, 0x03, 0x12, 0x04, 0x9e, 0x06, 0x24, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x18, 0x02, 0x19, 0x12, 0x04, 0x9f, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x19, 0x04, 0x12, 0x04, 0x9f, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x19, 0x05, 0x12, 0x04, 0x9f, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x19, 0x01, 0x12, 0x04, 0x9f, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x19,
    0x03, 0x12, 0x04, 0x9f, 0x06, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x1a, 0x12,
    0x04, 0xa0, 0x06, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x1a, 0x04, 0x12, 0x04,
    0xa0, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x1a, 0x05, 0x12, 0x04, 0xa0,
    0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x1a, 0x01, 0x12, 0x04, 0xa0, 0x06,
    0x11, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x1a, 0x03, 0x12, 0x04, 0xa0, 0x06, 0x23,
    0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0xa4, 0x06, 0x00, 0xb4, 0x06, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0xa4, 0x06, 0x08, 0x15, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0xa5, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xa5, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xa5, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xa5, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xa5, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x01, 0x12, 0x04,
    0xa6, 0x06, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa6,
    0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa6, 0x06,
    0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x06, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6, 0x06, 0x1a, 0x1b,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x02, 0x12, 0x04, 0xa7, 0x06, 0x02, 0x1c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa7, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa7, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa7, 0x06, 0x1a, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19,
    0x02, 0x03, 0x12, 0x04, 0xa8, 0x06, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xa8, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xa8, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xa8, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xa8, 0x06, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x04, 0x12, 0x04, 0xa9, 0x06,
    0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x04, 0x12, 0x04, 0xa9, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x05, 0x12, 0x04, 0xa9, 0x06, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa9, 0x06, 0x11, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa9, 0x06, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x19, 0x02, 0x05, 0x12, 0x04, 0xaa, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x05, 0x04, 0x12, 0x04, 0xaa, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x05, 0x05, 0x12, 0x04, 0xaa, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xaa, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xaa, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x06,
    0x12, 0x04, 0xab, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xab, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x06, 0x05, 0x12, 0x04,
    0xab, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x06, 0x01, 0x12, 0x04, 0xab,
    0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x06, 0x03, 0x12, 0x04, 0xab, 0x06,
    0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x07, 0x12, 0x04, 0xac, 0x06, 0x02, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x07, 0x04, 0x12, 0x04, 0xac, 0x06, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x07, 0x05, 0x12, 0x04, 0xac, 0x06, 0x0b, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x07, 0x01, 0x12, 0x04, 0xac, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x07, 0x03, 0x12, 0x04, 0xac, 0x06, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x19, 0x02, 0x08, 0x12, 0x04, 0xad, 0x06, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x08, 0x04, 0x12, 0x04, 0xad, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x08, 0x05, 0x12, 0x04, 0xad, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x08,
    0x01, 0x12, 0x04, 0xad, 0x06, 0x11, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x08, 0x03,
    0x12, 0x04, 0xad, 0x06, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x09, 0x12, 0x04,
    0xae, 0x06, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x09, 0x04, 0x12, 0x04, 0xae,
    0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x09, 0x05, 0x12, 0x04, 0xae, 0x06,
    0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x09, 0x01, 0x12, 0x04, 0xae, 0x06, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x09, 0x03, 0x12, 0x04, 0xae, 0x06, 0x1a, 0x1c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x0a, 0x12, 0x04, 0xaf, 0x06, 0x02, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xaf, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xaf, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xaf, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xaf, 0x06, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19,
    0x02, 0x0b, 0x12, 0x04, 0xb0, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0b,
    0x04, 0x12, 0x04, 0xb0, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0b, 0x05,
    0x12, 0x04, 0xb0, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0b, 0x01, 0x12,
    0x04, 0xb0, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0b, 0x03, 0x12, 0x04,
    0xb0, 0x06, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x0c, 0x12, 0x04, 0xb1, 0x06,
    0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xb1, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xb1, 0x06, 0x0b, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xb1, 0x06, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xb1, 0x06, 0x1a, 0x1c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x19, 0x02, 0x0d, 0x12, 0x04, 0xb2, 0x06, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xb2, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xb2, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x0d, 0x01, 0x12, 0x04, 0xb2, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x0d, 0x03, 0x12, 0x04, 0xb2, 0x06, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x0e,
    0x12, 0x04, 0xb3, 0x06, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0e, 0x04, 0x12,
    0x04, 0xb3, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0e, 0x05, 0x12, 0x04,
    0xb3, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xb3,
    0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xb3, 0x06,
    0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1a, 0x12, 0x06, 0xb7, 0x06, 0x00, 0xc0, 0x06, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01, 0x12, 0x04, 0xb7, 0x06, 0x08, 0x15, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04, 0xb8, 0x06, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb8, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xb8, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xb8, 0x06, 0x11, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xb8, 0x06, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x01, 0x12,
    0x04, 0xb9, 0x06, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xb9, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb9,
    0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb9, 0x06,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb9, 0x06, 0x1b,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x02, 0x12, 0x04, 0xba, 0x06, 0x02, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xba, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xba, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xba, 0x06, 0x11, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xba, 0x06, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1a, 0x02, 0x03, 0x12, 0x04, 0xbb, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xbb, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x03,
    0x05, 0x12, 0x04, 0xbb, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xbb, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xbb, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x04, 0x12, 0x04, 0xbc,
    0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xbc, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x04, 0x05, 0x12, 0x04, 0xbc, 0x06, 0x0b,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x04, 0x01, 0x12, 0x04, 0xbc, 0x06, 0x11, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x04, 0x03, 0x12, 0x04, 0xbc, 0x06, 0x20, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x05, 0x12, 0x04, 0xbd, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x05, 0x04, 0x12, 0x04, 0xbd, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x05, 0x05, 0x12, 0x04, 0xbd, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x05, 0x01, 0x12, 0x04, 0xbd, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a,
    0x02, 0x05, 0x03, 0x12, 0x04, 0xbd, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02,
    0x06, 0x12, 0x04, 0xbe, 0x06, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x04,
    0x12, 0x04, 0xbe, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x05, 0x12,
    0x04, 0xbe, 0x06, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x01, 0x12, 0x04,
    0xbe, 0x06, 0x11, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x06, 0x03, 0x12, 0x04, 0xbe,
    0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x07, 0x12, 0x04, 0xbf, 0x06, 0x02,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x04, 0x12, 0x04, 0xbf, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x05, 0x12, 0x04, 0xbf, 0x06, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x01, 0x12, 0x04, 0xbf, 0x06, 0x11, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x07, 0x03, 0x12, 0x04, 0xbf, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x1b, 0x12, 0x06, 0xc3, 0x06, 0x00, 0xc8, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x1b, 0x01, 0x12, 0x04, 0xc3, 0x06, 0x08, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x00,
    0x12, 0x04, 0xc4, 0x06, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xc4, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xc4, 0x06, 0x0b, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc4,
    0x06, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc4, 0x06,
    0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x06, 0x02, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc5, 0x06, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc5, 0x06, 0x0b, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc5, 0x06, 0x1a, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc5, 0x06, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1b, 0x02, 0x02, 0x12, 0x04, 0xc6, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xc6, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x02, 0x06, 0x12, 0x04, 0xc6, 0x06, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xc6, 0x06, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xc6, 0x06, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x03, 0x12, 0x04,
    0xc7, 0x06, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc7,
    0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x06, 0x12, 0x04, 0xc7, 0x06,
    0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc7, 0x06, 0x19,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc7, 0x06, 0x25, 0x26,
    0x0a, 0x3a, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xce, 0x06, 0x00, 0xb3, 0x07, 0x01, 0x1a, 0x2c,
    0x2a, 0x0a, 0x20, 0x41, 0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x6f, 0x66,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x1c, 0x01, 0x12, 0x04, 0xce, 0x06, 0x08, 0x1a, 0x0a, 0x3a, 0x0a, 0x04, 0x04, 0x1c, 0x02,
    0x00, 0x12, 0x04, 0xcf, 0x06, 0x02, 0x20, 0x22, 0x2c, 0x20, 0x53, 0x6e, 0x61, 0x70, 0x73, 0x68,
    0x6f, 0x74, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f,
    0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45, 0x70,
    0x6f, 0x63, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xcf, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcf,
    0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcf, 0x06,
    0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf, 0x06, 0x1e,
    0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x06, 0x02, 0x21, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd1, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd1, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd1, 0x06, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd1, 0x06, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1c, 0x02, 0x02, 0x12, 0x04, 0xd2, 0x06, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xd2, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xd2, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xd2, 0x06, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xd2, 0x06, 0x1c, 0x1e, 0x0a, 0x5b, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x03, 0x12, 0x04, 0xd6,
    0x06, 0x02, 0x2a, 0x1a, 0x4d, 0x20, 0x43, 0x50, 0x55, 0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x3a, 0x0a, 0x20, 0x54, 0x6f,
    0x74, 0x61, 0x6c, 0x20, 0x43, 0x50, 0x55, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20, 0x73, 0x70, 0x65,
    0x6e, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x2c,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x20, 0x6d, 0x6f, 0x64, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd6, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd6, 0x06, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd6, 0x06, 0x12, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd6, 0x06, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1c, 0x02, 0x04, 0x12, 0x04, 0xd7, 0x06, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd7, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd7, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xd7, 0x06, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xd7, 0x06, 0x2a, 0x2b, 0x0a, 0x29, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x05,
    0x12, 0x04, 0xda, 0x06, 0x02, 0x21, 0x1a, 0x1b, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20,
    0x6f, 0x66, 0x20, 0x43, 0x50, 0x55, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65,
    0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x05, 0x04, 0x12, 0x04, 0xda, 0x06,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x05, 0x05, 0x12, 0x04, 0xda, 0x06, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x05, 0x01, 0x12, 0x04, 0xda, 0x06, 0x12, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x05, 0x03, 0x12, 0x04, 0xda, 0x06, 0x1f, 0x20, 0x0a,
    0x47, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x06, 0x12, 0x04, 0xdd, 0x06, 0x02, 0x26, 0x1a, 0x39, 0x20,
    0x63, 0x70, 0x75, 0x2e, 0x73, 0x74, 0x61, 0x74, 0x20, 0x6f, 0x6e, 0x20, 0x70, 0x72, 0x6f, 0x63,
    0x65, 0x73, 0x73, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x69, 0x6e, 0x67, 0x20, 0x28,
    0x66, 0x6f, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69,
    0x73, 0x73, 0x75, 0x65, 0x73, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x06,
    0x04, 0x12, 0x04, 0xdd, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xdd, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xdd, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xdd, 0x06, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x07, 0x12, 0x04, 0xde, 0x06,
    0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x07, 0x04, 0x12, 0x04, 0xde, 0x06, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x07, 0x05, 0x12, 0x04, 0xde, 0x06, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x07, 0x01, 0x12, 0x04, 0xde, 0x06, 0x12, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x07, 0x03, 0x12, 0x04, 0xde, 0x06, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1c, 0x02, 0x08, 0x12, 0x04, 0xdf, 0x06, 0x02, 0x2f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x08, 0x04, 0x12, 0x04, 0xdf, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x08, 0x05, 0x12, 0x04, 0xdf, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x08, 0x01, 0x12, 0x04, 0xdf, 0x06, 0x12, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x08, 0x03, 0x12, 0x04, 0xdf, 0x06, 0x2d, 0x2e, 0x0a, 0xce, 0x02, 0x0a, 0x04, 0x04, 0x1c, 0x02,
    0x09, 0x12, 0x04, 0xe8, 0x06, 0x02, 0x27, 0x1a, 0xbf, 0x02, 0x20, 0x6d, 0x65, 0x6d, 0x5f, 0x74,
    0x6f, 0x74, 0x61, 0x6c, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20, 0x61,
    0x64, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x74,
    0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x0a, 0x20, 0x6f, 0x66,
    0x20, 0x61, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x52, 0x41,
    0x4d, 0x20, 0x28, 0x61, 0x73, 0x20, 0x6f, 0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x69, 0x6e, 0x20, 0x53, 0x77, 0x61, 0x70, 0x29, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x77, 0x61, 0x73, 0x20, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x6c, 0x79, 0x0a, 0x20,
    0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x61, 0x73, 0x20, 0x6d, 0x65, 0x6d, 0x5f,
    0x72, 0x73, 0x73, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
    0x20, 0x77, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65,
    0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75, 0x73, 0x20, 0x6d, 0x65, 0x6d,
    0x6f, 0x72, 0x79, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x65,
    0x65, 0x70, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x79, 0x6e, 0x63, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a,
    0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x27, 0x73, 0x20,
    0x28, 0x61, 0x72, 0x67, 0x75, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x6e, 0x65,
    0x6f, 0x75, 0x73, 0x29, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x65, 0x72, 0x6d,
    0x69, 0x6e, 0x6f, 0x6c, 0x6f, 0x67, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x09, 0x04, 0x12, 0x04, 0xe8, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x09,
    0x05, 0x12, 0x04, 0xe8, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xe8, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xe8, 0x06, 0x24, 0x26, 0x0a, 0x4a, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x0a, 0x12, 0x04, 0xeb,
    0x06, 0x02, 0x2d, 0x1a, 0x3c, 0x20, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x6d, 0x65, 0x6d, 0x6f,
    0x72, 0x79, 0x20, 0x2b, 0x20, 0x73, 0x77, 0x61, 0x70, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e,
    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x66, 0x20,
    0x73, 0x77, 0x61, 0x70, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xeb, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xeb, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xeb, 0x06, 0x12, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xeb, 0x06, 0x2a, 0x2c, 0x0a, 0x32, 0x0a,
    0x04, 0x04, 0x1c, 0x02, 0x0b, 0x12, 0x04, 0xee, 0x06, 0x02, 0x26, 0x1a, 0x24, 0x20, 0x48, 0x61,
    0x72, 0x64, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xee, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xee, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xee, 0x06, 0x12, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xee, 0x06, 0x24, 0x25, 0x0a, 0x32, 0x0a,
    0x04, 0x04, 0x1c, 0x02, 0x0c, 0x12, 0x04, 0xf1, 0x06, 0x02, 0x2c, 0x1a, 0x24, 0x20, 0x53, 0x6f,
    0x66, 0x74, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xf1, 0x06, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xf1, 0x06, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xf1, 0x06, 0x12, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xf1, 0x06, 0x29, 0x2b, 0x0a, 0x77, 0x0a,
    0x04, 0x04, 0x1c, 0x02, 0x0d, 0x12, 0x04, 0xf8, 0x06, 0x02, 0x26, 0x1a, 0x69, 0x20, 0x54, 0x4f,
    0x44, 0x4f, 0x28, 0x63, 0x68, 0x7a, 0x68, 0x63, 0x6e, 0x29, 0x20, 0x6d, 0x65, 0x6d, 0x5f, 0x66,
    0x69, 0x6c, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x65,
    0x6d, 0x5f, 0x61, 0x6e, 0x6f, 0x6e, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65,
    0x20, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20,
    0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e,
    0x32, 0x34, 0x2e, 0x30, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0d, 0x04, 0x12,
    0x04, 0xf8, 0x06, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0d, 0x05, 0x12, 0x04,
    0xf8, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xf8,
    0x06, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0d, 0x03, 0x12, 0x04, 0xf8, 0x06,
    0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x0e, 0x12, 0x04, 0xf9, 0x06, 0x02, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xf9, 0x06, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xf9, 0x06, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xf9, 0x06, 0x12, 0x20, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xf9, 0x06, 0x23, 0x25, 0x0a, 0x51, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x0f, 0x12, 0x04, 0xfc, 0x06, 0x02, 0x27, 0x1a, 0x43, 0x20, 0x6d, 0x65, 0x6d,
    0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x61, 0x64, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x20,
    0x74, 0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x61, 0x67,
    0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xfc, 0x06, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xfc, 0x06, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xfc, 0x06, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xfc, 0x06, 0x24, 0x26, 0x0a, 0xb4, 0x01, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x10, 0x12, 0x04, 0x81, 0x07, 0x02, 0x24, 0x1a, 0xa5, 0x01, 0x20, 0x53, 0x69,
    0x6e, 0x63, 0x65, 0x20, 0x30, 0x2e, 0x32, 0x33, 0x2e, 0x30, 0x2c, 0x20, 0x6d, 0x65, 0x6d, 0x5f,
    0x72, 0x73, 0x73, 0x5f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x68, 0x61,
    0x6e, 0x67, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e,
    0x74, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x61, 0x6e, 0x6f, 0x6e, 0x79, 0x6d, 0x6f, 0x75,
    0x73, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x20,
    0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x6e, 0x65, 0x69, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x69, 0x74, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x6e, 0x65,
    0x73, 0x73, 0x2c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2c, 0x0a, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20,
    0x6e, 0x6f, 0x72, 0x20, 0x6e, 0x75, 0x6d, 0x65, 0x72, 0x69, 0x63, 0x20, 0x74, 0x61, 0x67, 0x20,
    0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x10, 0x04, 0x12, 0x04, 0x81, 0x07, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x10, 0x05, 0x12, 0x04, 0x81, 0x07, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x10, 0x01, 0x12, 0x04, 0x81, 0x07, 0x12, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x10, 0x03, 0x12, 0x04, 0x81, 0x07, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1c, 0x02, 0x11, 0x12, 0x04, 0x83, 0x07, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x11, 0x04, 0x12, 0x04, 0x83, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x11, 0x05, 0x12, 0x04, 0x83, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x11, 0x01, 0x12, 0x04, 0x83, 0x07, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x11, 0x03, 0x12, 0x04, 0x83, 0x07, 0x2a, 0x2c, 0x0a, 0x34, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x12,
    0x12, 0x04, 0x85, 0x07, 0x02, 0x26, 0x1a, 0x26, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x73, 0x65, 0x74, 0x20, 0x69, 0x66, 0x20, 0x73, 0x77, 0x61,
    0x70, 0x20, 0x69, 0x73, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x12, 0x04, 0x12, 0x04, 0x85, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x12, 0x05, 0x12, 0x04, 0x85, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x12, 0x01, 0x12, 0x04, 0x85, 0x07, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x12, 0x03, 0x12, 0x04, 0x85, 0x07, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c,
    0x02, 0x13, 0x12, 0x04, 0x86, 0x07, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x13,
    0x04, 0x12, 0x04, 0x86, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x13, 0x05,
    0x12, 0x04, 0x86, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x13, 0x01, 0x12,
    0x04, 0x86, 0x07, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x13, 0x03, 0x12, 0x04,
    0x86, 0x07, 0x2a, 0x2c, 0x0a, 0x95, 0x02, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x14, 0x12, 0x04, 0x8d,
    0x07, 0x02, 0x30, 0x1a, 0x86, 0x02, 0x20, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x20, 0x6f, 0x66,
    0x20, 0x6f, 0x63, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20,
    0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x73,
    0x20, 0x6f, 0x66, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73,
    0x75, 0x72, 0x65, 0x0a, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x72, 0x65, 0x70, 0x6f,
    0x72, 0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x63,
    0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x20, 0x50, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x20,
    0x6c, 0x69, 0x73, 0x74, 0x65, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x28, 0x72, 0x65, 0x29, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x30,
    0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x28, 0x72, 0x65, 0x29,
    0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x0a, 0x20, 0x68, 0x74, 0x74,
    0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x6b, 0x65, 0x72, 0x6e, 0x65, 0x6c, 0x2e,
    0x6f, 0x72, 0x67, 0x2f, 0x64, 0x6f, 0x63, 0x2f, 0x44, 0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x2f, 0x6d, 0x65,
    0x6d, 0x6f, 0x72, 0x79, 0x2e, 0x74, 0x78, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x0a, 0x20, 0x6d, 0x6f,
    0x72, 0x65, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x14, 0x04, 0x12, 0x04, 0x8d, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x14, 0x05, 0x12, 0x04, 0x8d, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x14, 0x01, 0x12, 0x04, 0x8d, 0x07, 0x12, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x14, 0x03, 0x12, 0x04, 0x8d, 0x07, 0x2d, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x15,
    0x12, 0x04, 0x8e, 0x07, 0x02, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x15, 0x04, 0x12,
    0x04, 0x8e, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x15, 0x05, 0x12, 0x04,
    0x8e, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x15, 0x01, 0x12, 0x04, 0x8e,
    0x07, 0x12, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x15, 0x03, 0x12, 0x04, 0x8e, 0x07,
    0x30, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x16, 0x12, 0x04, 0x8f, 0x07, 0x02, 0x35,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x16, 0x04, 0x12, 0x04, 0x8f, 0x07, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x16, 0x05, 0x12, 0x04, 0x8f, 0x07, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x16, 0x01, 0x12, 0x04, 0x8f, 0x07, 0x12, 0x2f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x16, 0x03, 0x12, 0x04, 0x8f, 0x07, 0x32, 0x34, 0x0a, 0x46, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x17, 0x12, 0x04, 0x92, 0x07, 0x02, 0x28, 0x1a, 0x38, 0x20, 0x44, 0x69, 0x73,
    0x6b, 0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72,
    0x20, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f,
    0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x17, 0x04, 0x12, 0x04, 0x92,
    0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x17, 0x05, 0x12, 0x04, 0x92, 0x07,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x17, 0x01, 0x12, 0x04, 0x92, 0x07, 0x12,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x17, 0x03, 0x12, 0x04, 0x92, 0x07, 0x25, 0x27,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x18, 0x12, 0x04, 0x93, 0x07, 0x02, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x18, 0x04, 0x12, 0x04, 0x93, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x18, 0x05, 0x12, 0x04, 0x93, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x18, 0x01, 0x12, 0x04, 0x93, 0x07, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x18, 0x03, 0x12, 0x04, 0x93, 0x07, 0x24, 0x26, 0x0a, 0x20, 0x0a, 0x04, 0x04, 0x1c,
    0x02, 0x19, 0x12, 0x04, 0x96, 0x07, 0x02, 0x24, 0x1a, 0x12, 0x20, 0x50, 0x65, 0x72, 0x66, 0x20,
    0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x19, 0x04, 0x12, 0x04, 0x96, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x19, 0x06, 0x12, 0x04, 0x96, 0x07, 0x0b, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x19, 0x01, 0x12, 0x04, 0x96, 0x07, 0x1a, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x19, 0x03, 0x12, 0x04, 0x96, 0x07, 0x21, 0x23, 0x0a, 0x2a, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x1a,
    0x12, 0x04, 0x99, 0x07, 0x02, 0x26, 0x1a, 0x1c, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x55, 0x73, 0x61, 0x67, 0x65, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x3a, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1a, 0x04, 0x12, 0x04, 0x99,
    0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1a, 0x05, 0x12, 0x04, 0x99, 0x07,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1a, 0x01, 0x12, 0x04, 0x99, 0x07, 0x12,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1a, 0x03, 0x12, 0x04, 0x99, 0x07, 0x23, 0x25,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x1b, 0x12, 0x04, 0x9a, 0x07, 0x02, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1b, 0x04, 0x12, 0x04, 0x9a, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x1b, 0x05, 0x12, 0x04, 0x9a, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x1b, 0x01, 0x12, 0x04, 0x9a, 0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x1b, 0x03, 0x12, 0x04, 0x9a, 0x07, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c,
    0x02, 0x1c, 0x12, 0x04, 0x9b, 0x07, 0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1c,
    0x04, 0x12, 0x04, 0x9b, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1c, 0x05,
    0x12, 0x04, 0x9b, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1c, 0x01, 0x12,
    0x04, 0x9b, 0x07, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1c, 0x03, 0x12, 0x04,
    0x9b, 0x07, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x1d, 0x12, 0x04, 0x9c, 0x07,
    0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1d, 0x04, 0x12, 0x04, 0x9c, 0x07, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1d, 0x05, 0x12, 0x04, 0x9c, 0x07, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1d, 0x01, 0x12, 0x04, 0x9c, 0x07, 0x12, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1d, 0x03, 0x12, 0x04, 0x9c, 0x07, 0x23, 0x25, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1c, 0x02, 0x1e, 0x12, 0x04, 0x9d, 0x07, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x1e, 0x04, 0x12, 0x04, 0x9d, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x1e, 0x05, 0x12, 0x04, 0x9d, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x1e, 0x01, 0x12, 0x04, 0x9d, 0x07, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x1e, 0x03, 0x12, 0x04, 0x9d, 0x07, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x1f,
    0x12, 0x04, 0x9e, 0x07, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1f, 0x04, 0x12,
    0x04, 0x9e, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1f, 0x05, 0x12, 0x04,
    0x9e, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1f, 0x01, 0x12, 0x04, 0x9e,
    0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x1f, 0x03, 0x12, 0x04, 0x9e, 0x07,
    0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x20, 0x12, 0x04, 0x9f, 0x07, 0x02, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x20, 0x04, 0x12, 0x04, 0x9f, 0x07, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x20, 0x05, 0x12, 0x04, 0x9f, 0x07, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x20, 0x01, 0x12, 0x04, 0x9f, 0x07, 0x12, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x20, 0x03, 0x12, 0x04, 0x9f, 0x07, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x21, 0x12, 0x04, 0xa0, 0x07, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x21, 0x04, 0x12, 0x04, 0xa0, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x21, 0x05, 0x12, 0x04, 0xa0, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x21,
    0x01, 0x12, 0x04, 0xa0, 0x07, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x21, 0x03,
    0x12, 0x04, 0xa0, 0x07, 0x23, 0x25, 0x0a, 0x86, 0x01, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x22, 0x12,
    0x04, 0xa4, 0x07, 0x02, 0x31, 0x1a, 0x78, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6b, 0x65, 0x72, 0x6e,
    0x65, 0x6c, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x73, 0x20, 0x74, 0x72, 0x61, 0x63, 0x6b, 0x20, 0x6f,
    0x66, 0x20, 0x52, 0x54, 0x54, 0x20, 0x28, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x2d, 0x74, 0x72, 0x69,
    0x70, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x29, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x74, 0x73, 0x20,
    0x54, 0x43, 0x50, 0x0a, 0x20, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x73, 0x2e, 0x20, 0x52, 0x54,
    0x54, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x77, 0x61, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x65,
    0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x61, 0x74, 0x65, 0x6e, 0x63, 0x79, 0x20, 0x6f,
    0x66, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x22, 0x04, 0x12, 0x04, 0xa4, 0x07, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x22, 0x05, 0x12, 0x04, 0xa4, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x22, 0x01, 0x12, 0x04, 0xa4, 0x07, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x22, 0x03, 0x12, 0x04, 0xa4, 0x07, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1c, 0x02, 0x23, 0x12, 0x04, 0xa5, 0x07, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x23, 0x04, 0x12, 0x04, 0xa5, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x23,
    0x05, 0x12, 0x04, 0xa5, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x23, 0x01,
    0x12, 0x04, 0xa5, 0x07, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x23, 0x03, 0x12,
    0x04, 0xa5, 0x07, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x24, 0x12, 0x04, 0xa6,
    0x07, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x24, 0x04, 0x12, 0x04, 0xa6, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x24, 0x05, 0x12, 0x04, 0xa6, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x24, 0x01, 0x12, 0x04, 0xa6, 0x07, 0x12, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x24, 0x03, 0x12, 0x04, 0xa6, 0x07, 0x2e, 0x30, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x25, 0x12, 0x04, 0xa7, 0x07, 0x02, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x25, 0x04, 0x12, 0x04, 0xa7, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x25, 0x05, 0x12, 0x04, 0xa7, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x25, 0x01, 0x12, 0x04, 0xa7, 0x07, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x25, 0x03, 0x12, 0x04, 0xa7, 0x07, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02,
    0x26, 0x12, 0x04, 0xa9, 0x07, 0x02, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x26, 0x04,
    0x12, 0x04, 0xa9, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x26, 0x05, 0x12,
    0x04, 0xa9, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x26, 0x01, 0x12, 0x04,
    0xa9, 0x07, 0x12, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x26, 0x03, 0x12, 0x04, 0xa9,
    0x07, 0x2f, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x27, 0x12, 0x04, 0xaa, 0x07, 0x02,
    0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x27, 0x04, 0x12, 0x04, 0xaa, 0x07, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x27, 0x05, 0x12, 0x04, 0xaa, 0x07, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x27, 0x01, 0x12, 0x04, 0xaa, 0x07, 0x12, 0x2f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x27, 0x03, 0x12, 0x04, 0xaa, 0x07, 0x32, 0x34, 0x0a, 0x9d, 0x01,
    0x0a, 0x04, 0x04, 0x1c, 0x02, 0x28, 0x12, 0x04, 0xaf, 0x07, 0x02, 0x48, 0x1a, 0x8e, 0x01, 0x20,
    0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x20,
    0x66, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x6e, 0x74, 0x6f, 0x20, 0x6f, 0x72, 0x20,
    0x6f, 0x75, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x65,
    0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x20, 0x64, 0x75,
    0x65, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x67, 0x65, 0x73, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x6f, 0x72, 0x20, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x20, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x6f, 0x75, 0x74, 0x73, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x28, 0x04, 0x12, 0x04, 0xaf, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x28, 0x06, 0x12, 0x04, 0xaf, 0x07, 0x0b, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x28, 0x01, 0x12, 0x04, 0xaf, 0x07, 0x24, 0x42, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x28, 0x03, 0x12, 0x04, 0xaf, 0x07, 0x45, 0x47, 0x0a, 0x3b, 0x0a, 0x04, 0x04, 0x1c, 0x02,
    0x29, 0x12, 0x04, 0xb2, 0x07, 0x02, 0x33, 0x1a, 0x2d, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x53, 0x4e, 0x4d, 0x50, 0x20, 0x73, 0x74, 0x61, 0x74, 0x69, 0x73, 0x74, 0x69, 0x63,
    0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x29, 0x04, 0x12,
    0x04, 0xb2, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x29, 0x06, 0x12, 0x04,
    0xb2, 0x07, 0x0b, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x29, 0x01, 0x12, 0x04, 0xb2,
    0x07, 0x1a, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x29, 0x03, 0x12, 0x04, 0xb2, 0x07,
    0x30, 0x32, 0x0a, 0x4b, 0x0a, 0x02, 0x04, 0x1d, 0x12, 0x06, 0xb9, 0x07, 0x00, 0xce, 0x07, 0x01,
    0x1a, 0x3d, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61,
    0x20, 0x73, 0x6e, 0x61, 0x70, 0x73, 0x68, 0x6f, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x1d, 0x01, 0x12, 0x04, 0xb9, 0x07, 0x08, 0x15, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x1d, 0x03, 0x00, 0x12, 0x06, 0xba, 0x07, 0x02, 0xc7, 0x07, 0x03, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1d, 0x03, 0x00, 0x01, 0x12, 0x04, 0xba, 0x07, 0x0a, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x1d, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x07, 0x04, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1d, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x07, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xbb, 0x07, 0x0d, 0x19, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbb, 0x07, 0x1a, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbb, 0x07, 0x2a, 0x2b, 0x0a,
    0x63, 0x0a, 0x06, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xbf, 0x07, 0x04, 0x24, 0x1a,
    0x53, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x73, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x69,
    0x74, 0x73, 0x65, 0x6c, 0x66, 0x0a, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61,
    0x73, 0x20, 0x69, 0x74, 0x73, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x73, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xbf, 0x07, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x01, 0x06,
    0x12, 0x04, 0xbf, 0x07, 0x0d, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xbf, 0x07, 0x16, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xbf, 0x07, 0x22, 0x23, 0x0a, 0x66, 0x0a, 0x06, 0x04, 0x1d, 0x03, 0x00,
    0x02, 0x02, 0x12, 0x04, 0xc3, 0x07, 0x04, 0x2f, 0x1a, 0x56, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65,
    0x6e, 0x74, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67,
    0x65, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x61, 0x62, 0x73, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x72, 0x0a,
    0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x75, 0x73, 0x61, 0x67, 0x65, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc3, 0x07, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xc3, 0x07,
    0x0d, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc3,
    0x07, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xc3, 0x07, 0x2d, 0x2e, 0x0a, 0x59, 0x0a, 0x06, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04,
    0xc6, 0x07, 0x04, 0x2a, 0x1a, 0x49, 0x20, 0x54, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc6, 0x07, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x03, 0x06, 0x12, 0x04, 0xc6, 0x07, 0x0d,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc6, 0x07,
    0x19, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc6,
    0x07, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x00, 0x12, 0x04, 0xc9, 0x07, 0x02,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc9, 0x07, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc9, 0x07, 0x0b, 0x13, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc9, 0x07, 0x14, 0x1d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc9, 0x07, 0x20, 0x21, 0x0a, 0x6c, 0x0a,
    0x04, 0x04, 0x1d, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x07, 0x02, 0x1e, 0x1a, 0x5e, 0x20, 0x41, 0x67,
    0x65, 0x6e, 0x74, 0x27, 0x73, 0x20, 0x74, 0x6f, 0x74, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67, 0x20,
    0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x65, 0x64, 0x20, 0x64, 0x79, 0x6e,
    0x61, 0x6d, 0x69, 0x63, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x65, 0x72, 0x73, 0x69, 0x73, 0x74, 0x65, 0x6e,
    0x74, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d,
    0x02, 0x01, 0x06, 0x12, 0x04, 0xcd, 0x07, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xcd, 0x07, 0x14, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xcd, 0x07, 0x1c, 0x1d, 0x0a, 0xa8, 0x03, 0x0a, 0x02, 0x04, 0x1e, 0x12, 0x06,
    0xdd, 0x07, 0x00, 0x99, 0x08, 0x01, 0x1a, 0x99, 0x03, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x6f,
    0x66, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x22, 0x70,
    0x65, 0x72, 0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x22, 0x2e, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20,
    0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x0a, 0x20, 0x4c, 0x69,
    0x6e, 0x75, 0x78, 0x2e, 0x0a, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x45, 0x61, 0x63,
    0x68, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d,
    0x65, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x70, 0x65, 0x72, 0x66, 0x20, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x20, 0x28, 0x73, 0x65, 0x65, 0x0a, 0x20, 0x22, 0x70, 0x65, 0x72, 0x66, 0x20, 0x6c, 0x69,
    0x73, 0x74, 0x22, 0x29, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f,
    0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x3a,
    0x0a, 0x20, 0x31, 0x2e, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64,
    0x6f, 0x77, 0x6e, 0x63, 0x61, 0x73, 0x65, 0x64, 0x2e, 0x0a, 0x20, 0x32, 0x2e, 0x20, 0x48, 0x79,
    0x70, 0x68, 0x65, 0x6e, 0x73, 0x20, 0x28, 0x27, 0x2d, 0x27, 0x29, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x75, 0x6e,
    0x64, 0x65, 0x72, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x73, 0x20, 0x28, 0x27, 0x5f, 0x27, 0x29, 0x2e,
    0x0a, 0x20, 0x33, 0x2e, 0x20, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x20, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x73,
    0x20, 0x75, 0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x22, 0x70,
    0x65, 0x72, 0x66, 0x20, 0x73, 0x74, 0x61, 0x74, 0x22, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
    0x73, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x2e, 0x67, 0x2e, 0x2c, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x20, 0x22, 0x63, 0x79, 0x63, 0x6c,
    0x65, 0x73, 0x20, 0x4f, 0x52, 0x20, 0x63, 0x70, 0x75, 0x2d, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73,
    0x22, 0x20, 0x70, 0x65, 0x72, 0x66, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x72, 0x65,
    0x74, 0x75, 0x72, 0x6e, 0x73, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x73,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1e, 0x01, 0x12, 0x04, 0xdd, 0x07, 0x08, 0x16, 0x0a,
    0x45, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12, 0x04, 0xde, 0x07, 0x02, 0x20, 0x22, 0x37, 0x20,
    0x53, 0x74, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20, 0x69, 0x6e, 0x20, 0x73, 0x65, 0x63,
    0x6f, 0x6e, 0x64, 0x73, 0x20, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x45,
    0x70, 0x6f, 0x63, 0x68, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xde, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xde, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xde,
    0x07, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xde, 0x07,
    0x1e, 0x1f, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x01, 0x12, 0x04, 0xdf, 0x07, 0x02, 0x1f,
    0x22, 0x2a, 0x20, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x73,
    0x61, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20,
    0x69, 0x6e, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdf, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdf, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xdf, 0x07, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xdf, 0x07, 0x1d, 0x1e, 0x0a, 0x1f, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x02,
    0x12, 0x04, 0xe2, 0x07, 0x02, 0x1d, 0x1a, 0x11, 0x20, 0x48, 0x61, 0x72, 0x64, 0x77, 0x61, 0x72,
    0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xe2, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xe2, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xe2, 0x07, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xe2, 0x07, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x03, 0x12, 0x04, 0xe3,
    0x07, 0x02, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe3, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe3, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe3, 0x07, 0x12, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe3, 0x07, 0x2c, 0x2d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x04, 0x12, 0x04, 0xe4, 0x07, 0x02, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe4, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe4, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe4, 0x07, 0x12, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xe4, 0x07, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02,
    0x05, 0x12, 0x04, 0xe5, 0x07, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x05, 0x04,
    0x12, 0x04, 0xe5, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x05, 0x05, 0x12,
    0x04, 0xe5, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x05, 0x01, 0x12, 0x04,
    0xe5, 0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe5,
    0x07, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x06, 0x12, 0x04, 0xe6, 0x07, 0x02,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x06, 0x04, 0x12, 0x04, 0xe6, 0x07, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x06, 0x05, 0x12, 0x04, 0xe6, 0x07, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe6, 0x07, 0x12, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe6, 0x07, 0x25, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x07, 0x12, 0x04, 0xe7, 0x07, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x07, 0x04, 0x12, 0x04, 0xe7, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x07, 0x05, 0x12, 0x04, 0xe7, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x07, 0x01, 0x12, 0x04, 0xe7, 0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x07,
    0x03, 0x12, 0x04, 0xe7, 0x07, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x08, 0x12,
    0x04, 0xe8, 0x07, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x08, 0x04, 0x12, 0x04,
    0xe8, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x08, 0x05, 0x12, 0x04, 0xe8,
    0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x08, 0x01, 0x12, 0x04, 0xe8, 0x07,
    0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x08, 0x03, 0x12, 0x04, 0xe8, 0x07, 0x1d,
    0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x09, 0x12, 0x04, 0xe9, 0x07, 0x02, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x09, 0x04, 0x12, 0x04, 0xe9, 0x07, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x09, 0x05, 0x12, 0x04, 0xe9, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x09, 0x01, 0x12, 0x04, 0xe9, 0x07, 0x12, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x09, 0x03, 0x12, 0x04, 0xe9, 0x07, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x0a, 0x12, 0x04, 0xea, 0x07, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0xea, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0a,
    0x05, 0x12, 0x04, 0xea, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0a, 0x01,
    0x12, 0x04, 0xea, 0x07, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0a, 0x03, 0x12,
    0x04, 0xea, 0x07, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x0b, 0x12, 0x04, 0xeb,
    0x07, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xeb, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xeb, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xeb, 0x07, 0x12, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xeb, 0x07, 0x1f, 0x21, 0x0a,
    0x1f, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x0c, 0x12, 0x04, 0xee, 0x07, 0x02, 0x21, 0x1a, 0x11, 0x20,
    0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xee, 0x07, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xee, 0x07, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xee, 0x07, 0x12, 0x1b, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xee, 0x07, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1e, 0x02, 0x0d, 0x12, 0x04, 0xef, 0x07, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x0d, 0x04, 0x12, 0x04, 0xef, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x0d, 0x05, 0x12, 0x04, 0xef, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0d,
    0x01, 0x12, 0x04, 0xef, 0x07, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0d, 0x03,
    0x12, 0x04, 0xef, 0x07, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x0e, 0x12, 0x04,
    0xf0, 0x07, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xf0,
    0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xf0, 0x07,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xf0, 0x07, 0x12,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xf0, 0x07, 0x20, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x0f, 0x12, 0x04, 0xf1, 0x07, 0x02, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xf1, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xf1, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xf1, 0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xf1, 0x07, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e,
    0x02, 0x10, 0x12, 0x04, 0xf2, 0x07, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x10,
    0x04, 0x12, 0x04, 0xf2, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x10, 0x05,
    0x12, 0x04, 0xf2, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x10, 0x01, 0x12,
    0x04, 0xf2, 0x07, 0x12, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x10, 0x03, 0x12, 0x04,
    0xf2, 0x07, 0x21, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x11, 0x12, 0x04, 0xf3, 0x07,
    0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x11, 0x04, 0x12, 0x04, 0xf3, 0x07, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x11, 0x05, 0x12, 0x04, 0xf3, 0x07, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x11, 0x01, 0x12, 0x04, 0xf3, 0x07, 0x12, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x11, 0x03, 0x12, 0x04, 0xf3, 0x07, 0x25, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x1e, 0x02, 0x12, 0x12, 0x04, 0xf4, 0x07, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x12, 0x04, 0x12, 0x04, 0xf4, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x12, 0x05, 0x12, 0x04, 0xf4, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x12, 0x01, 0x12, 0x04, 0xf4, 0x07, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x12, 0x03, 0x12, 0x04, 0xf4, 0x07, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x13,
    0x12, 0x04, 0xf5, 0x07, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x13, 0x04, 0x12,
    0x04, 0xf5, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x13, 0x05, 0x12, 0x04,
    0xf5, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x13, 0x01, 0x12, 0x04, 0xf5,
    0x07, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x13, 0x03, 0x12, 0x04, 0xf5, 0x07,
    0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x14, 0x12, 0x04, 0xf6, 0x07, 0x02, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x14, 0x04, 0x12, 0x04, 0xf6, 0x07, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x14, 0x05, 0x12, 0x04, 0xf6, 0x07, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x14, 0x01, 0x12, 0x04, 0xf6, 0x07, 0x12, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x14, 0x03, 0x12, 0x04, 0xf6, 0x07, 0x25, 0x27, 0x0a, 0x25, 0x0a, 0x04,
    0x04, 0x1e, 0x02, 0x15, 0x12, 0x04, 0xf9, 0x07, 0x02, 0x27, 0x1a, 0x17, 0x20, 0x48, 0x61, 0x72,
    0x64, 0x77, 0x61, 0x72, 0x65, 0x20, 0x63, 0x61, 0x63, 0x68, 0x65, 0x20, 0x65, 0x76, 0x65, 0x6e,
    0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x15, 0x04, 0x12, 0x04, 0xf9, 0x07,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x15, 0x05, 0x12, 0x04, 0xf9, 0x07, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x15, 0x01, 0x12, 0x04, 0xf9, 0x07, 0x12, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x15, 0x03, 0x12, 0x04, 0xf9, 0x07, 0x24, 0x26, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x16, 0x12, 0x04, 0xfa, 0x07, 0x02, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x16, 0x04, 0x12, 0x04, 0xfa, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x16, 0x05, 0x12, 0x04, 0xfa, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x16, 0x01, 0x12, 0x04, 0xfa, 0x07, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x16, 0x03, 0x12, 0x04, 0xfa, 0x07, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02,
    0x17, 0x12, 0x04, 0xfb, 0x07, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x17, 0x04,
    0x12, 0x04, 0xfb, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x17, 0x05, 0x12,
    0x04, 0xfb, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x17, 0x01, 0x12, 0x04,
    0xfb, 0x07, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x17, 0x03, 0x12, 0x04, 0xfb,
    0x07, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x18, 0x12, 0x04, 0xfc, 0x07, 0x02,
    0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x18, 0x04, 0x12, 0x04, 0xfc, 0x07, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x18, 0x05, 0x12, 0x04, 0xfc, 0x07, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x18, 0x01, 0x12, 0x04, 0xfc, 0x07, 0x12, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x18, 0x03, 0x12, 0x04, 0xfc, 0x07, 0x2b, 0x2d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x19, 0x12, 0x04, 0xfd, 0x07, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x19, 0x04, 0x12, 0x04, 0xfd, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x19, 0x05, 0x12, 0x04, 0xfd, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x19, 0x01, 0x12, 0x04, 0xfd, 0x07, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x19,
    0x03, 0x12, 0x04, 0xfd, 0x07, 0x29, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x1a, 0x12,
    0x04, 0xfe, 0x07, 0x02, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1a, 0x04, 0x12, 0x04,
    0xfe, 0x07, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1a, 0x05, 0x12, 0x04, 0xfe,
    0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1a, 0x01, 0x12, 0x04, 0xfe, 0x07,
    0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1a, 0x03, 0x12, 0x04, 0xfe, 0x07, 0x2e,
    0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x1b, 0x12, 0x04, 0xff, 0x07, 0x02, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1b, 0x04, 0x12, 0x04, 0xff, 0x07, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1b, 0x05, 0x12, 0x04, 0xff, 0x07, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x1b, 0x01, 0x12, 0x04, 0xff, 0x07, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x1b, 0x03, 0x12, 0x04, 0xff, 0x07, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x1c, 0x12, 0x04, 0x80, 0x08, 0x02, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x1c, 0x04, 0x12, 0x04, 0x80, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1c,
    0x05, 0x12, 0x04, 0x80, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1c, 0x01,
    0x12, 0x04, 0x80, 0x08, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1c, 0x03, 0x12,
    0x04, 0x80, 0x08, 0x2a, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x1d, 0x12, 0x04, 0x81,
    0x08, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1d, 0x04, 0x12, 0x04, 0x81, 0x08,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1d, 0x05, 0x12, 0x04, 0x81, 0x08, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1d, 0x01, 0x12, 0x04, 0x81, 0x08, 0x12, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1d, 0x03, 0x12, 0x04, 0x81, 0x08, 0x29, 0x2b, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x1e, 0x12, 0x04, 0x82, 0x08, 0x02, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x1e, 0x04, 0x12, 0x04, 0x82, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x1e, 0x05, 0x12, 0x04, 0x82, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x1e, 0x01, 0x12, 0x04, 0x82, 0x08, 0x12, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x1e, 0x03, 0x12, 0x04, 0x82, 0x08, 0x2e, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02,
    0x1f, 0x12, 0x04, 0x83, 0x08, 0x02, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1f, 0x04,
    0x12, 0x04, 0x83, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1f, 0x05, 0x12,
    0x04, 0x83, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1f, 0x01, 0x12, 0x04,
    0x83, 0x08, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x1f, 0x03, 0x12, 0x04, 0x83,
    0x08, 0x1e, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x20, 0x12, 0x04, 0x84, 0x08, 0x02,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x20, 0x04, 0x12, 0x04, 0x84, 0x08, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x20, 0x05, 0x12, 0x04, 0x84, 0x08, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x20, 0x01, 0x12, 0x04, 0x84, 0x08, 0x12, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x20, 0x03, 0x12, 0x04, 0x84, 0x08, 0x24, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x21, 0x12, 0x04, 0x85, 0x08, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x21, 0x04, 0x12, 0x04, 0x85, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x21, 0x05, 0x12, 0x04, 0x85, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x21, 0x01, 0x12, 0x04, 0x85, 0x08, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x21,
    0x03, 0x12, 0x04, 0x85, 0x08, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x22, 0x12,
    0x04, 0x86, 0x08, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x22, 0x04, 0x12, 0x04,
    0x86, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x22, 0x05, 0x12, 0x04, 0x86,
    0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x22, 0x01, 0x12, 0x04, 0x86, 0x08,
    0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x22, 0x03, 0x12, 0x04, 0x86, 0x08, 0x25,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x23, 0x12, 0x04, 0x87, 0x08, 0x02, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x23, 0x04, 0x12, 0x04, 0x87, 0x08, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x23, 0x05, 0x12, 0x04, 0x87, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x23, 0x01, 0x12, 0x04, 0x87, 0x08, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x23, 0x03, 0x12, 0x04, 0x87, 0x08, 0x23, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x24, 0x12, 0x04, 0x88, 0x08, 0x02, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x24, 0x04, 0x12, 0x04, 0x88, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x24,
    0x05, 0x12, 0x04, 0x88, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x24, 0x01,
    0x12, 0x04, 0x88, 0x08, 0x12, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x24, 0x03, 0x12,
    0x04, 0x88, 0x08, 0x28, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x25, 0x12, 0x04, 0x89,
    0x08, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x25, 0x04, 0x12, 0x04, 0x89, 0x08,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x25, 0x05, 0x12, 0x04, 0x89, 0x08, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x25, 0x01, 0x12, 0x04, 0x89, 0x08, 0x12, 0x1c,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x25, 0x03, 0x12, 0x04, 0x89, 0x08, 0x1f, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x26, 0x12, 0x04, 0x8a, 0x08, 0x02, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x26, 0x04, 0x12, 0x04, 0x8a, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x26, 0x05, 0x12, 0x04, 0x8a, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x26, 0x01, 0x12, 0x04, 0x8a, 0x08, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x26, 0x03, 0x12, 0x04, 0x8a, 0x08, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02,
    0x27, 0x12, 0x04, 0x8b, 0x08, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x27, 0x04,
    0x12, 0x04, 0x8b, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x27, 0x05, 0x12,
    0x04, 0x8b, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x27, 0x01, 0x12, 0x04,
    0x8b, 0x08, 0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x27, 0x03, 0x12, 0x04, 0x8b,
    0x08, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x28, 0x12, 0x04, 0x8c, 0x08, 0x02,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x28, 0x04, 0x12, 0x04, 0x8c, 0x08, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x28, 0x05, 0x12, 0x04, 0x8c, 0x08, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x28, 0x01, 0x12, 0x04, 0x8c, 0x08, 0x12, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x28, 0x03, 0x12, 0x04, 0x8c, 0x08, 0x26, 0x28, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x29, 0x12, 0x04, 0x8d, 0x08, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x29, 0x04, 0x12, 0x04, 0x8d, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x29, 0x05, 0x12, 0x04, 0x8d, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x29, 0x01, 0x12, 0x04, 0x8d, 0x08, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x29,
    0x03, 0x12, 0x04, 0x8d, 0x08, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x2a, 0x12,
    0x04, 0x8e, 0x08, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2a, 0x04, 0x12, 0x04,
    0x8e, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2a, 0x05, 0x12, 0x04, 0x8e,
    0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2a, 0x01, 0x12, 0x04, 0x8e, 0x08,
    0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2a, 0x03, 0x12, 0x04, 0x8e, 0x08, 0x29,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x2b, 0x12, 0x04, 0x8f, 0x08, 0x02, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2b, 0x04, 0x12, 0x04, 0x8f, 0x08, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2b, 0x05, 0x12, 0x04, 0x8f, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x2b, 0x01, 0x12, 0x04, 0x8f, 0x08, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x2b, 0x03, 0x12, 0x04, 0x8f, 0x08, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x2c, 0x12, 0x04, 0x90, 0x08, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x2c, 0x04, 0x12, 0x04, 0x90, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2c,
    0x05, 0x12, 0x04, 0x90, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2c, 0x01,
    0x12, 0x04, 0x90, 0x08, 0x12, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2c, 0x03, 0x12,
    0x04, 0x90, 0x08, 0x25, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x2d, 0x12, 0x04, 0x91,
    0x08, 0x02, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2d, 0x04, 0x12, 0x04, 0x91, 0x08,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2d, 0x05, 0x12, 0x04, 0x91, 0x08, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2d, 0x01, 0x12, 0x04, 0x91, 0x08, 0x12, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2d, 0x03, 0x12, 0x04, 0x91, 0x08, 0x21, 0x23, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x2e, 0x12, 0x04, 0x92, 0x08, 0x02, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x2e, 0x04, 0x12, 0x04, 0x92, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x2e, 0x05, 0x12, 0x04, 0x92, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x2e, 0x01, 0x12, 0x04, 0x92, 0x08, 0x12, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x2e, 0x03, 0x12, 0x04, 0x92, 0x08, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02,
    0x2f, 0x12, 0x04, 0x93, 0x08, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2f, 0x04,
    0x12, 0x04, 0x93, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2f, 0x05, 0x12,
    0x04, 0x93, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2f, 0x01, 0x12, 0x04,
    0x93, 0x08, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x2f, 0x03, 0x12, 0x04, 0x93,
    0x08, 0x1f, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x30, 0x12, 0x04, 0x94, 0x08, 0x02,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x30, 0x04, 0x12, 0x04, 0x94, 0x08, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x30, 0x05, 0x12, 0x04, 0x94, 0x08, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x30, 0x01, 0x12, 0x04, 0x94, 0x08, 0x12, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x30, 0x03, 0x12, 0x04, 0x94, 0x08, 0x25, 0x27, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1e, 0x02, 0x31, 0x12, 0x04, 0x95, 0x08, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1e, 0x02, 0x31, 0x04, 0x12, 0x04, 0x95, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e,
    0x02, 0x31, 0x05, 0x12, 0x04, 0x95, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x31, 0x01, 0x12, 0x04, 0x95, 0x08, 0x12, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x31,
    0x03, 0x12, 0x04, 0x95, 0x08, 0x20, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x32, 0x12,
    0x04, 0x96, 0x08, 0x02, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x32, 0x04, 0x12, 0x04,
    0x96, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x32, 0x05, 0x12, 0x04, 0x96,
    0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x32, 0x01, 0x12, 0x04, 0x96, 0x08,
    0x12, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x32, 0x03, 0x12, 0x04, 0x96, 0x08, 0x26,
    0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x33, 0x12, 0x04, 0x97, 0x08, 0x02, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x33, 0x04, 0x12, 0x04, 0x97, 0x08, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x33, 0x05, 0x12, 0x04, 0x97, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x33, 0x01, 0x12, 0x04, 0x97, 0x08, 0x12, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x33, 0x03, 0x12, 0x04, 0x97, 0x08, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x34, 0x12, 0x04, 0x98, 0x08, 0x02, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x34, 0x04, 0x12, 0x04, 0x98, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x34,
    0x05, 0x12, 0x04, 0x98, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x34, 0x01,
    0x12, 0x04, 0x98, 0x08, 0x12, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x34, 0x03, 0x12,
    0x04, 0x98, 0x08, 0x29, 0x2b, 0x0a, 0xe1, 0x01, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06, 0xa2, 0x08,
    0x00, 0xa5, 0x08, 0x01, 0x1a, 0xd2, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20,
    0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x74, 0x6f, 0x20,
    0x70, 0x72, 0x6f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6c,
    0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x6f, 0x72, 0x2e, 0x20, 0x20, 0x49, 0x66, 0x20, 0x27, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x5f,
    0x69, 0x64, 0x27, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x0a,
    0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x79, 0x20, 0x74, 0x6f, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74,
    0x0a, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1f, 0x01,
    0x12, 0x04, 0xa2, 0x08, 0x08, 0x0f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x00, 0x12, 0x04,
    0xa3, 0x08, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa3,
    0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa3, 0x08,
    0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x08, 0x13,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x08, 0x1e, 0x1f,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x08, 0x02, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa4, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1f, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa4, 0x08, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa4, 0x08, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa4, 0x08, 0x20, 0x21, 0x0a, 0x78, 0x0a, 0x02, 0x04, 0x20,
    0x12, 0x06, 0xac, 0x08, 0x00, 0xea, 0x08, 0x01, 0x1a, 0x6a, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73,
    0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20,
    0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x41, 0x6e, 0x20,
    0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x66,
    0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x73, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x20, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x20, 0x01, 0x12, 0x04, 0xac, 0x08, 0x08,
    0x0d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x00, 0x12, 0x04, 0xad, 0x08, 0x02, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x04, 0x12, 0x04, 0xad, 0x08, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x06, 0x12, 0x04, 0xad, 0x08, 0x0b, 0x12, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12, 0x04, 0xad, 0x08, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04, 0xad, 0x08, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x20, 0x02, 0x01, 0x12, 0x04, 0xae, 0x08, 0x02, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xae, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xae, 0x08, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xae, 0x08, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xae, 0x08, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x02, 0x12, 0x04, 0xaf,
    0x08, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x04, 0x12, 0x04, 0xaf, 0x08,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x06, 0x12, 0x04, 0xaf, 0x08, 0x0b,
    0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x08, 0x13, 0x1b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x02, 0x03, 0x12, 0x04, 0xaf, 0x08, 0x1e, 0x1f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x03, 0x12, 0x04, 0xb0, 0x08, 0x02, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb0, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb0, 0x08, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb0, 0x08, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xb0, 0x08, 0x1d, 0x1e, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x20, 0x02,
    0x04, 0x12, 0x04, 0xb3, 0x08, 0x02, 0x17, 0x1a, 0x31, 0x20, 0x55, 0x52, 0x4c, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61,
    0x67, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20,
    0x02, 0x04, 0x04, 0x12, 0x04, 0xb3, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02,
    0x04, 0x06, 0x12, 0x04, 0xb3, 0x08, 0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xb3, 0x08, 0x0f, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x04, 0x03,
    0x12, 0x04, 0xb3, 0x08, 0x15, 0x16, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x05, 0x12, 0x04,
    0xb5, 0x08, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb5,
    0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x05, 0x06, 0x12, 0x04, 0xb5, 0x08,
    0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x05, 0x01, 0x12, 0x04, 0xb5, 0x08, 0x14,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x05, 0x03, 0x12, 0x04, 0xb5, 0x08, 0x20, 0x21,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x06, 0x12, 0x04, 0xb6, 0x08, 0x02, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb6, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x06, 0x06, 0x12, 0x04, 0xb6, 0x08, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb6, 0x08, 0x15, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb6, 0x08, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20,
    0x02, 0x07, 0x12, 0x04, 0xb7, 0x08, 0x02, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x07,
    0x04, 0x12, 0x04, 0xb7, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x07, 0x06,
    0x12, 0x04, 0xb7, 0x08, 0x0b, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x07, 0x01, 0x12,
    0x04, 0xb7, 0x08, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x07, 0x03, 0x12, 0x04,
    0xb7, 0x08, 0x25, 0x26, 0x0a, 0xb7, 0x04, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x08, 0x12, 0x04, 0xc3,
    0x08, 0x02, 0x2d, 0x1a, 0xa8, 0x04, 0x20, 0x53, 0x69, 0x67, 0x6e, 0x69, 0x66, 0x69, 0x65, 0x73,
    0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x4f, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x0a, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e,
    0x20, 0x20, 0x41, 0x6e, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e,
    0x63, 0x68, 0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62,
    0x65, 0x0a, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x61, 0x72, 0x72, 0x69,
    0x76, 0x65, 0x73, 0x2e, 0x20, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63,
    0x65, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x0a, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x61, 0x20, 0x70, 0x6c, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x20, 0x6d, 0x61, 0x69,
    0x6e, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c,
    0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20,
    0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x73, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20,
    0x61, 0x20, 0x70, 0x6c, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69,
    0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x75,
    0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6e,
    0x65, 0x63, 0x65, 0x73, 0x73, 0x61, 0x72, 0x69, 0x6c, 0x79, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74,
    0x20, 0x61, 0x74, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2c, 0x20, 0x6e, 0x6f, 0x72, 0x20,
    0x6c, 0x61, 0x73, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6c, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e, 0x0a,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c,
    0x69, 0x74, 0x79, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x62, 0x65, 0x20,
    0x66, 0x6f, 0x72, 0x65, 0x76, 0x65, 0x72, 0x21, 0x20, 0x20, 0x53, 0x65, 0x65, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x60, 0x55, 0x6e, 0x61, 0x76,
    0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x60, 0x20, 0x66, 0x6f, 0x72, 0x20,
    0x6d, 0x6f, 0x72, 0x65, 0x20, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x20, 0x02, 0x08, 0x04, 0x12, 0x04, 0xc3, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x20, 0x02, 0x08, 0x06, 0x12, 0x04, 0xc3, 0x08, 0x0b, 0x19, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x20, 0x02, 0x08, 0x01, 0x12, 0x04, 0xc3, 0x08, 0x1a, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x20, 0x02, 0x08, 0x03, 0x12, 0x04, 0xc3, 0x08, 0x2b, 0x2c, 0x0a, 0x4c, 0x0a, 0x04, 0x04, 0x20,
    0x03, 0x00, 0x12, 0x06, 0xc6, 0x08, 0x02, 0xe9, 0x08, 0x03, 0x1a, 0x3c, 0x20, 0x44, 0x65, 0x66,
    0x69, 0x6e, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x70, 0x65,
    0x72, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x64, 0x20, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x73, 0x74, 0x20,
    0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x03, 0x00,
    0x01, 0x12, 0x04, 0xc6, 0x08, 0x0a, 0x13, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x04,
    0x00, 0x12, 0x06, 0xc7, 0x08, 0x04, 0xcd, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03,
    0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x08, 0x09, 0x0d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xc8, 0x08, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc8, 0x08, 0x06, 0x0c, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xc8, 0x08,
    0x0f, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xc9, 0x08, 0x06, 0x12, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xc9, 0x08, 0x06, 0x0d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04,
    0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xc9, 0x08, 0x10, 0x11, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xca, 0x08, 0x06, 0x14, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xca, 0x08, 0x06, 0x0f, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xca, 0x08,
    0x12, 0x13, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x03, 0x12, 0x04,
    0xcb, 0x08, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xcb, 0x08, 0x06, 0x0c, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04,
    0x00, 0x02, 0x03, 0x02, 0x12, 0x04, 0xcb, 0x08, 0x0f, 0x10, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x04, 0x12, 0x04, 0xcc, 0x08, 0x06, 0x12, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcc, 0x08, 0x06, 0x0d, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x04, 0x00, 0x02, 0x04, 0x02, 0x12, 0x04, 0xcc, 0x08,
    0x10, 0x11, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x03, 0x00, 0x12, 0x06, 0xcf, 0x08,
    0x04, 0xd1, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xcf, 0x08, 0x0c, 0x12, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xd0, 0x08, 0x06, 0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd0, 0x08, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20,
    0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd0, 0x08, 0x0f, 0x17, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x08, 0x18, 0x22,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0,
    0x08, 0x25, 0x26, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x03, 0x01, 0x12, 0x06, 0xd3,
    0x08, 0x04, 0xd5, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x03, 0x01, 0x01,
    0x12, 0x04, 0xd3, 0x08, 0x0c, 0x13, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x04, 0xd4, 0x08, 0x06, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00,
    0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd4, 0x08, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x20, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd4, 0x08, 0x0f, 0x17, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd4, 0x08, 0x18,
    0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xd4, 0x08, 0x24, 0x25, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x03, 0x02, 0x12, 0x06,
    0xd7, 0x08, 0x04, 0xd9, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x03, 0x02,
    0x01, 0x12, 0x04, 0xd7, 0x08, 0x0c, 0x15, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00, 0x03,
    0x02, 0x02, 0x00, 0x12, 0x04, 0xd8, 0x08, 0x06, 0x26, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03,
    0x00, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd8, 0x08, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x20, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd8, 0x08, 0x0f, 0x17, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x08,
    0x18, 0x21, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xd8, 0x08, 0x24, 0x25, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x03, 0x03, 0x12,
    0x06, 0xdb, 0x08, 0x04, 0xdd, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x03,
    0x03, 0x01, 0x12, 0x04, 0xdb, 0x08, 0x0c, 0x12, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03, 0x00,
    0x03, 0x03, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x08, 0x06, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20,
    0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x08, 0x06, 0x0e, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdc, 0x08, 0x0f, 0x17,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc,
    0x08, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x03, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xdc, 0x08, 0x22, 0x23, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x03, 0x04,
    0x12, 0x06, 0xdf, 0x08, 0x04, 0xe1, 0x08, 0x05, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00,
    0x03, 0x04, 0x01, 0x12, 0x04, 0xdf, 0x08, 0x0c, 0x13, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x20, 0x03,
    0x00, 0x03, 0x04, 0x02, 0x00, 0x12, 0x04, 0xe0, 0x08, 0x06, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x20, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe0, 0x08, 0x06, 0x0e, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe0, 0x08, 0x0f,
    0x17, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xe0, 0x08, 0x18, 0x1f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x20, 0x03, 0x00, 0x03, 0x04, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe0, 0x08, 0x22, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xe3, 0x08, 0x04, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe3, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xe3, 0x08, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe3, 0x08, 0x12, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20,
    0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe3, 0x08, 0x19, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x20, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe4, 0x08, 0x04, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x20, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe4, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x20, 0x03, 0x00, 0x02, 0x01, 0x06, 0x12, 0x04, 0xe4, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe4, 0x08, 0x14, 0x1a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe4, 0x08, 0x1d, 0x1e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe5, 0x08, 0x04, 0x21, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe5, 0x08, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xe5, 0x08, 0x0d,
    0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe5, 0x08,
    0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe5,
    0x08, 0x1f, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xe6,
    0x08, 0x04, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xe6, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x03, 0x06, 0x12,
    0x04, 0xe6, 0x08, 0x0d, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xe6, 0x08, 0x17, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xe6, 0x08, 0x23, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x20, 0x03, 0x00, 0x02,
    0x04, 0x12, 0x04, 0xe7, 0x08, 0x04, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xe7, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03, 0x00,
    0x02, 0x04, 0x06, 0x12, 0x04, 0xe7, 0x08, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20, 0x03,
    0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe7, 0x08, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x20,
    0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe7, 0x08, 0x1d, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x20, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xe8, 0x08, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x20, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe8, 0x08, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x20, 0x03, 0x00, 0x02, 0x05, 0x06, 0x12, 0x04, 0xe8, 0x08, 0x0d, 0x14, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe8, 0x08, 0x15, 0x1c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x20, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe8, 0x08, 0x1f, 0x20, 0x0a,
    0x4d, 0x0a, 0x02, 0x04, 0x21, 0x12, 0x06, 0xf0, 0x08, 0x00, 0x9d, 0x09, 0x01, 0x1a, 0x3f, 0x2a,
    0x0a, 0x20, 0x41, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x72,
    0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x20, 0x6f, 0x63, 0x63, 0x75, 0x70, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79,
    0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x0a, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x21, 0x01, 0x12, 0x04, 0xf0, 0x08, 0x08, 0x14, 0x0a, 0x7e, 0x0a, 0x04, 0x04,
    0x21, 0x02, 0x00, 0x12, 0x04, 0xf3, 0x08, 0x02, 0x1a, 0x1a, 0x70, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x4f, 0x66, 0x66,
    0x65, 0x72, 0x49, 0x44, 0x20, 0x61, 0x73, 0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x69, 0x6e,
    0x20, 0x6e, 0x6f, 0x72, 0x6d, 0x61, 0x6c, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x73, 0x2c, 0x20,
    0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x0a, 0x20, 0x72, 0x65,
    0x2d, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x49, 0x44, 0x2d, 0x6f, 0x6e, 0x6c, 0x79,
    0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x21, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf3, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xf3, 0x08, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xf3, 0x08, 0x13, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xf3, 0x08, 0x18, 0x19, 0x0a, 0xdb, 0x01, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x01,
    0x12, 0x04, 0xf8, 0x08, 0x02, 0x17, 0x1a, 0xcc, 0x01, 0x20, 0x55, 0x52, 0x4c, 0x20, 0x66, 0x6f,
    0x72, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61,
    0x67, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x2e, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x0a, 0x20, 0x6f, 0x70,
    0x74, 0x69, 0x6d, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x61, 0x73, 0x20, 0x64,
    0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x4d, 0x45, 0x53, 0x4f,
    0x53, 0x2d, 0x33, 0x30, 0x31, 0x32, 0x2c, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x63,
    0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x74,
    0x6f, 0x20, 0x62, 0x79, 0x70, 0x61, 0x73, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x61, 0x6c, 0x6b, 0x20, 0x64, 0x69, 0x72,
    0x65, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67,
    0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xf8, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x06, 0x12, 0x04, 0xf8,
    0x08, 0x0b, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf8, 0x08,
    0x0f, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf8, 0x08, 0x15,
    0x16, 0x0a, 0xa6, 0x01, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x02, 0x12, 0x04, 0xfd, 0x08, 0x02, 0x28,
    0x1a, 0x97, 0x01, 0x20, 0x54, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x72, 0x65,
    0x6c, 0x65, 0x61, 0x73, 0x65, 0x20, 0x69, 0x74, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x20, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x63, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64,
    0x65, 0x64, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61,
    0x67, 0x65, 0x6e, 0x74, 0x29, 0x2c, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x27, 0x73, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73,
    0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xfd, 0x08, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02,
    0x02, 0x06, 0x12, 0x04, 0xfd, 0x08, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xfd, 0x08, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xfd, 0x08, 0x26, 0x27, 0x0a, 0xcd, 0x01, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x03, 0x12,
    0x04, 0x82, 0x09, 0x02, 0x20, 0x1a, 0xbe, 0x01, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72,
    0x63, 0x65, 0x73, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x72,
    0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x70,
    0x61, 0x72, 0x74, 0x69, 0x63, 0x75, 0x6c, 0x61, 0x72, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e,
    0x0a, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77,
    0x6f, 0x72, 0x6b, 0x27, 0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x6f, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x72,
    0x65, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x63, 0x6b,
    0x2c, 0x0a, 0x20, 0x75, 0x6e, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x66, 0x75, 0x72, 0x74, 0x68, 0x65,
    0x72, 0x20, 0x71, 0x75, 0x61, 0x6c, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x60, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x60, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x03, 0x04, 0x12,
    0x04, 0x82, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x03, 0x06, 0x12, 0x04,
    0x82, 0x09, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x03, 0x01, 0x12, 0x04, 0x82,
    0x09, 0x13, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x03, 0x03, 0x12, 0x04, 0x82, 0x09,
    0x1e, 0x1f, 0x0a, 0x9f, 0x06, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x04, 0x12, 0x04, 0x92, 0x09, 0x02,
    0x2d, 0x1a, 0x90, 0x06, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73,
    0x65, 0x4f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74,
    0x73, 0x20, 0x61, 0x20, 0x70, 0x6c, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x20, 0x75, 0x6e, 0x61, 0x76,
    0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x74,
    0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e, 0x20, 0x20, 0x41, 0x6e,
    0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20,
    0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x0a,
    0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x77,
    0x68, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
    0x20, 0x61, 0x72, 0x72, 0x69, 0x76, 0x65, 0x73, 0x2e, 0x20, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65,
    0x66, 0x6f, 0x72, 0x65, 0x2c, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x0a, 0x20, 0x61, 0x69, 0x6d, 0x20, 0x74, 0x6f, 0x20,
    0x67, 0x72, 0x61, 0x63, 0x65, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69,
    0x6e, 0x61, 0x74, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x72, 0x72, 0x69, 0x76, 0x61, 0x6c, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e,
    0x0a, 0x0a, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x20,
    0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 0x78, 0x70,
    0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75,
    0x72, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x2e, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20,
    0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x2c, 0x0a, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x61, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e,
    0x74, 0x65, 0x65, 0x2e, 0x20, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c,
    0x65, 0x2c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69,
    0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x0a, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x6d, 0x61, 0x79,
    0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x20, 0x70, 0x65, 0x72, 0x6d,
    0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x6f,
    0x74, 0x68, 0x65, 0x72, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x2c, 0x20,
    0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x67, 0x75, 0x61, 0x72,
    0x61, 0x6e, 0x74, 0x65, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x62, 0x65, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x65, 0x64,
    0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61,
    0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76,
    0x61, 0x6c, 0x2e, 0x20, 0x20, 0x54, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74,
    0x6f, 0x72, 0x20, 0x68, 0x61, 0x73, 0x20, 0x6e, 0x6f, 0x0a, 0x20, 0x6f, 0x62, 0x6c, 0x69, 0x67,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x72, 0x65, 0x2d, 0x6f, 0x66, 0x66, 0x65,
    0x72, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
    0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x66, 0x74, 0x65, 0x72, 0x0a, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x69, 0x6c, 0x69,
    0x74, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x04, 0x04, 0x12, 0x04, 0x92,
    0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x04, 0x06, 0x12, 0x04, 0x92, 0x09,
    0x0b, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x04, 0x01, 0x12, 0x04, 0x92, 0x09, 0x1a,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x04, 0x03, 0x12, 0x04, 0x92, 0x09, 0x2b, 0x2c,
    0x0a, 0xb2, 0x02, 0x0a, 0x04, 0x04, 0x21, 0x02, 0x05, 0x12, 0x04, 0x99, 0x09, 0x02, 0x22, 0x1a,
    0xa3, 0x02, 0x20, 0x41, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x66, 0x72, 0x6f, 0x6d,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x2c, 0x0a,
    0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x69, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x60, 0x61, 0x67, 0x65,
    0x6e, 0x74, 0x5f, 0x69, 0x64, 0x60, 0x2e, 0x20, 0x20, 0x49, 0x66, 0x20, 0x6e, 0x6f, 0x20, 0x72,
    0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x70, 0x65,
    0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x6c, 0x6c,
    0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x62,
    0x65, 0x69, 0x6e, 0x67, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x62,
    0x61, 0x63, 0x6b, 0x2e, 0x20, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75,
    0x72, 0x70, 0x6f, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x0a, 0x20, 0x6d, 0x61, 0x69, 0x6e, 0x74, 0x65,
    0x6e, 0x61, 0x6e, 0x63, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x65, 0x6d, 0x70, 0x74,
    0x79, 0x20, 0x28, 0x6d, 0x61, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x61,
    0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x0a, 0x20,
    0x61, 0x6c, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x62, 0x61,
    0x63, 0x6b, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x05, 0x04, 0x12, 0x04,
    0x99, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x05, 0x06, 0x12, 0x04, 0x99,
    0x09, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x05, 0x01, 0x12, 0x04, 0x99, 0x09,
    0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x05, 0x03, 0x12, 0x04, 0x99, 0x09, 0x20,
    0x21, 0x0a, 0xdb, 0x02, 0x0a, 0x02, 0x04, 0x22, 0x12, 0x06, 0xa7, 0x09, 0x00, 0xc3, 0x09, 0x01,
    0x1a, 0xcc, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x61, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x20, 0x50, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x66,
    0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65,
    0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x77, 0x61, 0x79, 0x20, 0x74, 0x6f,
    0x20, 0x61, 0x6e, 0x0a, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x28, 0x73,
    0x65, 0x65, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x20,
    0x61, 0x6e, 0x64, 0x0a, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x3a, 0x3a, 0x6c,
    0x61, 0x75, 0x6e, 0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x29, 0x2e, 0x20, 0x45, 0x69, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x20,
    0x6f, 0x72, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x73,
    0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x20, 0x41,
    0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x73, 0x75, 0x62, 0x73, 0x65, 0x71, 0x75,
    0x65, 0x6e, 0x74, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x0a, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x74,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x65, 0x78,
    0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x75, 0x73, 0x65,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x20, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x73, 0x74, 0x72, 0x75, 0x63, 0x74, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x22, 0x01, 0x12, 0x04, 0xa7, 0x09, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x22, 0x02, 0x00, 0x12, 0x04, 0xa8, 0x09, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xa8, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xa8, 0x09, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xa8, 0x09, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xa8, 0x09, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x01, 0x12, 0x04,
    0xa9, 0x09, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa9,
    0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa9, 0x09,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa9, 0x09, 0x12,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa9, 0x09, 0x1c, 0x1d,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x02, 0x12, 0x04, 0xaa, 0x09, 0x02, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x22, 0x02, 0x02, 0x04, 0x12, 0x04, 0xaa, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x22, 0x02, 0x02, 0x06, 0x12, 0x04, 0xaa, 0x09, 0x0b, 0x12, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x22, 0x02, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x09, 0x13, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x02, 0x03, 0x12, 0x04, 0xaa, 0x09, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22,
    0x02, 0x03, 0x12, 0x04, 0xab, 0x09, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xab, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x03, 0x06,
    0x12, 0x04, 0xab, 0x09, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xab, 0x09, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xab, 0x09, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x04, 0x12, 0x04, 0xac, 0x09,
    0x02, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x04, 0x04, 0x12, 0x04, 0xac, 0x09, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x04, 0x06, 0x12, 0x04, 0xac, 0x09, 0x0b, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x04, 0x01, 0x12, 0x04, 0xac, 0x09, 0x18, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x04, 0x03, 0x12, 0x04, 0xac, 0x09, 0x23, 0x24, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x22, 0x02, 0x05, 0x12, 0x04, 0xad, 0x09, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x22, 0x02, 0x05, 0x04, 0x12, 0x04, 0xad, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x05, 0x06, 0x12, 0x04, 0xad, 0x09, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xad, 0x09, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xad, 0x09, 0x21, 0x22, 0x0a, 0x82, 0x01, 0x0a, 0x04, 0x04, 0x22, 0x02,
    0x06, 0x12, 0x04, 0xb0, 0x09, 0x02, 0x27, 0x1a, 0x74, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x20, 0x70,
    0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x61, 0x20, 0x63,
    0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6c, 0x61,
    0x75, 0x6e, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x70, 0x61, 0x72, 0x74, 0x0a, 0x20, 0x6f, 0x66, 0x20, 0x74,
    0x68, 0x69, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x70, 0x61, 0x69, 0x72, 0x65, 0x64, 0x20,
    0x77, 0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x27, 0x73, 0x20,
    0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x22, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb0, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x22, 0x02, 0x06, 0x06, 0x12, 0x04, 0xb0, 0x09, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb0, 0x09, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x06, 0x03, 0x12, 0x04, 0xb0, 0x09, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02,
    0x07, 0x12, 0x04, 0xb1, 0x09, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x07, 0x04,
    0x12, 0x04, 0xb1, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x07, 0x05, 0x12,
    0x04, 0xb1, 0x09, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xb1, 0x09, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x07, 0x03, 0x12, 0x04, 0xb1,
    0x09, 0x18, 0x19, 0x0a, 0x8c, 0x01, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x08, 0x12, 0x04, 0xb4, 0x09,
    0x02, 0x28, 0x1a, 0x7e, 0x20, 0x41, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x20, 0x63, 0x68,
    0x65, 0x63, 0x6b, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x20, 0x28, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x69, 0x6e, 0x20, 0x2a,
    0x61, 0x6c, 0x70, 0x68, 0x61, 0x2a, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x6e, 0x69, 0x74, 0x69,
    0x61, 0x6c, 0x0a, 0x20, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x77, 0x69, 0x6c, 0x6c,
    0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x62, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x54, 0x61, 0x73,
    0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x27, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x68, 0x61, 0x76,
    0x65, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x29,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x08, 0x04, 0x12, 0x04, 0xb4, 0x09, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x08, 0x06, 0x12, 0x04, 0xb4, 0x09, 0x0b, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x08, 0x01, 0x12, 0x04, 0xb4, 0x09, 0x17, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x08, 0x03, 0x12, 0x04, 0xb4, 0x09, 0x26, 0x27, 0x0a, 0x89,
    0x03, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x09, 0x12, 0x04, 0xbc, 0x09, 0x02, 0x1e, 0x1a, 0xfa, 0x02,
    0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65,
    0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20,
    0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x72, 0x65, 0x20,
    0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x0a,
    0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x67, 0x65, 0x6e,
    0x74, 0x20, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x2e, 0x20, 0x4c, 0x61, 0x62,
    0x65, 0x6c, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20,
    0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65,
    0x73, 0x6f, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c, 0x66, 0x2e, 0x20, 0x41, 0x73, 0x20, 0x6f,
    0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61,
    0x74, 0x61, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2c, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x6b, 0x65, 0x70, 0x74, 0x20, 0x69,
    0x6e, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x6e, 0x20, 0x6d, 0x61, 0x73, 0x74,
    0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x70, 0x72, 0x6f,
    0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65, 0x66, 0x6f, 0x72,
    0x65, 0x2c, 0x0a, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c,
    0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x61, 0x67,
    0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6c, 0x69, 0x67, 0x68,
    0x74, 0x2d, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x2d, 0x64, 0x61,
    0x74, 0x61, 0x2e, 0x0a, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75,
    0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x20, 0x64,
    0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x2d, 0x76, 0x61, 0x6c,
    0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x09, 0x04, 0x12, 0x04, 0xbc, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x09, 0x06, 0x12, 0x04, 0xbc, 0x09, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x09,
    0x01, 0x12, 0x04, 0xbc, 0x09, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x09, 0x03,
    0x12, 0x04, 0xbc, 0x09, 0x1b, 0x1d, 0x0a, 0xf1, 0x01, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x0a, 0x12,
    0x04, 0xc2, 0x09, 0x02, 0x28, 0x1a, 0xe2, 0x01, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72,
    0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69,
    0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x61,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f, 0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73,
    0x6f, 0x73, 0x2e, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20,
    0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76,
    0x65, 0x72, 0x79, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x65, 0x64, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x74, 0x6f, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x73, 0x20, 0x77, 0x69, 0x74, 0x68, 0x6f, 0x75, 0x74, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69,
    0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x0a, 0x04, 0x12, 0x04, 0xc2, 0x09, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x0a, 0x06, 0x12, 0x04, 0xc2, 0x09, 0x0b, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x0a,
    0x01, 0x12, 0x04, 0xc2, 0x09, 0x19, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x0a, 0x03,
    0x12, 0x04, 0xc2, 0x09, 0x25, 0x27, 0x0a, 0xa6, 0x02, 0x0a, 0x02, 0x05, 0x01, 0x12, 0x06, 0xcd,
    0x09, 0x00, 0xdb, 0x09, 0x01, 0x1a, 0x97, 0x02, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x70, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20, 0x74, 0x61,
    0x73, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x2e, 0x20, 0x49, 0x4d, 0x50, 0x4f, 0x52,
    0x54, 0x41, 0x4e, 0x54, 0x3a, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x61, 0x73, 0x73, 0x75,
    0x6d, 0x65, 0x73, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20,
    0x65, 0x6e, 0x74, 0x65, 0x72, 0x20, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x73,
    0x74, 0x61, 0x74, 0x65, 0x73, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x62, 0x65, 0x6c, 0x6f, 0x77,
    0x29, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x6c, 0x6f, 0x6e, 0x67, 0x65, 0x72, 0x0a, 0x20, 0x72,
    0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x75, 0x73, 0x20,
    0x63, 0x6c, 0x65, 0x61, 0x6e, 0x20, 0x75, 0x70, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x74, 0x68, 0x69,
    0x6e, 0x67, 0x20, 0x61, 0x73, 0x73, 0x6f, 0x63, 0x69, 0x61, 0x74, 0x65, 0x64, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x0a, 0x20, 0x28, 0x75, 0x6c,
    0x74, 0x69, 0x6d, 0x61, 0x74, 0x65, 0x6c, 0x79, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x69, 0x6e,
    0x67, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x29, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x05, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x09, 0x05, 0x0e, 0x0a, 0x47, 0x0a, 0x04,
    0x05, 0x01, 0x02, 0x00, 0x12, 0x04, 0xce, 0x09, 0x02, 0x13, 0x22, 0x39, 0x20, 0x49, 0x6e, 0x69,
    0x74, 0x69, 0x61, 0x6c, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x20, 0x46, 0x72, 0x61, 0x6d,
    0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x75, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xce, 0x09, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04, 0xce,
    0x09, 0x11, 0x12, 0x0a, 0x3b, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x01, 0x12, 0x04, 0xcf, 0x09, 0x02,
    0x14, 0x22, 0x2d, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x69, 0x73, 0x20,
    0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x20, 0x62,
    0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcf, 0x09, 0x02, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04, 0xcf, 0x09, 0x12, 0x13, 0x0a, 0x0c,
    0x0a, 0x04, 0x05, 0x01, 0x02, 0x02, 0x12, 0x04, 0xd0, 0x09, 0x02, 0x13, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x09, 0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x02, 0x02, 0x12, 0x04, 0xd0, 0x09, 0x11, 0x12, 0x0a, 0x96, 0x01, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x03, 0x12, 0x04, 0xd4, 0x09, 0x02, 0x13, 0x1a, 0x5b, 0x20, 0x4e, 0x4f, 0x54, 0x45,
    0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x6e,
    0x6c, 0x79, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x77, 0x68, 0x65, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x68, 0x61,
    0x73, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x54, 0x41, 0x53, 0x4b, 0x5f, 0x4b, 0x49, 0x4c, 0x4c,
    0x49, 0x4e, 0x47, 0x5f, 0x53, 0x54, 0x41, 0x54, 0x45, 0x20, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69,
    0x6c, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x22, 0x2b, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x20, 0x69, 0x73, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f,
    0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd4, 0x09,
    0x02, 0x0e, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01, 0x02, 0x03, 0x02, 0x12, 0x04, 0xd4, 0x09, 0x11,
    0x12, 0x0a, 0x39, 0x0a, 0x04, 0x05, 0x01, 0x02, 0x04, 0x12, 0x04, 0xd6, 0x09, 0x02, 0x14, 0x22,
    0x2b, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e, 0x41, 0x4c, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64, 0x20, 0x73, 0x75,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd6, 0x09, 0x02, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x04, 0x02, 0x12, 0x04, 0xd6, 0x09, 0x12, 0x13, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x05, 0x12, 0x04, 0xd7, 0x09, 0x02, 0x12, 0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49,
    0x4e, 0x41, 0x4c, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x66, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x20, 0x73,
    0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd7, 0x09, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x05, 0x02, 0x12, 0x04, 0xd7, 0x09, 0x10, 0x11, 0x0a, 0x3e, 0x0a, 0x04, 0x05,
    0x01, 0x02, 0x06, 0x12, 0x04, 0xd8, 0x09, 0x02, 0x12, 0x22, 0x30, 0x20, 0x54, 0x45, 0x52, 0x4d,
    0x49, 0x4e, 0x41, 0x4c, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x77,
    0x61, 0x73, 0x20, 0x6b, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd8, 0x09, 0x02, 0x0d, 0x0a, 0x0d, 0x0a, 0x05, 0x05, 0x01,
    0x02, 0x06, 0x02, 0x12, 0x04, 0xd8, 0x09, 0x10, 0x11, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01, 0x02,
    0x07, 0x12, 0x04, 0xd9, 0x09, 0x02, 0x10, 0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49, 0x4e,
    0x41, 0x4c, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x66, 0x61, 0x69,
    0x6c, 0x65, 0x64, 0x20, 0x62, 0x75, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x72,
    0x65, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd9, 0x09, 0x02, 0x0b, 0x0a, 0x0d, 0x0a, 0x05, 0x05,
    0x01, 0x02, 0x07, 0x02, 0x12, 0x04, 0xd9, 0x09, 0x0e, 0x0f, 0x0a, 0x41, 0x0a, 0x04, 0x05, 0x01,
    0x02, 0x08, 0x12, 0x04, 0xda, 0x09, 0x02, 0x11, 0x22, 0x33, 0x20, 0x54, 0x45, 0x52, 0x4d, 0x49,
    0x4e, 0x41, 0x4c, 0x3a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x64, 0x65,
    0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x05, 0x01, 0x02, 0x08, 0x01, 0x12, 0x04, 0xda, 0x09, 0x02, 0x0c, 0x0a, 0x0d, 0x0a, 0x05,
    0x05, 0x01, 0x02, 0x08, 0x02, 0x12, 0x04, 0xda, 0x09, 0x0f, 0x10, 0x0a, 0x39, 0x0a, 0x02, 0x04,
    0x23, 0x12, 0x06, 0xe1, 0x09, 0x00, 0xb2, 0x0a, 0x01, 0x1a, 0x2b, 0x2a, 0x0a, 0x20, 0x44, 0x65,
    0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x75, 0x72, 0x72,
    0x65, 0x6e, 0x74, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20,
    0x74, 0x61, 0x73, 0x6b, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xe1,
    0x09, 0x08, 0x12, 0x0a, 0x41, 0x0a, 0x04, 0x04, 0x23, 0x04, 0x00, 0x12, 0x06, 0xe3, 0x09, 0x02,
    0xe7, 0x09, 0x03, 0x1a, 0x31, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x75, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x04, 0x00, 0x01, 0x12,
    0x04, 0xe3, 0x09, 0x07, 0x0d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xe4, 0x09, 0x04, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe4, 0x09, 0x04, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x00, 0x02, 0x00,
    0x02, 0x12, 0x04, 0xe4, 0x09, 0x14, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xe5, 0x09, 0x04, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xe5, 0x09, 0x04, 0x10, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x00,
    0x02, 0x01, 0x02, 0x12, 0x04, 0xe5, 0x09, 0x13, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04,
    0x00, 0x02, 0x02, 0x12, 0x04, 0xe6, 0x09, 0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x09, 0x04, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xe6, 0x09, 0x16, 0x17, 0x0a, 0xaf, 0x01, 0x0a, 0x04,
    0x04, 0x23, 0x04, 0x01, 0x12, 0x06, 0xed, 0x09, 0x02, 0x8b, 0x0a, 0x03, 0x1a, 0x9e, 0x01, 0x20,
    0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x20, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f,
    0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68, 0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x44, 0x69, 0x66,
    0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x74, 0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65,
    0x65, 0x6e, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c,
    0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x73, 0x0a, 0x20, 0x28, 0x65, 0x2e, 0x67, 0x2e, 0x20,
    0x75, 0x6e, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x20, 0x76, 0x73, 0x2e, 0x20, 0x75, 0x6e,
    0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d,
    0x61, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x61, 0x6e, 0x63, 0x65, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x04, 0x01, 0x01, 0x12, 0x04, 0xed, 0x09, 0x07, 0x0d, 0x0a, 0xd1, 0x01, 0x0a,
    0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x00, 0x12, 0x04, 0xf1, 0x09, 0x04, 0x27, 0x1a, 0xc0, 0x01,
    0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x6a, 0x69, 0x65, 0x79, 0x75, 0x29, 0x3a, 0x20, 0x54, 0x68,
    0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20,
    0x77, 0x68, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x65, 0x72, 0x20, 0x64, 0x6f,
    0x65, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x6f, 0x72, 0x0a,
    0x20, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x30, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x73, 0x6f, 0x20, 0x69, 0x64, 0x65, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x30, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x20, 0x6f, 0x6e, 0x65, 0x2e, 0x0a, 0x20,
    0x53, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x77, 0x68, 0x65, 0x72, 0x65, 0x2c,
    0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf1, 0x09, 0x04,
    0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x00, 0x02, 0x12, 0x04, 0xf1, 0x09,
    0x25, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x09,
    0x04, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf3,
    0x09, 0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x01, 0x02, 0x12, 0x04,
    0xf3, 0x09, 0x25, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x02, 0x12, 0x04,
    0xf4, 0x09, 0x04, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xf4, 0x09, 0x04, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x02, 0x02,
    0x12, 0x04, 0xf4, 0x09, 0x22, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x03,
    0x12, 0x04, 0xf5, 0x09, 0x04, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xf5, 0x09, 0x04, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02,
    0x03, 0x02, 0x12, 0x04, 0xf5, 0x09, 0x27, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x04, 0x12, 0x04, 0xf6, 0x09, 0x04, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xf6, 0x09, 0x04, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04,
    0x01, 0x02, 0x04, 0x02, 0x12, 0x04, 0xf6, 0x09, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x05, 0x12, 0x04, 0xf7, 0x09, 0x04, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf7, 0x09, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x23, 0x04, 0x01, 0x02, 0x05, 0x02, 0x12, 0x04, 0xf7, 0x09, 0x21, 0x23, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x06, 0x12, 0x04, 0xf8, 0x09, 0x04, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf8, 0x09, 0x04, 0x22, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x06, 0x02, 0x12, 0x04, 0xf8, 0x09, 0x25, 0x27, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x07, 0x12, 0x04, 0xf9, 0x09, 0x04, 0x2e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf9, 0x09, 0x04, 0x28, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x07, 0x02, 0x12, 0x04, 0xf9, 0x09, 0x2b, 0x2d,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x08, 0x12, 0x04, 0xfa, 0x09, 0x04, 0x30,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x08, 0x01, 0x12, 0x04, 0xfa, 0x09, 0x04,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x08, 0x02, 0x12, 0x04, 0xfa, 0x09,
    0x2d, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x09, 0x12, 0x04, 0xfb, 0x09,
    0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x09, 0x01, 0x12, 0x04, 0xfb,
    0x09, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x09, 0x02, 0x12, 0x04,
    0xfb, 0x09, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0a, 0x12, 0x04,
    0xfc, 0x09, 0x04, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0a, 0x01, 0x12,
    0x04, 0xfc, 0x09, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0a, 0x02,
    0x12, 0x04, 0xfc, 0x09, 0x23, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0b,
    0x12, 0x04, 0xfd, 0x09, 0x04, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0b,
    0x01, 0x12, 0x04, 0xfd, 0x09, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02,
    0x0b, 0x02, 0x12, 0x04, 0xfd, 0x09, 0x1f, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x0c, 0x12, 0x04, 0xfe, 0x09, 0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x0c, 0x01, 0x12, 0x04, 0xfe, 0x09, 0x04, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04,
    0x01, 0x02, 0x0c, 0x02, 0x12, 0x04, 0xfe, 0x09, 0x16, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x0d, 0x12, 0x04, 0xff, 0x09, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xff, 0x09, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x23, 0x04, 0x01, 0x02, 0x0d, 0x02, 0x12, 0x04, 0xff, 0x09, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x0e, 0x12, 0x04, 0x80, 0x0a, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x0e, 0x01, 0x12, 0x04, 0x80, 0x0a, 0x04, 0x19, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0e, 0x02, 0x12, 0x04, 0x80, 0x0a, 0x1c, 0x1d, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0f, 0x12, 0x04, 0x81, 0x0a, 0x04, 0x23, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0f, 0x01, 0x12, 0x04, 0x81, 0x0a, 0x04, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x0f, 0x02, 0x12, 0x04, 0x81, 0x0a, 0x21, 0x22,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x10, 0x12, 0x04, 0x82, 0x0a, 0x04, 0x1e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x10, 0x01, 0x12, 0x04, 0x82, 0x0a, 0x04,
    0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x10, 0x02, 0x12, 0x04, 0x82, 0x0a,
    0x1c, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x11, 0x12, 0x04, 0x83, 0x0a,
    0x04, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x11, 0x01, 0x12, 0x04, 0x83,
    0x0a, 0x04, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x11, 0x02, 0x12, 0x04,
    0x83, 0x0a, 0x1f, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x12, 0x12, 0x04,
    0x84, 0x0a, 0x04, 0x23, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x12, 0x01, 0x12,
    0x04, 0x84, 0x0a, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x12, 0x02,
    0x12, 0x04, 0x84, 0x0a, 0x20, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x13,
    0x12, 0x04, 0x85, 0x0a, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x13,
    0x01, 0x12, 0x04, 0x85, 0x0a, 0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02,
    0x13, 0x02, 0x12, 0x04, 0x85, 0x0a, 0x1b, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x14, 0x12, 0x04, 0x86, 0x0a, 0x04, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01,
    0x02, 0x14, 0x01, 0x12, 0x04, 0x86, 0x0a, 0x04, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04,
    0x01, 0x02, 0x14, 0x02, 0x12, 0x04, 0x86, 0x0a, 0x1d, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x15, 0x12, 0x04, 0x87, 0x0a, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23,
    0x04, 0x01, 0x02, 0x15, 0x01, 0x12, 0x04, 0x87, 0x0a, 0x04, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x23, 0x04, 0x01, 0x02, 0x15, 0x02, 0x12, 0x04, 0x87, 0x0a, 0x1b, 0x1d, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x16, 0x12, 0x04, 0x88, 0x0a, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x23, 0x04, 0x01, 0x02, 0x16, 0x01, 0x12, 0x04, 0x88, 0x0a, 0x04, 0x17, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x16, 0x02, 0x12, 0x04, 0x88, 0x0a, 0x1a, 0x1c, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x17, 0x12, 0x04, 0x89, 0x0a, 0x04, 0x22, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x17, 0x01, 0x12, 0x04, 0x89, 0x0a, 0x04, 0x1c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x17, 0x02, 0x12, 0x04, 0x89, 0x0a, 0x1f, 0x21,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x23, 0x04, 0x01, 0x02, 0x18, 0x12, 0x04, 0x8a, 0x0a, 0x04, 0x1d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x18, 0x01, 0x12, 0x04, 0x8a, 0x0a, 0x04,
    0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x23, 0x04, 0x01, 0x02, 0x18, 0x02, 0x12, 0x04, 0x8a, 0x0a,
    0x1a, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x00, 0x12, 0x04, 0x8d, 0x0a, 0x02, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d, 0x0a, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8d, 0x0a, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8d, 0x0a, 0x12, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8d, 0x0a, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x23, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x0a, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x8e, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x01, 0x06, 0x12, 0x04, 0x8e, 0x0a, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01,
    0x01, 0x12, 0x04, 0x8e, 0x0a, 0x15, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x03,
    0x12, 0x04, 0x8e, 0x0a, 0x1d, 0x1e, 0x0a, 0x32, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x02, 0x12, 0x04,
    0x8f, 0x0a, 0x02, 0x1e, 0x22, 0x24, 0x20, 0x50, 0x6f, 0x73, 0x73, 0x69, 0x62, 0x6c, 0x65, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x61, 0x69, 0x6e, 0x69,
    0x6e, 0x67, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23,
    0x02, 0x02, 0x04, 0x12, 0x04, 0x8f, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x8f, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x02,
    0x01, 0x12, 0x04, 0x8f, 0x0a, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x02, 0x03,
    0x12, 0x04, 0x8f, 0x0a, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x03, 0x12, 0x04,
    0x90, 0x0a, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x04, 0x12, 0x04, 0x90,
    0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x06, 0x12, 0x04, 0x90, 0x0a,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x01, 0x12, 0x04, 0x90, 0x0a, 0x12,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x03, 0x12, 0x04, 0x90, 0x0a, 0x1b, 0x1c,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x04, 0x12, 0x04, 0x91, 0x0a, 0x02, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x04, 0x04, 0x12, 0x04, 0x91, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x04, 0x06, 0x12, 0x04, 0x91, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x23, 0x02, 0x04, 0x01, 0x12, 0x04, 0x91, 0x0a, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x23, 0x02, 0x04, 0x03, 0x12, 0x04, 0x91, 0x0a, 0x1b, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23,
    0x02, 0x05, 0x12, 0x04, 0x92, 0x0a, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x05,
    0x04, 0x12, 0x04, 0x92, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x05, 0x05,
    0x12, 0x04, 0x92, 0x0a, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x05, 0x01, 0x12,
    0x04, 0x92, 0x0a, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x05, 0x03, 0x12, 0x04,
    0x92, 0x0a, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x06, 0x12, 0x04, 0x93, 0x0a,
    0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x06, 0x04, 0x12, 0x04, 0x93, 0x0a, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x06, 0x06, 0x12, 0x04, 0x93, 0x0a, 0x0b, 0x12,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x06, 0x01, 0x12, 0x04, 0x93, 0x0a, 0x13, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x06, 0x03, 0x12, 0x04, 0x93, 0x0a, 0x1e, 0x1f, 0x0a, 0x30,
    0x0a, 0x04, 0x04, 0x23, 0x02, 0x07, 0x12, 0x04, 0x94, 0x0a, 0x02, 0x26, 0x22, 0x22, 0x20, 0x54,
    0x4f, 0x44, 0x4f, 0x28, 0x62, 0x65, 0x6e, 0x68, 0x29, 0x3a, 0x20, 0x55, 0x73, 0x65, 0x20, 0x69,
    0x6e, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2f, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x07, 0x04, 0x12, 0x04, 0x94, 0x0a, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x07, 0x06, 0x12, 0x04, 0x94, 0x0a, 0x0b, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x07, 0x01, 0x12, 0x04, 0x94, 0x0a, 0x16, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x07, 0x03, 0x12, 0x04, 0x94, 0x0a, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x23, 0x02, 0x08, 0x12, 0x04, 0x95, 0x0a, 0x02, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23,
    0x02, 0x08, 0x04, 0x12, 0x04, 0x95, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x08, 0x05, 0x12, 0x04, 0x95, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x08,
    0x01, 0x12, 0x04, 0x95, 0x0a, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x08, 0x03,
    0x12, 0x04, 0x95, 0x0a, 0x1e, 0x1f, 0x0a, 0xde, 0x03, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x09, 0x12,
    0x04, 0xa0, 0x0a, 0x02, 0x1b, 0x1a, 0xcf, 0x03, 0x20, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65,
    0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x64, 0x65, 0x6c, 0x69, 0x76,
    0x65, 0x72, 0x65, 0x64, 0x20, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x74, 0x6f,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x77,
    0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x20, 0x61, 0x20, 0x27,
    0x75, 0x75, 0x69, 0x64, 0x27, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20,
    0x64, 0x65, 0x6c, 0x69, 0x76, 0x65, 0x72, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x63, 0x65, 0x0a, 0x20,
    0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75,
    0x6c, 0x65, 0x72, 0x2e, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x73, 0x20,
    0x63, 0x61, 0x6e, 0x20, 0x63, 0x68, 0x6f, 0x6f, 0x73, 0x65, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x65,
    0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x6c, 0x79,
    0x20, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x20, 0x73, 0x74, 0x61,
    0x74, 0x75, 0x73, 0x65, 0x73, 0x20, 0x6f, 0x72, 0x20, 0x6c, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x73, 0x63, 0x68, 0x65, 0x64, 0x75, 0x6c, 0x65, 0x72, 0x0a, 0x20, 0x64, 0x72, 0x69, 0x76,
    0x65, 0x72, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x6c, 0x79, 0x20, 0x61, 0x63,
    0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x65, 0x20, 0x28, 0x64, 0x65, 0x66, 0x61, 0x75,
    0x6c, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x4f, 0x44, 0x4f, 0x28, 0x62, 0x6d, 0x61, 0x68,
    0x6c, 0x65, 0x72, 0x29, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x63, 0x75,
    0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x77, 0x72, 0x69, 0x74,
    0x74, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x0a, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64,
    0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72,
    0x2c, 0x20, 0x62, 0x75, 0x74, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x74,
    0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x76, 0x61, 0x6c, 0x69,
    0x64, 0x20, 0x52, 0x46, 0x43, 0x2d, 0x34, 0x31, 0x32, 0x32, 0x20, 0x55, 0x55, 0x49, 0x44, 0x20,
    0x69, 0x66, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x48, 0x54, 0x54,
    0x50, 0x20, 0x41, 0x50, 0x49, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x09, 0x04,
    0x12, 0x04, 0xa0, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x09, 0x05, 0x12,
    0x04, 0xa0, 0x0a, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x09, 0x01, 0x12, 0x04,
    0xa0, 0x0a, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x09, 0x03, 0x12, 0x04, 0xa0,
    0x0a, 0x18, 0x1a, 0x0a, 0xa3, 0x01, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x0a, 0x12, 0x04, 0xa5, 0x0a,
    0x02, 0x1c, 0x1a, 0x94, 0x01, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20,
    0x77, 0x68, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x62, 0x65, 0x65, 0x6e, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d,
    0x69, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x68, 0x65, 0x61, 0x6c, 0x74,
    0x68, 0x79, 0x0a, 0x20, 0x28, 0x74, 0x72, 0x75, 0x65, 0x29, 0x20, 0x6f, 0x72, 0x20, 0x75, 0x6e,
    0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x79, 0x20, 0x28, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x29, 0x20,
    0x61, 0x63, 0x63, 0x6f, 0x72, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x20, 0x66, 0x69, 0x65,
    0x6c, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x61,
    0x6e, 0x64, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0xa5, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0a,
    0x05, 0x12, 0x04, 0xa5, 0x0a, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0a, 0x01,
    0x12, 0x04, 0xa5, 0x0a, 0x10, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0a, 0x03, 0x12,
    0x04, 0xa5, 0x0a, 0x1a, 0x1b, 0x0a, 0x97, 0x03, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x0b, 0x12, 0x04,
    0xad, 0x0a, 0x02, 0x1e, 0x1a, 0x88, 0x03, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65, 0x2d, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x6b, 0x65, 0x79,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x20, 0x77, 0x68, 0x69,
    0x63, 0x68, 0x20, 0x61, 0x72, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74,
    0x68, 0x72, 0x6f, 0x75, 0x67, 0x68, 0x0a, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e,
    0x74, 0x73, 0x2e, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74,
    0x65, 0x64, 0x20, 0x6f, 0x72, 0x0a, 0x20, 0x61, 0x63, 0x74, 0x65, 0x64, 0x20, 0x75, 0x70, 0x6f,
    0x6e, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x69, 0x74, 0x73, 0x65, 0x6c,
    0x66, 0x2e, 0x20, 0x41, 0x73, 0x20, 0x6f, 0x70, 0x70, 0x6f, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x61, 0x74, 0x61, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2c,
    0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x0a, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65,
    0x20, 0x6b, 0x65, 0x70, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20,
    0x6f, 0x6e, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x67,
    0x65, 0x6e, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x2e, 0x20, 0x54,
    0x68, 0x65, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x2c, 0x0a, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c,
    0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x61, 0x67, 0x20, 0x54, 0x61, 0x73, 0x6b, 0x53, 0x74, 0x61, 0x74,
    0x75, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20,
    0x6c, 0x69, 0x67, 0x68, 0x74, 0x2d, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x20, 0x6d, 0x65,
    0x74, 0x61, 0x2d, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x20, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73,
    0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x20, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x6b, 0x65,
    0x79, 0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xad, 0x0a, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x0b, 0x06, 0x12, 0x04, 0xad, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xad, 0x0a, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x23, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xad, 0x0a, 0x1b, 0x1d, 0x0a, 0x64, 0x0a, 0x04, 0x04,
    0x23, 0x02, 0x0c, 0x12, 0x04, 0xb1, 0x0a, 0x02, 0x31, 0x1a, 0x56, 0x20, 0x43, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69,
    0x73, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x64, 0x20, 0x64, 0x79, 0x6e, 0x61, 0x6d,
    0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x0a, 0x20,
    0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xb1, 0x0a, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0c, 0x06, 0x12, 0x04, 0xb1, 0x0a, 0x0b, 0x1a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xb1, 0x0a, 0x1b, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xb1, 0x0a, 0x2e, 0x30, 0x0a, 0x95, 0x01,
    0x0a, 0x02, 0x04, 0x24, 0x12, 0x06, 0xb9, 0x0a, 0x00, 0xc1, 0x0a, 0x01, 0x1a, 0x86, 0x01, 0x2a,
    0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x70, 0x6f, 0x73, 0x73,
    0x69, 0x62, 0x6c, 0x65, 0x20, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62, 0x65, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75,
    0x72, 0x63, 0x65, 0x73, 0x0a, 0x20, 0x28, 0x73, 0x65, 0x65, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75, 0x6e,
    0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x66, 0x6c,
    0x75, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x6f, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24, 0x01, 0x12, 0x04, 0xb9, 0x0a,
    0x08, 0x0f, 0x0a, 0x84, 0x03, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x0a, 0x02,
    0x35, 0x1a, 0xf5, 0x02, 0x20, 0x54, 0x69, 0x6d, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e,
    0x73, 0x69, 0x64, 0x65, 0x72, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73,
    0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x72, 0x65, 0x66, 0x75, 0x73, 0x65, 0x64, 0x2e, 0x20,
    0x4e, 0x6f, 0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x75, 0x6e,
    0x75, 0x73, 0x65, 0x64, 0x0a, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x20,
    0x77, 0x69, 0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72,
    0x65, 0x64, 0x20, 0x72, 0x65, 0x66, 0x75, 0x73, 0x65, 0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x75,
    0x73, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x76,
    0x61, 0x6c, 0x75, 0x65, 0x0a, 0x20, 0x28, 0x62, 0x65, 0x6c, 0x6f, 0x77, 0x29, 0x20, 0x72, 0x65,
    0x67, 0x61, 0x72, 0x64, 0x6c, 0x65, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x77, 0x68, 0x65, 0x74,
    0x68, 0x65, 0x72, 0x20, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20, 0x77, 0x61, 0x73, 0x20,
    0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x53, 0x63, 0x68, 0x65, 0x64,
    0x75, 0x6c, 0x65, 0x72, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x3a, 0x3a, 0x6c, 0x61, 0x75, 0x6e,
    0x63, 0x68, 0x54, 0x61, 0x73, 0x6b, 0x73, 0x2e, 0x20, 0x59, 0x6f, 0x75, 0x20, 0x4d, 0x55, 0x53,
    0x54, 0x20, 0x70, 0x61, 0x73, 0x73, 0x20, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x73, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x0a, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20,
    0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x20, 0x74, 0x68,
    0x69, 0x73, 0x20, 0x62, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x72, 0x20, 0x28, 0x69, 0x2e, 0x65,
    0x2e, 0x2c, 0x20, 0x67, 0x65, 0x74, 0x20, 0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x20, 0x6f,
    0x66, 0x66, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x0a, 0x20, 0x69, 0x6e, 0x63, 0x6c,
    0x75, 0x64, 0x65, 0x73, 0x20, 0x75, 0x6e, 0x75, 0x73, 0x65, 0x64, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x75, 0x72, 0x63, 0x65, 0x73, 0x20, 0x73, 0x6f, 0x6f, 0x6e, 0x65, 0x72, 0x20, 0x6f, 0x72, 0x20,
    0x6c, 0x61, 0x74, 0x65, 0x72, 0x20, 0x74, 0x68, 0x61, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64,
    0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc0, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xc0, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc0, 0x0a, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xc0, 0x0a, 0x23, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x08, 0x12, 0x04,
    0xc0, 0x0a, 0x25, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x07, 0x12, 0x04, 0xc0,
    0x0a, 0x30, 0x33, 0x0a, 0xa3, 0x01, 0x0a, 0x02, 0x04, 0x25, 0x12, 0x06, 0xc9, 0x0a, 0x00, 0xd0,
    0x0a, 0x01, 0x1a, 0x94, 0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
    0x73, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f,
    0x66, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x76, 0x61,
    0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,
    0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x0a, 0x20, 0x43, 0x6f, 0x6d, 0x6d,
    0x61, 0x6e, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x69, 0x6e, 0x20, 0x6f, 0x72, 0x64, 0x65, 0x72,
    0x20, 0x74, 0x6f, 0x20, 0x73, 0x65, 0x74, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d,
    0x65, 0x6e, 0x74, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x20, 0x62, 0x65,
    0x66, 0x6f, 0x72, 0x65, 0x20, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x0a, 0x20,
    0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x25, 0x01,
    0x12, 0x04, 0xc9, 0x0a, 0x08, 0x13, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x25, 0x03, 0x00, 0x12, 0x06,
    0xca, 0x0a, 0x02, 0xcd, 0x0a, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xca, 0x0a, 0x0a, 0x12, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xcb, 0x0a, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xcb, 0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xcb, 0x0a, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xcb, 0x0a, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xcb, 0x0a, 0x1b, 0x1c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x25, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xcc, 0x0a, 0x04, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcc, 0x0a, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x25,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcc, 0x0a, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x25, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcc, 0x0a, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x25, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcc, 0x0a, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x25, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x0a, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x25, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xcf, 0x0a, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xcf, 0x0a, 0x14, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xcf, 0x0a, 0x20, 0x21, 0x0a, 0x54, 0x0a, 0x02, 0x04, 0x26, 0x12, 0x06, 0xd6,
    0x0a, 0x00, 0xd9, 0x0a, 0x01, 0x1a, 0x46, 0x2a, 0x0a, 0x20, 0x41, 0x20, 0x67, 0x65, 0x6e, 0x65,
    0x72, 0x69, 0x63, 0x20, 0x28, 0x6b, 0x65, 0x79, 0x2c, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x29,
    0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x61,
    0x72, 0x69, 0x6f, 0x75, 0x73, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x26, 0x01, 0x12, 0x04, 0xd6, 0x0a, 0x08, 0x11, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x26,
    0x02, 0x00, 0x12, 0x04, 0xd7, 0x0a, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xd7, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xd7, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xd7, 0x0a, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xd7, 0x0a, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x26, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x0a,
    0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x0a, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x0a, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8, 0x0a, 0x12, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x0a, 0x1a, 0x1b, 0x0a, 0x2a,
    0x0a, 0x02, 0x04, 0x27, 0x12, 0x06, 0xdf, 0x0a, 0x00, 0xe1, 0x0a, 0x01, 0x1a, 0x1c, 0x2a, 0x0a,
    0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x50,
    0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x27,
    0x01, 0x12, 0x04, 0xdf, 0x0a, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x00, 0x12,
    0x04, 0xe0, 0x0a, 0x02, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xe0, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe0,
    0x0a, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe0, 0x0a,
    0x15, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe0, 0x0a, 0x21,
    0x22, 0x0a, 0xc0, 0x02, 0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xed, 0x0a, 0x00, 0xf0, 0x0a, 0x01,
    0x1a, 0xb1, 0x02, 0x2a, 0x0a, 0x20, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c,
    0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x76, 0x61, 0x72, 0x69, 0x6f, 0x75, 0x73,
    0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68,
    0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x0a, 0x20,
    0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x41, 0x20, 0x27, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69,
    0x70, 0x61, 0x6c, 0x27, 0x20, 0x69, 0x73, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e,
    0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x27, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x75, 0x73, 0x65, 0x72, 0x27, 0x2e, 0x20, 0x54, 0x68, 0x65,
    0x0a, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x6c, 0x65, 0x20, 0x74, 0x68, 0x65, 0x0a,
    0x20, 0x6c, 0x61, 0x74, 0x74, 0x65, 0x72, 0x20, 0x69, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x65, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x75, 0x73, 0x65, 0x72, 0x20, 0x75, 0x6e,
    0x64, 0x65, 0x72, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x27, 0x73, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75,
    0x74, 0x6f, 0x72, 0x73, 0x2f, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x72,
    0x75, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x28, 0x01, 0x12, 0x04, 0xed, 0x0a, 0x08,
    0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x00, 0x12, 0x04, 0xee, 0x0a, 0x02, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x04, 0x12, 0x04, 0xee, 0x0a, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x05, 0x12, 0x04, 0xee, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x28, 0x02, 0x00, 0x01, 0x12, 0x04, 0xee, 0x0a, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x28, 0x02, 0x00, 0x03, 0x12, 0x04, 0xee, 0x0a, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x28, 0x02, 0x01, 0x12, 0x04, 0xef, 0x0a, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xef, 0x0a, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xef, 0x0a, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xef, 0x0a, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xef, 0x0a, 0x1b, 0x1c, 0x0a, 0xc0, 0x01, 0x0a, 0x02, 0x04, 0x29, 0x12, 0x06, 0xf8, 0x0a,
    0x00, 0xfa, 0x0a, 0x01, 0x1a, 0xb1, 0x01, 0x2a, 0x0a, 0x20, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e,
    0x74, 0x69, 0x61, 0x6c, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x48, 0x54, 0x54, 0x50, 0x20, 0x61, 0x75,
    0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x28, 0x77,
    0x68, 0x65, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x20,
    0x27, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61, 0x6d, 0x65, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x27,
    0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x27, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x61,
    0x70, 0x74, 0x75, 0x72, 0x65, 0x64, 0x20, 0x61, 0x73, 0x0a, 0x20, 0x27, 0x70, 0x72, 0x69, 0x6e,
    0x63, 0x69, 0x70, 0x61, 0x6c, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x27, 0x73, 0x65, 0x63, 0x72,
    0x65, 0x74, 0x27, 0x20, 0x72, 0x65, 0x73, 0x70, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6c, 0x79,
    0x29, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x29, 0x01, 0x12,
    0x04, 0xf8, 0x0a, 0x08, 0x13, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x00, 0x12, 0x04, 0xf9,
    0x0a, 0x02, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf9, 0x0a,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf9, 0x0a, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf9, 0x0a, 0x16, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf9, 0x0a, 0x24, 0x25, 0x0a,
    0xba, 0x01, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06, 0x82, 0x0b, 0x00, 0x92, 0x0b, 0x01, 0x1a, 0xab,
    0x01, 0x2a, 0x0a, 0x20, 0x52, 0x61, 0x74, 0x65, 0x20, 0x28, 0x71, 0x75, 0x65, 0x72, 0x69, 0x65,
    0x73, 0x20, 0x70, 0x65, 0x72, 0x20, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x2c, 0x20, 0x51, 0x50,
    0x53, 0x29, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61,
    0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72,
    0x2e, 0x0a, 0x20, 0x53, 0x74, 0x72, 0x69, 0x63, 0x74, 0x6c, 0x79, 0x20, 0x73, 0x70, 0x65, 0x61,
    0x6b, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20,
    0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a,
    0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x2a, 0x01, 0x12, 0x04, 0x82, 0x0b, 0x08, 0x11, 0x0a, 0x78, 0x0a, 0x04, 0x04, 0x2a, 0x02,
    0x00, 0x12, 0x04, 0x85, 0x0b, 0x02, 0x1a, 0x1a, 0x6a, 0x20, 0x4c, 0x65, 0x61, 0x76, 0x69, 0x6e,
    0x67, 0x20, 0x51, 0x50, 0x53, 0x20, 0x75, 0x6e, 0x73, 0x65, 0x74, 0x20, 0x67, 0x69, 0x76, 0x65,
    0x73, 0x20, 0x69, 0x74, 0x20, 0x75, 0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x20, 0x72,
    0x61, 0x74, 0x65, 0x20, 0x28, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74,
    0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x29, 0x2c, 0x0a, 0x20, 0x77, 0x68, 0x69, 0x63,
    0x68, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x69, 0x6d, 0x70, 0x6c, 0x69, 0x65, 0x73, 0x20, 0x75,
    0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74,
    0x79, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x0b,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x05, 0x12, 0x04, 0x85, 0x0b, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x0b, 0x12, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x0b, 0x18, 0x19, 0x0a,
    0x95, 0x01, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x01, 0x12, 0x04, 0x89, 0x0b, 0x02, 0x20, 0x1a, 0x86,
    0x01, 0x20, 0x50, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x6f, 0x66, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x28, 0x73, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x62,
    0x65, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64, 0x2e, 0x20, 0x53, 0x68, 0x6f,
    0x75, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70,
    0x61, 0x6c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61,
    0x6c, 0x2e, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x28, 0x69, 0x66, 0x20,
    0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x89, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x89, 0x0b, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x89, 0x0b, 0x12, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x01, 0x03, 0x12, 0x04, 0x89,
    0x0b, 0x1e, 0x1f, 0x0a, 0x92, 0x03, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x02, 0x12, 0x04, 0x91, 0x0b,
    0x02, 0x1f, 0x1a, 0x83, 0x03, 0x20, 0x4d, 0x61, 0x78, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
    0x20, 0x6f, 0x66, 0x20, 0x6f, 0x75, 0x74, 0x73, 0x74, 0x61, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x20,
    0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x69, 0x73,
    0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x0a, 0x20, 0x61, 0x6c, 0x6c, 0x6f,
    0x77, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x62, 0x65,
    0x66, 0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x78, 0x74, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65, 0x64,
    0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x69, 0x73,
    0x20, 0x73, 0x65, 0x6e, 0x74, 0x0a, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x65, 0x72, 0x2e, 0x20, 0x4d, 0x65, 0x73, 0x73, 0x61,
    0x67, 0x65, 0x73, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x64, 0x20, 0x62, 0x65, 0x66,
    0x6f, 0x72, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79,
    0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x61, 0x63, 0x68, 0x65, 0x64, 0x20, 0x61, 0x72, 0x65, 0x0a,
    0x20, 0x73, 0x74, 0x69, 0x6c, 0x6c, 0x20, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x61, 0x66, 0x74,
    0x65, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x75, 0x6e, 0x73, 0x70, 0x65, 0x63,
    0x69, 0x66, 0x69, 0x65, 0x64, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x72, 0x69, 0x6e,
    0x63, 0x69, 0x70, 0x61, 0x6c, 0x20, 0x69, 0x73, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65,
    0x64, 0x20, 0x75, 0x6e, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x20, 0x63, 0x61, 0x70, 0x61,
    0x63, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x69, 0x73, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72,
    0x65, 0x64, 0x20, 0x69, 0x66, 0x20, 0x27, 0x71, 0x70, 0x73, 0x27, 0x20, 0x69, 0x73, 0x20, 0x6e,
    0x6f, 0x74, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x91, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x91, 0x0b, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x91, 0x0b, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x91, 0x0b, 0x1d, 0x1e, 0x0a, 0x98, 0x01, 0x0a, 0x02, 0x04, 0x2b, 0x12, 0x06, 0x9a, 0x0b, 0x00,
    0xa6, 0x0b, 0x01, 0x1a, 0x89, 0x01, 0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74,
    0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x52, 0x61, 0x74, 0x65, 0x4c, 0x69, 0x6d, 0x69, 0x74,
    0x2e, 0x0a, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x77, 0x69,
    0x74, 0x68, 0x6f, 0x75, 0x74, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20, 0x6c, 0x69, 0x6d, 0x69, 0x74,
    0x73, 0x20, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x68, 0x65, 0x72, 0x65, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64,
    0x20, 0x75, 0x6e, 0x6c, 0x65, 0x73, 0x73, 0x0a, 0x20, 0x27, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67,
    0x61, 0x74, 0x65, 0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x27,
    0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x2b, 0x01, 0x12, 0x04, 0x9a, 0x0b, 0x08, 0x12, 0x0a, 0x34, 0x0a, 0x04,
    0x04, 0x2b, 0x02, 0x00, 0x12, 0x04, 0x9c, 0x0b, 0x02, 0x20, 0x1a, 0x26, 0x20, 0x49, 0x74, 0x65,
    0x6d, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x75,
    0x6e, 0x69, 0x71, 0x75, 0x65, 0x20, 0x70, 0x72, 0x69, 0x6e, 0x63, 0x69, 0x70, 0x61, 0x6c, 0x73,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9c, 0x0b, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x06, 0x12, 0x04, 0x9c, 0x0b, 0x0b, 0x14,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9c, 0x0b, 0x15, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9c, 0x0b, 0x1e, 0x1f, 0x0a, 0xc7,
    0x01, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x0b, 0x02, 0x2c, 0x1a, 0xb8, 0x01,
    0x20, 0x41, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f,
    0x72, 0x6b, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65,
    0x64, 0x20, 0x69, 0x6e, 0x20, 0x27, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x73, 0x27, 0x20, 0x67, 0x65,
    0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x72,
    0x61, 0x74, 0x65, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x72, 0x61, 0x74, 0x65, 0x20,
    0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x20,
    0x72, 0x61, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x6d, 0x2c, 0x20, 0x69, 0x2e, 0x65, 0x2e, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x69,
    0x72, 0x20, 0x63, 0x6f, 0x6d, 0x62, 0x69, 0x6e, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x72, 0x61, 0x66,
    0x66, 0x69, 0x63, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x72, 0x6f, 0x74, 0x74, 0x6c, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x67, 0x65, 0x74, 0x68, 0x65, 0x72, 0x20, 0x61, 0x74, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x72, 0x61, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xa1, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xa1, 0x0b, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xa1, 0x0b, 0x12, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xa1, 0x0b, 0x2a, 0x2b, 0x0a, 0x98, 0x01, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x02, 0x12, 0x04, 0xa5,
    0x0b, 0x02, 0x31, 0x1a, 0x89, 0x01, 0x20, 0x41, 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x73, 0x70,
    0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x27, 0x6c, 0x69, 0x6d, 0x69,
    0x74, 0x73, 0x27, 0x20, 0x67, 0x65, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x64, 0x65, 0x66,
    0x61, 0x75, 0x6c, 0x74, 0x20, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x2e, 0x0a, 0x20,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x67, 0x67, 0x72, 0x65,
    0x67, 0x61, 0x74, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x73, 0x69, 0x6d, 0x69, 0x6c,
    0x61, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x27, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65,
    0x5f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x71, 0x70, 0x73, 0x27, 0x2e, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa5, 0x0b, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2b, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa5, 0x0b, 0x0b, 0x11, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2b, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x0b, 0x12, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2b, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x0b, 0x2f, 0x30, 0x0a, 0x96, 0x01, 0x0a, 0x02,
    0x04, 0x2c, 0x12, 0x06, 0xad, 0x0b, 0x00, 0xd6, 0x0b, 0x01, 0x1a, 0x87, 0x01, 0x2a, 0x0a, 0x20,
    0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x20, 0x61, 0x6e, 0x20, 0x69, 0x6d, 0x61, 0x67,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20,
    0x6f, 0x72, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x4e, 0x6f,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x74, 0x27, 0x73, 0x20, 0x6f, 0x6e, 0x6c,
    0x79, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x73, 0x20, 0x6f, 0x72, 0x20,
    0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x6f, 0x72, 0x73, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68,
    0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a, 0x65, 0x72, 0x20, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74,
    0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2c, 0x01, 0x12, 0x04, 0xad, 0x0b, 0x08,
    0x0d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2c, 0x04, 0x00, 0x12, 0x06, 0xae, 0x0b, 0x02, 0xb1, 0x0b,
    0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x04, 0x00, 0x01, 0x12, 0x04, 0xae, 0x0b, 0x07, 0x0b,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xaf, 0x0b, 0x04, 0x0d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x0b, 0x04,
    0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xaf, 0x0b,
    0x0b, 0x0c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x0b,
    0x04, 0x0f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb0,
    0x0b, 0x04, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04,
    0xb0, 0x0b, 0x0d, 0x0e, 0x0a, 0x7d, 0x0a, 0x04, 0x04, 0x2c, 0x03, 0x00, 0x12, 0x06, 0xb5, 0x0b,
    0x02, 0xc1, 0x0b, 0x03, 0x1a, 0x6d, 0x20, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x61,
    0x6e, 0x20, 0x41, 0x70, 0x70, 0x63, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x53, 0x65, 0x65, 0x3a, 0x0a, 0x20, 0x68, 0x74,
    0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
    0x2f, 0x61, 0x70, 0x70, 0x63, 0x2f, 0x73, 0x70, 0x65, 0x63, 0x2f, 0x62, 0x6c, 0x6f, 0x62, 0x2f,
    0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x2f, 0x73, 0x70, 0x65, 0x63, 0x2f, 0x61, 0x63, 0x69, 0x2e,
    0x6d, 0x64, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x0b,
    0x0a, 0x0e, 0x0a, 0x28, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x0b,
    0x04, 0x1d, 0x1a, 0x18, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2c, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7, 0x0b, 0x04, 0x0c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb7, 0x0b, 0x0d, 0x13, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x0b, 0x14, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x0b, 0x1b, 0x1c,
    0x0a, 0xdd, 0x01, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xbd, 0x0b, 0x04,
    0x1b, 0x1a, 0xcc, 0x01, 0x20, 0x41, 0x6e, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x49, 0x44,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x22, 0x68, 0x61, 0x73, 0x68,
    0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x2c, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x0a, 0x20,
    0x22, 0x68, 0x61, 0x73, 0x68, 0x22, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61,
    0x73, 0x68, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x20, 0x75, 0x73, 0x65,
    0x64, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x20, 0x69, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x65, 0x78, 0x0a, 0x20, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65,
    0x64, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x2e, 0x20, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x6c,
    0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69,
    0x74, 0x74, 0x65, 0x64, 0x0a, 0x20, 0x68, 0x61, 0x73, 0x68, 0x20, 0x61, 0x6c, 0x67, 0x6f, 0x72,
    0x69, 0x74, 0x68, 0x6d, 0x20, 0x69, 0x73, 0x20, 0x73, 0x68, 0x61, 0x35, 0x31, 0x32, 0x2e, 0x0a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbd, 0x0b, 0x04,
    0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbd, 0x0b,
    0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbd,
    0x0b, 0x14, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xbd, 0x0b, 0x19, 0x1a, 0x0a, 0x51, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04,
    0xc0, 0x0b, 0x04, 0x1f, 0x1a, 0x41, 0x20, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x20,
    0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x2e, 0x20, 0x53, 0x75, 0x67, 0x67, 0x65, 0x73, 0x74, 0x65,
    0x64, 0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x3a, 0x20, 0x22, 0x76, 0x65, 0x72, 0x73, 0x69,
    0x6f, 0x6e, 0x22, 0x2c, 0x20, 0x22, 0x6f, 0x73, 0x22, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22,
    0x61, 0x72, 0x63, 0x68, 0x22, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xc0, 0x0b, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00,
    0x02, 0x02, 0x06, 0x12, 0x04, 0xc0, 0x0b, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc0, 0x0b, 0x14, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c,
    0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc0, 0x0b, 0x1d, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04,
    0x2c, 0x03, 0x01, 0x12, 0x06, 0xc3, 0x0b, 0x02, 0xce, 0x0b, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2c, 0x03, 0x01, 0x01, 0x12, 0x04, 0xc3, 0x0b, 0x0a, 0x10, 0x0a, 0xb6, 0x01, 0x0a, 0x06, 0x04,
    0x2c, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc8, 0x0b, 0x04, 0x1d, 0x1a, 0xa5, 0x01, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69,
    0x6d, 0x61, 0x67, 0x65, 0x2e, 0x20, 0x45, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x5b, 0x52, 0x45, 0x47, 0x49, 0x53,
    0x54, 0x52, 0x59, 0x5f, 0x48, 0x4f, 0x53, 0x54, 0x5b, 0x3a, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54,
    0x52, 0x59, 0x5f, 0x50, 0x4f, 0x52, 0x54, 0x5d, 0x2f, 0x5d, 0x52, 0x45, 0x50, 0x4f, 0x53, 0x49,
    0x54, 0x4f, 0x52, 0x59, 0x5b, 0x3a, 0x54, 0x41, 0x47, 0x7c, 0x40, 0x54, 0x59, 0x50, 0x45, 0x3a,
    0x44, 0x49, 0x47, 0x45, 0x53, 0x54, 0x5d, 0x0a, 0x0a, 0x20, 0x53, 0x65, 0x65, 0x3a, 0x20, 0x68,
    0x74, 0x74, 0x70, 0x73, 0x3a, 0x2f, 0x2f, 0x64, 0x6f, 0x63, 0x73, 0x2e, 0x64, 0x6f, 0x63, 0x6b,
    0x65, 0x72, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65,
    0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x2f, 0x70, 0x75, 0x6c,
    0x6c, 0x2f, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xc8, 0x0b, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xc8, 0x0b, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xc8, 0x0b, 0x14, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xc8, 0x0b, 0x1b, 0x1c, 0x0a, 0xb5, 0x01, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xcd, 0x0b, 0x04, 0x27, 0x1a, 0xa4, 0x01, 0x20, 0x43, 0x72, 0x65, 0x64,
    0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,
    0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x64, 0x6f, 0x63, 0x6b,
    0x65, 0x72, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x2e, 0x0a, 0x20, 0x4e, 0x4f,
    0x54, 0x45, 0x3a, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65,
    0x66, 0x6f, 0x72, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61,
    0x6e, 0x64, 0x20, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x6f, 0x72, 0x73, 0x0a, 0x20, 0x73, 0x68,
    0x6f, 0x75, 0x6c, 0x64, 0x20, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x53, 0x53, 0x4c, 0x20,
    0x77, 0x68, 0x65, 0x6e, 0x20, 0x70, 0x61, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x69,
    0x73, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcd, 0x0b, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xcd, 0x0b, 0x0d,
    0x17, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcd, 0x0b,
    0x18, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcd,
    0x0b, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x00, 0x12, 0x04, 0xd0, 0x0b, 0x02,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd0, 0x0b, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd0, 0x0b, 0x0b, 0x0f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x0b, 0x10, 0x14, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0, 0x0b, 0x17, 0x18, 0x0a, 0x5a, 0x0a,
    0x04, 0x04, 0x2c, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x0b, 0x02, 0x19, 0x1a, 0x4c, 0x20, 0x4f, 0x6e,
    0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f,
    0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x6d, 0x65,
    0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65,
    0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd4, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01,
    0x06, 0x12, 0x04, 0xd4, 0x0b, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xd4, 0x0b, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xd4, 0x0b, 0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x02, 0x12, 0x04, 0xd5,
    0x0b, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd5, 0x0b,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd5, 0x0b, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd5, 0x0b, 0x12, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd5, 0x0b, 0x1b, 0x1c, 0x0a,
    0x91, 0x01, 0x0a, 0x02, 0x04, 0x2d, 0x12, 0x06, 0xdd, 0x0b, 0x00, 0xf5, 0x0b, 0x01, 0x1a, 0x82,
    0x01, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20,
    0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x20, 0x65,
    0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x20,
    0x74, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x6f, 0x72, 0x20,
    0x76, 0x69, 0x63, 0x65, 0x0a, 0x20, 0x76, 0x65, 0x72, 0x73, 0x61, 0x2e, 0x20, 0x42, 0x6f, 0x74,
    0x68, 0x20, 0x70, 0x61, 0x74, 0x68, 0x73, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x65, 0x69, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x72, 0x65, 0x66, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x64, 0x69,
    0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x66, 0x69, 0x6c,
    0x65, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2d, 0x01, 0x12, 0x04, 0xdd, 0x0b, 0x08, 0x0e,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2d, 0x04, 0x00, 0x12, 0x06, 0xde, 0x0b, 0x02, 0xe1, 0x0b, 0x03,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x04, 0x00, 0x01, 0x12, 0x04, 0xde, 0x0b, 0x07, 0x0b, 0x0a,
    0x1d, 0x0a, 0x06, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdf, 0x0b, 0x04, 0x0b, 0x22,
    0x0d, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2d, 0x77, 0x72, 0x69, 0x74, 0x65, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdf, 0x0b, 0x04, 0x06, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xdf, 0x0b, 0x09, 0x0a,
    0x0a, 0x1c, 0x0a, 0x06, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe0, 0x0b, 0x04, 0x0b,
    0x22, 0x0c, 0x20, 0x72, 0x65, 0x61, 0x64, 0x2d, 0x6f, 0x6e, 0x6c, 0x79, 0x2e, 0x0a, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe0, 0x0b, 0x04, 0x06, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2d, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xe0, 0x0b, 0x09, 0x0a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x00, 0x12, 0x04, 0xe3, 0x0b, 0x02, 0x19, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe3, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2d, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe3, 0x0b, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe3, 0x0b, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe3, 0x0b, 0x17, 0x18, 0x0a, 0xd9, 0x01, 0x0a, 0x04, 0x04,
    0x2d, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x0b, 0x02, 0x25, 0x1a, 0xca, 0x01, 0x20, 0x50, 0x61, 0x74,
    0x68, 0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20,
    0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x69, 0x6c,
    0x65, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x70, 0x61, 0x74, 0x68,
    0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x20, 0x70,
    0x61, 0x74, 0x68, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74,
    0x69, 0x76, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63,
    0x74, 0x6f, 0x72, 0x79, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x61, 0x74,
    0x68, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x62, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x65,
    0x20, 0x70, 0x61, 0x74, 0x68, 0x2c, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68,
    0x20, 0x6d, 0x75, 0x73, 0x74, 0x0a, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x65,
    0x78, 0x69, 0x73, 0x74, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xe9, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xe9, 0x0b, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe9,
    0x0b, 0x12, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe9, 0x0b,
    0x23, 0x24, 0x0a, 0x7e, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x02, 0x12, 0x04, 0xf0, 0x0b, 0x02, 0x20,
    0x1a, 0x70, 0x20, 0x41, 0x62, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x65, 0x20, 0x70, 0x61, 0x74, 0x68,
    0x20, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x20, 0x64,
    0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x69, 0x6c, 0x65,
    0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74, 0x20, 0x6f, 0x72, 0x20,
    0x61, 0x0a, 0x20, 0x70, 0x61, 0x74, 0x68, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x20, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf0, 0x0b, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf0, 0x0b, 0x0b, 0x11,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x0b, 0x12, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf0, 0x0b, 0x1e, 0x1f, 0x0a, 0x7b,
    0x0a, 0x04, 0x04, 0x2d, 0x02, 0x03, 0x12, 0x04, 0xf4, 0x0b, 0x02, 0x1b, 0x1a, 0x6d, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d, 0x65, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x6d,
    0x61, 0x67, 0x65, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
    0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x72, 0x6f, 0x6f, 0x74, 0x0a, 0x20, 0x66, 0x69, 0x6c, 0x65,
    0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6c,
    0x6c, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2d, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf4, 0x0b, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d,
    0x02, 0x03, 0x06, 0x12, 0x04, 0xf4, 0x0b, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xf4, 0x0b, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xf4, 0x0b, 0x19, 0x1a, 0x0a, 0xb0, 0x07, 0x0a, 0x02, 0x04, 0x2e, 0x12, 0x06,
    0x8c, 0x0c, 0x00, 0xc9, 0x0c, 0x01, 0x1a, 0xa1, 0x07, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c,
    0x20, 0x61, 0x73, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x72, 0x65, 0x73, 0x6f,
    0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x41, 0x20, 0x66,
    0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74,
    0x65, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x6e, 0x61,
    0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x63, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x20, 0x61, 0x20, 0x76, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c, 0x20, 0x6e, 0x65, 0x74,
    0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2e, 0x0a,
    0x20, 0x54, 0x68, 0x65, 0x20, 0x60, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e, 0x66,
    0x6f, 0x60, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x64, 0x65, 0x73, 0x63, 0x72,
    0x69, 0x62, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74,
    0x69, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x76, 0x69, 0x72, 0x74,
    0x75, 0x61, 0x6c, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2c, 0x20,
    0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x50,
    0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6e,
    0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x20, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x0a, 0x20, 0x28, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
    0x6b, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68,
    0x69, 0x70, 0x29, 0x2e, 0x0a, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f,
    0x72, 0x6b, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69,
    0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65,
    0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20,
    0x6f, 0x72, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x73, 0x0a,
    0x20, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20,
    0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73,
    0x20, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x2e, 0x20, 0x49, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73,
    0x20, 0x61, 0x72, 0x65, 0x20, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x2c, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x69, 0x73, 0x20, 0x73, 0x69, 0x6d,
    0x70, 0x6c, 0x79, 0x20, 0x69, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x64, 0x2e, 0x20, 0x49, 0x6e, 0x0a,
    0x20, 0x66, 0x75, 0x74, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73,
    0x6b, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20, 0x66, 0x61,
    0x69, 0x6c, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73, 0x20, 0x6e,
    0x6f, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x69,
    0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x63, 0x61, 0x70, 0x61, 0x62, 0x69,
    0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x20, 0x28, 0x4d, 0x45, 0x53, 0x4f, 0x53, 0x2d, 0x33, 0x33,
    0x39, 0x30, 0x29, 0x2e, 0x0a, 0x0a, 0x20, 0x41, 0x6e, 0x20, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74,
    0x6f, 0x72, 0x2c, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x6e,
    0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x20, 0x6d, 0x61,
    0x79, 0x20, 0x61, 0x70, 0x70, 0x65, 0x6e, 0x64, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x49, 0x6e, 0x66, 0x6f, 0x73, 0x20, 0x69, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x0a, 0x20, 0x54, 0x61,
    0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3a, 0x3a, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x70, 0x72,
    0x6f, 0x76, 0x69, 0x64, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x49, 0x50, 0x0a, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2e,
    0x01, 0x12, 0x04, 0x8c, 0x0c, 0x08, 0x13, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2e, 0x04, 0x00, 0x12,
    0x06, 0x8d, 0x0c, 0x02, 0x90, 0x0c, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x04, 0x00, 0x01,
    0x12, 0x04, 0x8d, 0x0c, 0x07, 0x0f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2e, 0x04, 0x00, 0x02, 0x00,
    0x12, 0x04, 0x8e, 0x0c, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x04, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x8e, 0x0c, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x04, 0x00, 0x02,
    0x00, 0x02, 0x12, 0x04, 0x8e, 0x0c, 0x0b, 0x0c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2e, 0x04, 0x00,
    0x02, 0x01, 0x12, 0x04, 0x8f, 0x0c, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x04, 0x00,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x8f, 0x0c, 0x04, 0x08, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x04,
    0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0x8f, 0x0c, 0x0b, 0x0c, 0x0a, 0xf9, 0x02, 0x0a, 0x04, 0x04,
    0x2e, 0x03, 0x00, 0x12, 0x06, 0x99, 0x0c, 0x02, 0xa7, 0x0c, 0x03, 0x1a, 0xe8, 0x02, 0x20, 0x53,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72,
    0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x20, 0x55, 0x73, 0x65, 0x72, 0x73, 0x20, 0x63, 0x61, 0x6e,
    0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x61, 0x6e, 0x20, 0x61, 0x75, 0x74, 0x6f,
    0x6d, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e,
    0x65, 0x64, 0x20, 0x49, 0x50, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70,
    0x6c, 0x65, 0x2c, 0x20, 0x76, 0x69, 0x61, 0x20, 0x61, 0x6e, 0x0a, 0x20, 0x49, 0x50, 0x41, 0x4d,
    0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x29, 0x20, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x73,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x49, 0x50, 0x20, 0x62, 0x79, 0x20, 0x61, 0x64,
    0x64, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x4e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x49, 0x6e,
    0x66, 0x6f, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x20, 0x74,
    0x61, 0x73, 0x6b, 0x2e, 0x20, 0x20, 0x4f, 0x6e, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x2c, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x69, 0x6e, 0x67, 0x20, 0x6e,
    0x65, 0x69, 0x74, 0x68, 0x65, 0x72, 0x20, 0x60, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
    0x60, 0x0a, 0x20, 0x6e, 0x6f, 0x72, 0x20, 0x60, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65,
    0x73, 0x73, 0x60, 0x20, 0x6d, 0x65, 0x61, 0x6e, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61,
    0x6e, 0x79, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x61, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x61, 0x73, 0x73, 0x69,
    0x67, 0x6e, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x03, 0x00, 0x01, 0x12,
    0x04, 0x99, 0x0c, 0x0a, 0x13, 0x0a, 0x90, 0x02, 0x0a, 0x06, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0x9e, 0x0c, 0x04, 0x23, 0x1a, 0xff, 0x01, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x79, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x53, 0x65, 0x74, 0x20, 0x70, 0x72,
    0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65,
    0x73, 0x69, 0x72, 0x65, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x0a, 0x20,
    0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77,
    0x6f, 0x72, 0x6b, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x73, 0x73,
    0x69, 0x67, 0x6e, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69,
    0x6e, 0x65, 0x72, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68,
    0x65, 0x64, 0x2e, 0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69,
    0x63, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x69, 0x73, 0x20,
    0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x69, 0x70,
    0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20,
    0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x9e, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03,
    0x00, 0x02, 0x00, 0x06, 0x12, 0x04, 0x9e, 0x0c, 0x0d, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9e, 0x0c, 0x16, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2e, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9e, 0x0c, 0x21, 0x22, 0x0a, 0xc0, 0x02, 0x0a,
    0x06, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x0c, 0x04, 0x23, 0x1a, 0xaf, 0x02,
    0x20, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x61, 0x73, 0x73, 0x69,
    0x67, 0x6e, 0x65, 0x64, 0x20, 0x49, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64,
    0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72,
    0x6b, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x49, 0x50, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x62, 0x79,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x73, 0x6f,
    0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x20, 0x6f, 0x6e, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x69, 0x73,
    0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x61, 0x62, 0x6f, 0x76, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x61, 0x6e,
    0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x62,
    0x75, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
    0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20,
    0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20,
    0x66, 0x61, 0x69, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x61, 0x73, 0x6b, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa6, 0x0c, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa6, 0x0c, 0x0d,
    0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa6, 0x0c,
    0x14, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2e, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6,
    0x0c, 0x21, 0x22, 0x0a, 0xc2, 0x03, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x00, 0x12, 0x04, 0xb1, 0x0c,
    0x02, 0x26, 0x1a, 0xb3, 0x03, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75,
    0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e,
    0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x2c, 0x20, 0x65, 0x61, 0x63, 0x68, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20,
    0x61, 0x0a, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x61,
    0x6e, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x20, 0x45, 0x61,
    0x63, 0x68, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73,
    0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63,
    0x69, 0x74, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x0a, 0x20, 0x6f, 0x72, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x49, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x74,
    0x6f, 0x20, 0x75, 0x73, 0x65, 0x2e, 0x0a, 0x0a, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x69, 0x6e,
    0x63, 0x6c, 0x75, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x54, 0x61, 0x73, 0x6b,
    0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2c, 0x20,
    0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x0a, 0x20, 0x73, 0x63, 0x68, 0x65,
    0x64, 0x75, 0x6c, 0x65, 0x72, 0x20, 0x61, 0x62, 0x6f, 0x75, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61,
    0x74, 0x20, 0x61, 0x72, 0x65, 0x20, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x2e, 0x20, 0x57, 0x68, 0x65, 0x6e, 0x20, 0x74, 0x68,
    0x65, 0x72, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x6e, 0x6f, 0x20, 0x63, 0x75, 0x73, 0x74, 0x6f,
    0x6d, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74,
    0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61,
    0x6c, 0x6c, 0x65, 0x64, 0x2c, 0x0a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x6c, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x61,
    0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x49, 0x50, 0x20, 0x61,
    0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xb1, 0x0c, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xb1, 0x0c, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xb1, 0x0c, 0x15, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xb1, 0x0c, 0x24, 0x25, 0x0a, 0x9e, 0x02, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x01, 0x12, 0x04, 0xb7,
    0x0c, 0x02, 0x35, 0x1a, 0xff, 0x01, 0x20, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x79, 0x20, 0x49,
    0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x53, 0x65, 0x74, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f,
    0x63, 0x6f, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x73, 0x69, 0x72,
    0x65, 0x64, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x20, 0x74, 0x6f, 0x0a, 0x20, 0x72, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e,
    0x20, 0x61, 0x6e, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x74,
    0x6f, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x64, 0x2e,
    0x20, 0x49, 0x66, 0x20, 0x61, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x49,
    0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65,
    0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x0a, 0x20, 0x69, 0x70, 0x5f, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20,
    0x73, 0x65, 0x74, 0x2e, 0x0a, 0x22, 0x0e, 0x20, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x20, 0x30, 0x2e,
    0x32, 0x36, 0x2e, 0x30, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xb7, 0x0c, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x06, 0x12, 0x04, 0xb7,
    0x0c, 0x0b, 0x13, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb7, 0x0c,
    0x14, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb7, 0x0c, 0x1f,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x08, 0x12, 0x04, 0xb7, 0x0c, 0x21, 0x34,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2e, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xb7, 0x0c,
    0x22, 0x33, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2e, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x12,
    0x04, 0xb7, 0x0c, 0x22, 0x2c, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x2e, 0x02, 0x01, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x0c, 0x22, 0x2c, 0x0a, 0x13, 0x0a, 0x0b, 0x04, 0x2e, 0x02,
    0x01, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x0c, 0x22, 0x2c, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x2e, 0x02, 0x01, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x0c, 0x2f,
    0x33, 0x0a, 0xf3, 0x02, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x0c, 0x02, 0x35,
    0x1a, 0xd4, 0x02, 0x20, 0x53, 0x74, 0x61, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x6c, 0x79, 0x20, 0x61,
    0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x20, 0x49, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69,
    0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x46, 0x72, 0x61, 0x6d, 0x65,
    0x77, 0x6f, 0x72, 0x6b, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x49, 0x50, 0x20, 0x77, 0x69,
    0x6c, 0x6c, 0x20, 0x62, 0x65, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x0a, 0x20,
    0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72,
    0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20,
    0x69, 0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x64, 0x75, 0x6c, 0x65, 0x20,
    0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x20, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x0a, 0x20, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64,
    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x20, 0x61, 0x62, 0x6f, 0x76, 0x65, 0x2e, 0x0a, 0x20, 0x4e, 0x4f, 0x54,
    0x45, 0x3a, 0x20, 0x49, 0x74, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x27, 0x70,
    0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x27, 0x20, 0x28, 0x49, 0x50, 0x41, 0x4d, 0x2f, 0x49,
    0x73, 0x6f, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x29, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e, 0x74, 0x65,
    0x72, 0x70, 0x72, 0x65, 0x74, 0x0a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x65, 0x69, 0x74, 0x68,
    0x65, 0x72, 0x20, 0x61, 0x73, 0x20, 0x61, 0x20, 0x68, 0x69, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20,
    0x61, 0x73, 0x20, 0x61, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74,
    0x20, 0x66, 0x6f, 0x72, 0x20, 0x61, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x74,
    0x68, 0x65, 0x20, 0x49, 0x50, 0x2e, 0x0a, 0x22, 0x0e, 0x20, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x20,
    0x30, 0x2e, 0x32, 0x36, 0x2e, 0x30, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xbe, 0x0c, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xbe, 0x0c, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xbe, 0x0c, 0x12, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbe,
    0x0c, 0x1f, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x02, 0x08, 0x12, 0x04, 0xbe, 0x0c,
    0x21, 0x34, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2e, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x12, 0x04,
    0xbe, 0x0c, 0x22, 0x33, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2e, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00,
    0x02, 0x12, 0x04, 0xbe, 0x0c, 0x22, 0x2c, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x2e, 0x02, 0x02, 0x08,
    0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbe, 0x0c, 0x22, 0x2c, 0x0a, 0x13, 0x0a, 0x0b, 0x04,
    0x2e, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbe, 0x0c, 0x22, 0x2c,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2e, 0x02, 0x02, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12, 0x04, 0xbe,
    0x0c, 0x2f, 0x33, 0x0a, 0xe3, 0x02, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x0c,
    0x02, 0x1d, 0x1a, 0xd4, 0x02, 0x20, 0x41, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x69, 0x73,
    0x20, 0x74, 0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x20,
    0x74, 0x6f, 0x20, 0x61, 0x20, 0x73, 0x65, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6c, 0x6f, 0x67, 0x69,
    0x63, 0x61, 0x6c, 0x6c, 0x79, 0x2d, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x20, 0x61,
    0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6f,
    0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x61, 0x6d, 0x6f, 0x6e, 0x67, 0x20,
    0x74, 0x68, 0x65, 0x6d, 0x73, 0x65, 0x6c, 0x76, 0x65, 0x73, 0x2e, 0x20, 0x4e, 0x65, 0x74, 0x77,
    0x6f, 0x72, 0x6b, 0x20, 0x74, 0x72, 0x61, 0x66, 0x66, 0x69, 0x63, 0x20, 0x69, 0x73, 0x20, 0x61,
    0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x0a, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20,
    0x74, 0x77, 0x6f, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6e,
    0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x73, 0x68,
    0x61, 0x72, 0x65, 0x20, 0x61, 0x74, 0x20, 0x6c, 0x65, 0x61, 0x73, 0x74, 0x20, 0x6f, 0x6e, 0x65,
    0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x2e, 0x0a,
    0x20, 0x46, 0x6f, 0x72, 0x20, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2c, 0x20, 0x6f, 0x6e,
    0x65, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x20, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x20,
    0x67, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x73, 0x6f, 0x6c, 0x61,
    0x74, 0x69, 0x6e, 0x67, 0x20, 0x64, 0x65, 0x76, 0x2c, 0x0a, 0x20, 0x74, 0x65, 0x73, 0x74, 0x69,
    0x6e, 0x67, 0x2c, 0x20, 0x71, 0x61, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x70, 0x72, 0x6f, 0x64, 0x20,
    0x64, 0x65, 0x70, 0x6c, 0x6f, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x65, 0x6e, 0x76, 0x69, 0x72,
    0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xc5, 0x0c, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03,
    0x05, 0x12, 0x04, 0xc5, 0x0c, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x01,
    0x12, 0x04, 0xc5, 0x0c, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xc5, 0x0c, 0x1b, 0x1c, 0x0a, 0x55, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x04, 0x12, 0x04, 0xc8,
    0x0c, 0x02, 0x1d, 0x1a, 0x47, 0x20, 0x54, 0x6f, 0x20, 0x74, 0x61, 0x67, 0x20, 0x63, 0x65, 0x72,
    0x74, 0x61, 0x69, 0x6e, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6f,
    0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x49, 0x73, 0x6f, 0x6c,
    0x61, 0x74, 0x6f, 0x72, 0x2f, 0x49, 0x50, 0x41, 0x4d, 0x2c, 0x20, 0x65, 0x2e, 0x67, 0x2e, 0x2c,
    0x20, 0x72, 0x61, 0x63, 0x6b, 0x2c, 0x20, 0x65, 0x74, 0x63, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2e, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc8, 0x0c, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2e, 0x02, 0x04, 0x06, 0x12, 0x04, 0xc8, 0x0c, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xc8, 0x0c, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xc8, 0x0c, 0x1b, 0x1c, 0x0a, 0x84, 0x01, 0x0a, 0x02, 0x04, 0x2f, 0x12,
    0x06, 0xd0, 0x0c, 0x00, 0x8e, 0x0d, 0x01, 0x1a, 0x76, 0x2a, 0x0a, 0x20, 0x44, 0x65, 0x73, 0x63,
    0x72, 0x69, 0x62, 0x65, 0x73, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x61, 0x6e, 0x64, 0x20, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x73, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6e,
    0x73, 0x69, 0x62, 0x6c, 0x65, 0x0a, 0x20, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72,
    0x65, 0x6e, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d,
    0x70, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x2f, 0x01, 0x12, 0x04, 0xd0, 0x0c, 0x08, 0x15, 0x0a, 0x35, 0x0a, 0x04,
    0x04, 0x2f, 0x04, 0x00, 0x12, 0x06, 0xd2, 0x0c, 0x02, 0xd5, 0x0c, 0x03, 0x1a, 0x25, 0x20, 0x41,
    0x6c, 0x6c, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x70,
    0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x04, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x0c,
    0x07, 0x0b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd3, 0x0c,
    0x04, 0x0f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd3,
    0x0c, 0x04, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04,
    0xd3, 0x0c, 0x0d, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xd4, 0x0c, 0x04, 0x0e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xd4, 0x0c, 0x04, 0x09, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x04, 0x00, 0x02, 0x01, 0x02,
    0x12, 0x04, 0xd4, 0x0c, 0x0c, 0x0d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2f, 0x03, 0x00, 0x12, 0x06,
    0xd7, 0x0c, 0x02, 0xfc, 0x0c, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xd7, 0x0c, 0x0a, 0x14, 0x0a, 0x4e, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xd9, 0x0c, 0x04, 0x1e, 0x1a, 0x3e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b,
    0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73,
    0x20, 0x67, 0x6f, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73,
    0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73,
    0x74, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xd9, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xd9, 0x0c, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xd9, 0x0c, 0x14, 0x19, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xd9, 0x0c, 0x1c, 0x1d, 0x0a, 0x24, 0x0a, 0x06, 0x04, 0x2f, 0x03,
    0x00, 0x04, 0x00, 0x12, 0x06, 0xdc, 0x0c, 0x04, 0xe0, 0x0c, 0x05, 0x1a, 0x12, 0x20, 0x4e, 0x65,
    0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x0a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x0c, 0x09, 0x10,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x0c,
    0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xdd, 0x0c, 0x06, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02,
    0x00, 0x02, 0x12, 0x04, 0xdd, 0x0c, 0x0d, 0x0e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2f, 0x03, 0x00,
    0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xde, 0x0c, 0x06, 0x11, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f,
    0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xde, 0x0c, 0x06, 0x0c, 0x0a, 0x11, 0x0a,
    0x09, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xde, 0x0c, 0x0f, 0x10,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xdf, 0x0c,
    0x06, 0x0f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xdf, 0x0c, 0x06, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x04, 0x00, 0x02,
    0x02, 0x02, 0x12, 0x04, 0xdf, 0x0c, 0x0d, 0x0e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0xe2, 0x0c, 0x04, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xe2, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03,
    0x00, 0x02, 0x01, 0x06, 0x12, 0x04, 0xe2, 0x0c, 0x0d, 0x14, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x0c, 0x15, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2f, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe2, 0x0c, 0x1f, 0x20, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2f, 0x03, 0x00, 0x02, 0x01, 0x08, 0x12, 0x04, 0xe2, 0x0c, 0x21, 0x31, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x01, 0x07, 0x12, 0x04, 0xe2, 0x0c, 0x2c, 0x30, 0x0a, 0x10,
    0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x12, 0x06, 0xe4, 0x0c, 0x04, 0xe9, 0x0c, 0x05,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x0c, 0x0c,
    0x17, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe5,
    0x0c, 0x06, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe5, 0x0c, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xe5, 0x0c, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe5, 0x0c, 0x16, 0x1f, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe5, 0x0c, 0x22, 0x23, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x0c, 0x06,
    0x29, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xe6, 0x0c, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xe6, 0x0c, 0x0f, 0x15, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe6, 0x0c, 0x16, 0x24, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f,
    0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe6, 0x0c, 0x27, 0x28, 0x0a, 0x39, 0x0a,
    0x08, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe8, 0x0c, 0x06, 0x23, 0x1a,
    0x27, 0x20, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x20, 0x74, 0x6f, 0x20, 0x65, 0x78,
    0x70, 0x6f, 0x73, 0x65, 0x20, 0x61, 0x73, 0x20, 0x28, 0x69, 0x65, 0x3a, 0x20, 0x74, 0x63, 0x70,
    0x2c, 0x20, 0x75, 0x64, 0x70, 0x29, 0x2e, 0x0a, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00,
    0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe8, 0x0c, 0x06, 0x0e, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe8, 0x0c, 0x0f, 0x15, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe8, 0x0c, 0x16,
    0x1e, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x2f, 0x03, 0x00, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xe8, 0x0c, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04,
    0xeb, 0x0c, 0x04, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xeb, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xeb, 0x0c, 0x0d, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xeb, 0x0c, 0x19, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xeb, 0x0c, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x03, 0x12, 0x04, 0xed, 0x0c, 0x04, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xed, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03,
    0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xed, 0x0c, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f,
    0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xed, 0x0c, 0x12, 0x1c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2f, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xed, 0x0c, 0x1f, 0x20, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2f, 0x03, 0x00, 0x02, 0x03, 0x08, 0x12, 0x04, 0xed, 0x0c, 0x21, 0x32, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x03, 0x07, 0x12, 0x04, 0xed, 0x0c, 0x2c, 0x31, 0x0a, 0xd4,
    0x01, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x0c, 0x04, 0x26, 0x1a,
    0xc3, 0x01, 0x20, 0x41, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x72, 0x62, 0x69,
    0x74, 0x72, 0x61, 0x72, 0x79, 0x20, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73,
    0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x43, 0x4c, 0x49, 0x2e, 0x0a, 0x20, 0x4e, 0x6f,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67,
    0x20, 0x70, 0x61, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20,
    0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x67, 0x75, 0x61,
    0x72, 0x61, 0x6e, 0x74, 0x65, 0x65, 0x64, 0x0a, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x73,
    0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x6d, 0x6f, 0x76, 0x69, 0x6e, 0x67, 0x20,
    0x66, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x20, 0x6d,
    0x69, 0x67, 0x68, 0x74, 0x20, 0x6d, 0x6f, 0x76, 0x65, 0x20, 0x61, 0x77, 0x61, 0x79, 0x20, 0x66,
    0x72, 0x6f, 0x6d, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20,
    0x43, 0x4c, 0x49, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xf3, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x04,
    0x06, 0x12, 0x04, 0xf3, 0x0c, 0x0d, 0x16, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xf3, 0x0c, 0x17, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xf3, 0x0c, 0x24, 0x25, 0x0a, 0xac, 0x01, 0x0a, 0x06, 0x04, 0x2f,
    0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xf8, 0x0c, 0x04, 0x27, 0x1a, 0x9b, 0x01, 0x20, 0x57, 0x69,
    0x74, 0x68, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x61, 0x67, 0x20, 0x73, 0x65, 0x74,
    0x20, 0x74, 0x6f, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x6f,
    0x63, 0x6b, 0x65, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x69, 0x7a,
    0x65, 0x72, 0x20, 0x77, 0x69, 0x6c, 0x6c, 0x0a, 0x20, 0x70, 0x75, 0x6c, 0x6c, 0x20, 0x74, 0x68,
    0x65, 0x20, 0x64, 0x6f, 0x63, 0x6b, 0x65, 0x72, 0x20, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x20, 0x66,
    0x72, 0x6f, 0x6d, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79,
    0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x69, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x69, 0x6d, 0x61,
    0x67, 0x65, 0x0a, 0x20, 0x69, 0x73, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x64,
    0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x61, 0x67, 0x65, 0x6e, 0x74, 0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00,
    0x02, 0x05, 0x04, 0x12, 0x04, 0xf8, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03,
    0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xf8, 0x0c, 0x0d, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f,
    0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf8, 0x0c, 0x12, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2f, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf8, 0x0c, 0x25, 0x26, 0x0a, 0x33, 0x0a, 0x06,
    0x04, 0x2f, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0xfb, 0x0c, 0x04, 0x26, 0x1a, 0x23, 0x20, 0x54,
    0x68, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x76, 0x6f, 0x6c, 0x75, 0x6d,
    0x65, 0x20, 0x64, 0x72, 0x69, 0x76, 0x65, 0x72, 0x20, 0x70, 0x6c, 0x75, 0x67, 0x69, 0x6e, 0x2e,
    0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xfb, 0x0c,
    0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xfb,
    0x0c, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04,
    0xfb, 0x0c, 0x14, 0x21, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xfb, 0x0c, 0x24, 0x25, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2f, 0x03, 0x01, 0x12, 0x06, 0xfe,
    0x0c, 0x02, 0x80, 0x0d, 0x03, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x03, 0x01, 0x01, 0x12, 0x04,
    0xfe, 0x0c, 0x0a, 0x13, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2f, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xff, 0x0c, 0x04, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xff, 0x0c, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x01, 0x02, 0x00, 0x06,
    0x12, 0x04, 0xff, 0x0c, 0x0d, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xff, 0x0c, 0x13, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2f, 0x03, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xff, 0x0c, 0x1b, 0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x00,
    0x12, 0x04, 0x82, 0x0d, 0x02, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x82, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x06, 0x12, 0x04,
    0x82, 0x0d, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82,
    0x0d, 0x10, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x0d,
    0x17, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x01, 0x12, 0x04, 0x83, 0x0d, 0x02, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x04, 0x12, 0x04, 0x83, 0x0d, 0x02, 0x0a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x06, 0x12, 0x04, 0x83, 0x0d, 0x0b, 0x11, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x01, 0x12, 0x04, 0x83, 0x0d, 0x12, 0x19, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2f, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83, 0x0d, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x2f, 0x02, 0x02, 0x12, 0x04, 0x84, 0x0d, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f,
    0x02, 0x02, 0x04, 0x12, 0x04, 0x84, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x84, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x02,
    0x01, 0x12, 0x04, 0x84, 0x0d, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x02, 0x03,
    0x12, 0x04, 0x84, 0x0d, 0x1d, 0x1e, 0x0a, 0x5a, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x03, 0x12, 0x04,
    0x88, 0x0d, 0x02, 0x21, 0x1a, 0x4c, 0x20, 0x4f, 0x6e, 0x6c, 0x79, 0x20, 0x6f, 0x6e, 0x65, 0x20,
    0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x6f, 0x6c, 0x6c, 0x6f, 0x77, 0x69, 0x6e, 0x67,
    0x20, 0x2a, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x62, 0x65, 0x20, 0x73, 0x65, 0x74, 0x20, 0x74, 0x6f,
    0x20, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x0a, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x79, 0x70, 0x65,
    0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x04, 0x12, 0x04, 0x88, 0x0d, 0x02,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x06, 0x12, 0x04, 0x88, 0x0d, 0x0b, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x01, 0x12, 0x04, 0x88, 0x0d, 0x16, 0x1c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x03, 0x12, 0x04, 0x88, 0x0d, 0x1f, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x2f, 0x02, 0x04, 0x12, 0x04, 0x89, 0x0d, 0x02, 0x1f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2f, 0x02, 0x04, 0x04, 0x12, 0x04, 0x89, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2f, 0x02, 0x04, 0x06, 0x12, 0x04, 0x89, 0x0d, 0x0b, 0x14, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f,
    0x02, 0x04, 0x01, 0x12, 0x04, 0x89, 0x0d, 0x15, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02,
    0x04, 0x03, 0x12, 0x04, 0x89, 0x0d, 0x1d, 0x1e, 0x0a, 0x6d, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x05,
    0x12, 0x04, 0x8d, 0x0d, 0x02, 0x29, 0x1a, 0x5f, 0x20, 0x41, 0x20, 0x6c, 0x69, 0x73, 0x74, 0x20,
    0x6f, 0x66, 0x20, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65,
    0x73, 0x74, 0x73, 0x2e, 0x20, 0x41, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b,
    0x20, 0x63, 0x61, 0x6e, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x6d, 0x75, 0x6c,
    0x74, 0x69, 0x70, 0x6c, 0x65, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
    0x65, 0x73, 0x0a, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e, 0x74,
    0x61, 0x69, 0x6e, 0x65, 0x72, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x05, 0x04,
    0x12, 0x04, 0x8d, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x05, 0x06, 0x12,
    0x04, 0x8d, 0x0d, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x05, 0x01, 0x12, 0x04,
    0x8d, 0x0d, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x05, 0x03, 0x12, 0x04, 0x8d,
    0x0d, 0x27, 0x28, 0x0a, 0xac, 0x01, 0x0a, 0x02, 0x04, 0x30, 0x12, 0x06, 0x96, 0x0d, 0x00, 0x9c,
    0x0d, 0x01, 0x1a, 0x9d, 0x01, 0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65,
    0x72, 0x20, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d,
    0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x69, 0x73, 0x20, 0x72, 0x65,
    0x73, 0x6f, 0x6c, 0x76, 0x65, 0x64, 0x20, 0x64, 0x75, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x63, 0x6f,
    0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x0a, 0x20, 0x73, 0x65, 0x74, 0x75, 0x70, 0x2e, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x69, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20,
    0x69, 0x73, 0x20, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x62, 0x61, 0x63, 0x6b, 0x20, 0x74, 0x6f, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x61, 0x73,
    0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x54, 0x61,
    0x73, 0x6b, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x30, 0x01, 0x12, 0x04, 0x96, 0x0d, 0x08, 0x17, 0x0a,
    0x55, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x00, 0x12, 0x04, 0x98, 0x0d, 0x02, 0x29, 0x1a, 0x47, 0x20,
    0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62,
    0x65, 0x20, 0x72, 0x65, 0x6c, 0x69, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20,
    0x74, 0x6f, 0x20, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x20, 0x49, 0x50, 0x20, 0x61, 0x64, 0x64,
    0x72, 0x65, 0x73, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x98, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x06, 0x12, 0x04,
    0x98, 0x0d, 0x0b, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x01, 0x12, 0x04, 0x98,
    0x0d, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x03, 0x12, 0x04, 0x98, 0x0d,
    0x27, 0x28, 0x0a, 0x3f, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x0d, 0x02, 0x26,
    0x1a, 0x31, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61,
    0x62, 0x6f, 0x75, 0x74, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x72,
    0x6f, 0x6c, 0x20, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x28, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70,
    0x29, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9b, 0x0d,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x06, 0x12, 0x04, 0x9b, 0x0d, 0x0b,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9b, 0x0d, 0x16, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9b, 0x0d, 0x24, 0x25, 0x0a,
    0x3b, 0x0a, 0x02, 0x04, 0x31, 0x12, 0x06, 0xa2, 0x0d, 0x00, 0xad, 0x0d, 0x01, 0x1a, 0x2d, 0x2a,
    0x0a, 0x20, 0x4c, 0x69, 0x6e, 0x75, 0x78, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x6f, 0x6c, 0x20,
    0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x28, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x29, 0x20, 0x69,
    0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x31, 0x01, 0x12, 0x04, 0xa2, 0x0d, 0x08, 0x12, 0x0a, 0x3e, 0x0a, 0x04, 0x04, 0x31, 0x03,
    0x00, 0x12, 0x06, 0xa4, 0x0d, 0x02, 0xaa, 0x0d, 0x03, 0x1a, 0x2e, 0x20, 0x43, 0x6f, 0x6e, 0x66,
    0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x20, 0x6e,
    0x65, 0x74, 0x5f, 0x63, 0x6c, 0x73, 0x20, 0x63, 0x67, 0x72, 0x6f, 0x75, 0x70, 0x20, 0x73, 0x75,
    0x62, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x03,
    0x00, 0x01, 0x12, 0x04, 0xa4, 0x0d, 0x0a, 0x10, 0x0a, 0x87, 0x02, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x0d, 0x04, 0x20, 0x1a, 0xf6, 0x01, 0x20, 0x54, 0x68, 0x65,
    0x20, 0x33, 0x32, 0x2d, 0x62, 0x69, 0x74, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x69, 0x64, 0x20,
    0x63, 0x6f, 0x6e, 0x73, 0x69, 0x73, 0x74, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x77, 0x6f, 0x20,
    0x70, 0x61, 0x72, 0x74, 0x73, 0x2c, 0x20, 0x61, 0x20, 0x31, 0x36, 0x20, 0x62, 0x69, 0x74, 0x20,
    0x6d, 0x61, 0x6a, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x0a, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x61, 0x20, 0x31, 0x36, 0x2d, 0x62, 0x69, 0x74, 0x20, 0x6d, 0x69, 0x6e, 0x6f, 0x72,
    0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x6d, 0x61, 0x6a,
    0x6f, 0x72, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x6e,
    0x64, 0x6c, 0x65, 0x20, 0x61, 0x72, 0x65, 0x0a, 0x20, 0x72, 0x65, 0x70, 0x72, 0x65, 0x73, 0x65,
    0x6e, 0x74, 0x65, 0x64, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66,
    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x30, 0x78, 0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42,
    0x2c, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x30, 0x78, 0x41, 0x41, 0x41, 0x41, 0x20, 0x69,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x20, 0x31, 0x36, 0x2d, 0x62, 0x69, 0x74, 0x20, 0x6d, 0x61,
    0x6a, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x30,
    0x78, 0x42, 0x42, 0x42, 0x42, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x31, 0x36, 0x2d,
    0x62, 0x69, 0x74, 0x20, 0x6d, 0x69, 0x6e, 0x6f, 0x72, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65,
    0x2e, 0x0a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa9,
    0x0d, 0x04, 0x0c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xa9, 0x0d, 0x0d, 0x13, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa9, 0x0d, 0x14, 0x1b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xa9, 0x0d, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x00, 0x12, 0x04,
    0xac, 0x0d, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x04, 0x12, 0x04, 0xac,
    0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x06, 0x12, 0x04, 0xac, 0x0d,
    0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x01, 0x12, 0x04, 0xac, 0x0d, 0x12,
    0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00, 0x03, 0x12, 0x04, 0xac, 0x0d, 0x1c, 0x1d,
    0x0a, 0x5d, 0x0a, 0x02, 0x04, 0x32, 0x12, 0x06, 0xb4, 0x0d, 0x00, 0xb6, 0x0d, 0x01, 0x1a, 0x4f,
    0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66,
    0x20, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x2e, 0x20, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x20,
    0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x63, 0x6f, 0x6e, 0x74, 0x61,
    0x69, 0x6e, 0x20, 0x64, 0x75, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x6b, 0x65, 0x79,
    0x2d, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x0a, 0x20, 0x70, 0x61, 0x69, 0x72, 0x73, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x32, 0x01, 0x12, 0x04, 0xb4, 0x0d, 0x08, 0x0e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x32, 0x02, 0x00, 0x12, 0x04, 0xb5, 0x0d, 0x02, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xb5, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xb5, 0x0d, 0x0b, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xb5, 0x0d, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xb5, 0x0d, 0x1a, 0x1b, 0x0a, 0x44, 0x0a, 0x02, 0x04, 0x33, 0x12, 0x06, 0xbc, 0x0d,
    0x00, 0xbf, 0x0d, 0x01, 0x1a, 0x36, 0x2a, 0x0a, 0x20, 0x4b, 0x65, 0x79, 0x2c, 0x20, 0x76, 0x61,
    0x6c, 0x75, 0x65, 0x20, 0x70, 0x61, 0x69, 0x72, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f,
    0x20, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x20, 0x66, 0x72, 0x65, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x6d,
    0x20, 0x75, 0x73, 0x65, 0x72, 0x2d, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x33, 0x01, 0x12, 0x04, 0xbc, 0x0d, 0x08, 0x0d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02,
    0x00, 0x12, 0x04, 0xbd, 0x0d, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xbd, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xbd, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xbd, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbd,
    0x0d, 0x18, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x0d, 0x02,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbe, 0x0d, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbe, 0x0d, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbe, 0x0d, 0x12, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbe, 0x0d, 0x1a, 0x1b, 0x0a, 0x38, 0x0a,
    0x02, 0x04, 0x34, 0x12, 0x06, 0xc5, 0x0d, 0x00, 0xd4, 0x0d, 0x01, 0x1a, 0x2a, 0x2a, 0x0a, 0x20,
    0x4e, 0x61, 0x6d, 0x65, 0x64, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20,
    0x66, 0x6f, 0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63,
    0x6f, 0x76, 0x65, 0x72, 0x79, 0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x34, 0x01, 0x12, 0x04,
    0xc5, 0x0d, 0x08, 0x0c, 0x0a, 0x45, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x00, 0x12, 0x04, 0xc7, 0x0d,
    0x02, 0x1d, 0x1a, 0x37, 0x20, 0x50, 0x6f, 0x72, 0x74, 0x20, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72,
    0x20, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x73, 0x20,
    0x61, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x34, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc7, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xc7, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xc7, 0x0d, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xc7, 0x0d, 0x1b, 0x1c, 0x0a, 0x38, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x01, 0x12,
    0x04, 0xc9, 0x0d, 0x02, 0x1b, 0x1a, 0x2a, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x20, 0x6f, 0x66, 0x20,
    0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x68, 0x6f, 0x73, 0x74,
    0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x2e,
    0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc9, 0x0d, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc9, 0x0d, 0x0b, 0x11, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc9, 0x0d, 0x12, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x34, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc9, 0x0d, 0x19, 0x1a, 0x0a, 0x4f, 0x0a,
    0x04, 0x04, 0x34, 0x02, 0x02, 0x12, 0x04, 0xcb, 0x0d, 0x02, 0x1f, 0x1a, 0x41, 0x20, 0x4c, 0x61,
    0x79, 0x65, 0x72, 0x20, 0x34, 0x2d, 0x37, 0x20, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c,
    0x20, 0x6f, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x65, 0x78, 0x70, 0x6f, 0x73, 0x65, 0x73, 0x20,
    0x69, 0x74, 0x73, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x34, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcb, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x34, 0x02, 0x02, 0x05, 0x12, 0x04, 0xcb, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x34, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcb, 0x0d, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x34, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcb, 0x0d, 0x1d, 0x1e, 0x0a, 0xfb, 0x01, 0x0a, 0x04, 0x04,
    0x34, 0x02, 0x03, 0x12, 0x04, 0xd0, 0x0d, 0x02, 0x33, 0x1a, 0xec, 0x01, 0x20, 0x54, 0x68, 0x69,
    0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74,
    0x73, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68,
    0x69, 0x6e, 0x20, 0x61, 0x20, 0x66, 0x72, 0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x28,
    0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f, 0x52, 0x4b, 0x29, 0x2c, 0x0a, 0x20, 0x77, 0x69, 0x74,
    0x68, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x4d, 0x65, 0x73, 0x6f, 0x73, 0x20, 0x63, 0x6c, 0x75, 0x73,
    0x74, 0x65, 0x72, 0x20, 0x28, 0x43, 0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x29, 0x2c, 0x20, 0x6f,
    0x72, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x73, 0x20, 0x6e, 0x6f, 0x20, 0x72, 0x65, 0x73, 0x74,
    0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x28, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e,
    0x41, 0x4c, 0x29, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69,
    0x6c, 0x69, 0x74, 0x79, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x66, 0x6f, 0x72,
    0x20, 0x61, 0x20, 0x50, 0x6f, 0x72, 0x74, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65,
    0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x20, 0x76, 0x69,
    0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67,
    0x0a, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65,
    0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xd0, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x03, 0x06,
    0x12, 0x04, 0xd0, 0x0d, 0x0b, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xd0, 0x0d, 0x24, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xd0, 0x0d, 0x31, 0x32, 0x0a, 0x85, 0x01, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x04, 0x12, 0x04, 0xd3,
    0x0d, 0x02, 0x1d, 0x1a, 0x77, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x62,
    0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x64, 0x65, 0x63, 0x6f, 0x72, 0x61,
    0x74, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 0x77,
    0x69, 0x74, 0x68, 0x20, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x20, 0x74, 0x6f, 0x20,
    0x62, 0x65, 0x0a, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x72, 0x65, 0x74, 0x65, 0x64, 0x20,
    0x62, 0x79, 0x20, 0x65, 0x78, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x20, 0x61, 0x70, 0x70, 0x6c,
    0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20, 0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73,
    0x20, 0x66, 0x69, 0x72, 0x65, 0x77, 0x61, 0x6c, 0x6c, 0x73, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x34, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd3, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x34, 0x02, 0x04, 0x06, 0x12, 0x04, 0xd3, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34,
    0x02, 0x04, 0x01, 0x12, 0x04, 0xd3, 0x0d, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xd3, 0x0d, 0x1b, 0x1c, 0x0a, 0x26, 0x0a, 0x02, 0x04, 0x35, 0x12, 0x06,
    0xda, 0x0d, 0x00, 0xdc, 0x0d, 0x01, 0x1a, 0x18, 0x2a, 0x0a, 0x20, 0x43, 0x6f, 0x6c, 0x6c, 0x65,
    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x2e, 0x0a,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x35, 0x01, 0x12, 0x04, 0xda, 0x0d, 0x08, 0x0d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x35, 0x02, 0x00, 0x12, 0x04, 0xdb, 0x0d, 0x02, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x35, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdb, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xdb, 0x0d, 0x0b, 0x0f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xdb, 0x0d, 0x10, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xdb, 0x0d, 0x18, 0x19, 0x0a, 0x95, 0x06, 0x0a, 0x02, 0x04, 0x36, 0x12, 0x06,
    0xed, 0x0d, 0x00, 0xfb, 0x0d, 0x01, 0x1a, 0x86, 0x06, 0x2a, 0x0a, 0x20, 0x53, 0x65, 0x72, 0x76,
    0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x69, 0x6e,
    0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20,
    0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64,
    0x20, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x73, 0x20, 0x64, 0x69, 0x73, 0x63, 0x6f,
    0x76, 0x65, 0x72, 0x79, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x66, 0x72,
    0x61, 0x6d, 0x65, 0x77, 0x6f, 0x72, 0x6b, 0x20, 0x28, 0x46, 0x52, 0x41, 0x4d, 0x45, 0x57, 0x4f,
    0x52, 0x4b, 0x29, 0x2c, 0x0a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x61, 0x20, 0x4d,
    0x65, 0x73, 0x6f, 0x73, 0x20, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x20, 0x28, 0x43, 0x4c,
    0x55, 0x53, 0x54, 0x45, 0x52, 0x29, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65,
    0x73, 0x20, 0x6e, 0x6f, 0x20, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e,
    0x73, 0x20, 0x28, 0x45, 0x58, 0x54, 0x45, 0x52, 0x4e, 0x41, 0x4c, 0x29, 0x2e, 0x0a, 0x20, 0x45,
    0x61, 0x63, 0x68, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20,
    0x70, 0x6f, 0x72, 0x74, 0x73, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x61, 0x6c, 0x73, 0x6f,
    0x20, 0x68, 0x61, 0x73, 0x20, 0x61, 0x6e, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c,
    0x20, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x66, 0x69, 0x65, 0x6c,
    0x64, 0x2e, 0x0a, 0x20, 0x49, 0x66, 0x20, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74,
    0x79, 0x20, 0x69, 0x73, 0x20, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x65, 0x64, 0x20, 0x66,
    0x6f, 0x72, 0x20, 0x61, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x6f, 0x76,
    0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x65, 0x66, 0x61,
    0x75, 0x6c, 0x74, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2d, 0x77, 0x69, 0x64, 0x65,
    0x0a, 0x20, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x49, 0x6e, 0x66, 0x6f, 0x2e,
    0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74,
    0x68, 0x61, 0x74, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x2e, 0x0a, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65,
    0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x2c, 0x20, 0x6c, 0x6f, 0x63, 0x61,
    0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
    0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65,
    0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x20, 0x73, 0x75, 0x70,
    0x70, 0x6f, 0x72, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x0a, 0x20, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
    0x20, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x20, 0x75, 0x73, 0x65, 0x64,
    0x20, 0x74, 0x6f, 0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x74,
    0x65, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x73, 0x69, 0x6d, 0x69, 0x6c, 0x61,
    0x72, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x0a,
    0x20, 0x65, 0x6e, 0x76, 0x69, 0x72, 0x6f, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x79,
    0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20,
    0x73, 0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x50, 0x52, 0x4f, 0x44, 0x2f, 0x51, 0x41, 0x2f,
    0x44, 0x45, 0x56, 0x2c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f,
    0x6e, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x79, 0x0a, 0x20, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6c, 0x69, 0x6b, 0x65,
    0x20, 0x45, 0x41, 0x53, 0x54, 0x2d, 0x55, 0x53, 0x2f, 0x57, 0x45, 0x53, 0x54, 0x2d, 0x55, 0x53,
    0x2f, 0x45, 0x55, 0x52, 0x4f, 0x50, 0x45, 0x2f, 0x41, 0x4d, 0x45, 0x41, 0x2c, 0x20, 0x61, 0x6e,
    0x64, 0x20, 0x74, 0x68, 0x65, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x66, 0x69,
    0x65, 0x6c, 0x64, 0x20, 0x6d, 0x61, 0x79, 0x0a, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65,
    0x20, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x76, 0x32, 0x2e,
    0x30, 0x2f, 0x76, 0x30, 0x2e, 0x39, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x65, 0x78, 0x61, 0x63,
    0x74, 0x20, 0x75, 0x73, 0x65, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x66,
    0x69, 0x65, 0x6c, 0x64, 0x73, 0x20, 0x69, 0x73, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x65,
    0x61, 0x63, 0x68, 0x0a, 0x20, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x64, 0x69, 0x73,
    0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2e, 0x0a, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x36, 0x01, 0x12, 0x04, 0xed, 0x0d, 0x08, 0x15, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x36, 0x04, 0x00, 0x12, 0x06, 0xee, 0x0d, 0x02, 0xf2, 0x0d, 0x03, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x36, 0x04, 0x00, 0x01, 0x12, 0x04, 0xee, 0x0d, 0x07, 0x11, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x36, 0x04, 0x00, 0x02, 0x00, 0x12, 0x04, 0xef, 0x0d, 0x04, 0x12, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x36, 0x04, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xef, 0x0d, 0x04, 0x0d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x36, 0x04, 0x00, 0x02, 0x00, 0x02, 0x12, 0x04, 0xef, 0x0d, 0x10, 0x11, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x36, 0x04, 0x00, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x0d, 0x04, 0x10, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x36, 0x04, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf0, 0x0d, 0x04, 0x0b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x36, 0x04, 0x00, 0x02, 0x01, 0x02, 0x12, 0x04, 0xf0, 0x0d, 0x0e, 0x0f, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x36, 0x04, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf1, 0x0d, 0x04, 0x11, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x36, 0x04, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf1, 0x0d, 0x04, 0x0c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x04, 0x00, 0x02, 0x02, 0x02, 0x12, 0x04, 0xf1, 0x0d, 0x0f,
    0x10, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x00, 0x12, 0x04, 0xf4, 0x0d, 0x02, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf4, 0x0d, 0x02, 0x0a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x06, 0x12, 0x04, 0xf4, 0x0d, 0x0b, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x36, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf4, 0x0d, 0x16, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x36, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf4, 0x0d, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x36, 0x02, 0x01, 0x12, 0x04, 0xf5, 0x0d, 0x02, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf5, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xf5, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xf5, 0x0d, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xf5, 0x0d, 0x19, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x02, 0x12, 0x04, 0xf6,
    0x0d, 0x02, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf6, 0x0d,
    0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf6, 0x0d, 0x0b,
    0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf6, 0x0d, 0x12, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf6, 0x0d, 0x20, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x03, 0x12, 0x04, 0xf7, 0x0d, 0x02, 0x1f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x36, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf7, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x36, 0x02, 0x03, 0x05, 0x12, 0x04, 0xf7, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x36, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf7, 0x0d, 0x12, 0x1a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xf7, 0x0d, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02,
    0x04, 0x12, 0x04, 0xf8, 0x0d, 0x02, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xf8, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xf8, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xf8, 0x0d, 0x12, 0x19, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf8,
    0x0d, 0x1c, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x05, 0x12, 0x04, 0xf9, 0x0d, 0x02,
    0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x04, 0x12, 0x04, 0xf9, 0x0d, 0x02, 0x0a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x06, 0x12, 0x04, 0xf9, 0x0d, 0x0b, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf9, 0x0d, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x36, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf9, 0x0d, 0x19, 0x1a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x36, 0x02, 0x06, 0x12, 0x04, 0xfa, 0x0d, 0x02, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x36, 0x02, 0x06, 0x04, 0x12, 0x04, 0xfa, 0x0d, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36,
    0x02, 0x06, 0x06, 0x12, 0x04, 0xfa, 0x0d, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xfa, 0x0d, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xfa, 0x0d, 0x1b, 0x1c, 0x0a, 0x69, 0x0a, 0x02, 0x04, 0x37, 0x12, 0x06, 0x82,
    0x0e, 0x00, 0x87, 0x0e, 0x01, 0x1a, 0x5b, 0x2a, 0x0a, 0x20, 0x4e, 0x61, 0x6d, 0x65, 0x64, 0x20,
    0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x20, 0x74, 0x6f, 0x20, 0x69, 0x6e,
    0x64, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x72, 0x65, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x20,
    0x61, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x20, 0x70, 0x72, 0x69, 0x6f,
    0x72, 0x69, 0x74, 0x79, 0x20, 0x62, 0x65, 0x74, 0x77, 0x65, 0x65, 0x6e, 0x20, 0x74, 0x68, 0x65,
    0x20, 0x64, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x74, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x73,
    0x2e, 0x0a, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x37, 0x01, 0x12, 0x04, 0x82, 0x0e, 0x08, 0x12, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x00, 0x12, 0x04, 0x83, 0x0e, 0x02, 0x1d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x37, 0x02, 0x00, 0x04, 0x12, 0x04, 0x83, 0x0e, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x37, 0x02, 0x00, 0x05, 0x12, 0x04, 0x83, 0x0e, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x37, 0x02, 0x00, 0x01, 0x12, 0x04, 0x83, 0x0e, 0x12, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x0e, 0x1b, 0x1c, 0x0a, 0x22, 0x0a, 0x04, 0x04, 0x37, 0x02,
    0x01, 0x12, 0x04, 0x86, 0x0e, 0x02, 0x1b, 0x1a, 0x14, 0x20, 0x52, 0x65, 0x6c, 0x61, 0x74, 0x65,
    0x64, 0x20, 0x72, 0x6f, 0x6c, 0x65, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x37, 0x02, 0x01, 0x04, 0x12, 0x04, 0x86, 0x0e, 0x02, 0x0a, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x37, 0x02, 0x01, 0x05, 0x12, 0x04, 0x86, 0x0e, 0x0b, 0x11, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x37, 0x02, 0x01, 0x01, 0x12, 0x04, 0x86, 0x0e, 0x12, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x86, 0x0e, 0x19, 0x1a,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
